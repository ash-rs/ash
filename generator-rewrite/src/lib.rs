mod items;

use analysis::{
    items::{Origin, RequiredBy},
    Analysis, LibraryId,
};
use proc_macro2::TokenStream;
use quote::{format_ident, quote};
use std::{
    collections::{HashMap, HashSet},
    fs, io,
    path::{Path, PathBuf},
};

#[derive(Debug, Clone, Copy, Hash, PartialEq, Eq)]
pub struct Destination(pub Origin);

impl Destination {
    fn path(&self) -> PathBuf {
        let mut path = PathBuf::new();
        path.push(self.0.library_id.to_string());
        path.push(match self.0.required_by {
            RequiredBy::Feature { major, minor } => format!("version{major}_{minor}.rs"),
            RequiredBy::Extension { name } => {
                let prefix = match self.0.library_id {
                    LibraryId::Vk => "vk_",
                    LibraryId::Video => "vulkan_video_",
                };

                format!(
                    "extension/{}.rs",
                    name.to_ascii_lowercase().strip_prefix(prefix).unwrap()
                )
            }
        });

        path
    }
}

impl From<Origin> for Destination {
    fn from(value: Origin) -> Self {
        Destination(value)
    }
}

#[derive(Default)]
pub struct CodeMap(HashMap<Destination, TokenStream>);

impl CodeMap {
    pub fn new(destination: impl Into<Destination>, tokens: TokenStream) -> CodeMap {
        let mut map = HashMap::with_capacity(1);
        map.insert(destination.into(), tokens);
        CodeMap(map)
    }

    pub fn extend(&mut self, other: CodeMap) {
        for (destination, tokens) in other.0 {
            self.0.entry(destination).or_default().extend(tokens);
        }
    }
}

pub fn generate(analysis: &Analysis, output_path: impl AsRef<Path>) -> io::Result<()> {
    fn file(content: TokenStream) -> String {
        format!(
            "// DO NOT EDIT: @generated by ash {} {}\n{}",
            env!("CARGO_PKG_NAME"),
            env!("CARGO_PKG_VERSION"),
            prettyplease::unparse(&syn::parse2(content).unwrap())
        )
    }

    let codemap = items::build_codemap(analysis);

    let output_path = output_path.as_ref();
    if output_path.exists() {
        fs::remove_dir_all(output_path)?;
    }

    let mut modules: HashMap<PathBuf, HashSet<String>> = Default::default();
    for destination in codemap.0.keys() {
        let mut module_path = destination.path();
        while let Some(file_name) = module_path
            .file_stem()
            .map(|s| s.to_str().unwrap().to_owned())
        {
            if !module_path.pop() {
                break;
            }

            modules
                .entry(module_path.clone())
                .or_default()
                .insert(file_name);
        }
    }

    for (module_path, items) in modules {
        let top_level_module = module_path.parent().is_none();
        let output_path = output_path.join(module_path);
        fs::create_dir_all(&output_path)?;

        let mut modules: Vec<_> = items.iter().collect();
        modules.sort_unstable();
        let mod_idents = modules.iter().map(|item| format_ident!("{}", item));
        let use_code = if top_level_module {
            quote!()
        } else {
            let use_idents = modules.iter().map(|item| format_ident!("{}", item));
            quote! {
                #(
                    #[doc(no_inline)]
                    pub use #use_idents::*;
                )*
            }
        };

        let tokens = quote! {
            #(pub mod #mod_idents;)*
            #use_code
        };

        fs::write(output_path.join("mod.rs"), file(tokens))?;
    }

    for (destination, tokens) in codemap.0 {
        let output_path = output_path.join(destination.path());
        fs::write(output_path, file(tokens))?;
    }

    Ok(())
}
