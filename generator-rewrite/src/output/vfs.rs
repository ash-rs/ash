use proc_macro2::TokenStream;
use std::{
    collections::HashMap,
    fs, io,
    path::{Path, PathBuf},
};
use tracing::{debug, trace};

fn content(tokens: TokenStream) -> String {
    format!(
        "// DO NOT EDIT: @generated by ash {} {}\n#![cfg_attr(rustfmt, rustfmt_skip)]\n{}",
        env!("CARGO_PKG_NAME"),
        env!("CARGO_PKG_VERSION"),
        prettyplease::unparse(&syn::parse2(tokens).unwrap())
    )
}

#[derive(Default)]
pub struct VirtualRustFs(HashMap<PathBuf, TokenStream>);

impl VirtualRustFs {
    pub fn write(&mut self, path: impl Into<PathBuf>, content: TokenStream) {
        let path = path.into();
        assert!(path.is_relative());
        self.0.entry(path).or_default().extend(content);
    }

    /// This function determines the difference to the existing file structure on disk,
    /// then removes/adds only what is necessary.
    ///
    /// This is nicer than running a `fs::remove_dir_all` and then recreating everything.
    /// Also editors watching the file for changes will react/update correctly.
    pub fn sync_to(self, target: impl AsRef<Path>) -> io::Result<()> {
        debug!("writing {} files to disk", self.0.len());

        let target = target.as_ref();
        fs::create_dir_all(target)?;

        fn visit(
            dir: &Path,
            base: &Path,
            files: &mut Vec<PathBuf>,
            dirs: &mut Vec<PathBuf>,
        ) -> io::Result<()> {
            for entry in fs::read_dir(dir)? {
                let entry = entry?;
                let path = entry.path();
                let stripped = path.strip_prefix(base).unwrap();
                if path.is_dir() {
                    visit(&path, base, files, dirs)?;
                    dirs.push(stripped.into());
                } else {
                    files.push(stripped.into());
                }
            }

            Ok(())
        }

        let mut existing_files = Vec::new();
        let mut existing_dirs = Vec::new();
        visit(target, target, &mut existing_files, &mut existing_dirs)?;

        for existing_file in existing_files.into_iter() {
            if !self.0.contains_key(&existing_file) {
                let target_path = target.join(existing_file);
                trace!(?target_path, "removing file");
                fs::remove_file(target_path)?;
            }
        }

        existing_dirs.sort_by_key(|p| p.components().count());
        for existing_dir in existing_dirs.into_iter().rev() {
            if !(self.0.keys()).any(|file_path| file_path.starts_with(&existing_dir)) {
                let target_path = target.join(existing_dir);
                trace!(?target_path, "removing dir");
                fs::remove_dir(target_path)?;
            }
        }

        for (file_path, file_tokens) in self.0 {
            let target_path = target.join(file_path);

            if let Some(parent) = target_path.parent() {
                if !parent.exists() {
                    trace!(?parent, "creating dir");
                    fs::create_dir_all(parent)?;
                }
            }

            trace!(?target_path, "writing file");
            let contents = content(file_tokens);
            fs::write(target_path, contents)?;
        }

        Ok(())
    }
}
