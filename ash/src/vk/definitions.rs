use crate::vk::aliases::*;
use crate::vk::bitflags::*;
use crate::vk::constants::*;
use crate::vk::enums::*;
use crate::vk::native::*;
use crate::vk::platform_types::*;
use crate::vk::prelude::*;
use crate::vk::{ptr_chain_iter, Handle};
use std::fmt;
use std::marker::PhantomData;
use std::os::raw::*;
#[deprecated = "This define is deprecated. VK_MAKE_API_VERSION should be used instead."]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_MAKE_VERSION.html>"]
pub const fn make_version(major: u32, minor: u32, patch: u32) -> u32 {
    ((major) << 22) | ((minor) << 12) | (patch)
}
#[deprecated = "This define is deprecated. VK_API_VERSION_MAJOR should be used instead."]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_VERSION_MAJOR.html>"]
pub const fn version_major(version: u32) -> u32 {
    (version) >> 22
}
#[deprecated = "This define is deprecated. VK_API_VERSION_MINOR should be used instead."]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_VERSION_MINOR.html>"]
pub const fn version_minor(version: u32) -> u32 {
    ((version) >> 12) & 0x3ffu32
}
#[deprecated = "This define is deprecated. VK_API_VERSION_PATCH should be used instead."]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_VERSION_PATCH.html>"]
pub const fn version_patch(version: u32) -> u32 {
    (version) & 0xfffu32
}
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_MAKE_API_VERSION.html>"]
pub const fn make_api_version(variant: u32, major: u32, minor: u32, patch: u32) -> u32 {
    ((variant) << 29) | ((major) << 22) | ((minor) << 12) | (patch)
}
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_API_VERSION_VARIANT.html>"]
pub const fn api_version_variant(version: u32) -> u32 {
    (version) >> 29
}
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_API_VERSION_MAJOR.html>"]
pub const fn api_version_major(version: u32) -> u32 {
    ((version) >> 22) & 0x7fu32
}
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_API_VERSION_MINOR.html>"]
pub const fn api_version_minor(version: u32) -> u32 {
    ((version) >> 12) & 0x3ffu32
}
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_API_VERSION_PATCH.html>"]
pub const fn api_version_patch(version: u32) -> u32 {
    (version) & 0xfffu32
}
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_API_VERSION_1_0.html>"]
pub const API_VERSION_1_0: u32 = make_api_version(0, 1, 0, 0);
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_API_VERSION_1_1.html>"]
pub const API_VERSION_1_1: u32 = make_api_version(0, 1, 1, 0);
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_API_VERSION_1_2.html>"]
pub const API_VERSION_1_2: u32 = make_api_version(0, 1, 2, 0);
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_API_VERSION_1_3.html>"]
pub const API_VERSION_1_3: u32 = make_api_version(0, 1, 3, 0);
pub const HEADER_VERSION: u32 = 219u32;
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_HEADER_VERSION_COMPLETE.html>"]
pub const HEADER_VERSION_COMPLETE: u32 = make_api_version(0, 1, 3, HEADER_VERSION);
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSampleMask.html>"]
pub type SampleMask = u32;
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBool32.html>"]
pub type Bool32 = u32;
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFlags.html>"]
pub type Flags = u32;
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFlags64.html>"]
pub type Flags64 = u64;
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceSize.html>"]
pub type DeviceSize = u64;
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceAddress.html>"]
pub type DeviceAddress = u64;
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkQueryPoolCreateFlags.html>"]
pub struct QueryPoolCreateFlags(pub(crate) Flags);
vk_bitflags_wrapped!(QueryPoolCreateFlags, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineDynamicStateCreateFlags.html>"]
pub struct PipelineDynamicStateCreateFlags(pub(crate) Flags);
vk_bitflags_wrapped!(PipelineDynamicStateCreateFlags, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineMultisampleStateCreateFlags.html>"]
pub struct PipelineMultisampleStateCreateFlags(pub(crate) Flags);
vk_bitflags_wrapped!(PipelineMultisampleStateCreateFlags, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineRasterizationStateCreateFlags.html>"]
pub struct PipelineRasterizationStateCreateFlags(pub(crate) Flags);
vk_bitflags_wrapped!(PipelineRasterizationStateCreateFlags, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineViewportStateCreateFlags.html>"]
pub struct PipelineViewportStateCreateFlags(pub(crate) Flags);
vk_bitflags_wrapped!(PipelineViewportStateCreateFlags, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineTessellationStateCreateFlags.html>"]
pub struct PipelineTessellationStateCreateFlags(pub(crate) Flags);
vk_bitflags_wrapped!(PipelineTessellationStateCreateFlags, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineInputAssemblyStateCreateFlags.html>"]
pub struct PipelineInputAssemblyStateCreateFlags(pub(crate) Flags);
vk_bitflags_wrapped!(PipelineInputAssemblyStateCreateFlags, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineVertexInputStateCreateFlags.html>"]
pub struct PipelineVertexInputStateCreateFlags(pub(crate) Flags);
vk_bitflags_wrapped!(PipelineVertexInputStateCreateFlags, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferViewCreateFlags.html>"]
pub struct BufferViewCreateFlags(pub(crate) Flags);
vk_bitflags_wrapped!(BufferViewCreateFlags, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceCreateFlags.html>"]
pub struct DeviceCreateFlags(pub(crate) Flags);
vk_bitflags_wrapped!(DeviceCreateFlags, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryMapFlags.html>"]
pub struct MemoryMapFlags(pub(crate) Flags);
vk_bitflags_wrapped!(MemoryMapFlags, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorPoolResetFlags.html>"]
pub struct DescriptorPoolResetFlags(pub(crate) Flags);
vk_bitflags_wrapped!(DescriptorPoolResetFlags, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorUpdateTemplateCreateFlags.html>"]
pub struct DescriptorUpdateTemplateCreateFlags(pub(crate) Flags);
vk_bitflags_wrapped!(DescriptorUpdateTemplateCreateFlags, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAccelerationStructureMotionInfoFlagsNV.html>"]
pub struct AccelerationStructureMotionInfoFlagsNV(pub(crate) Flags);
vk_bitflags_wrapped!(AccelerationStructureMotionInfoFlagsNV, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAccelerationStructureMotionInstanceFlagsNV.html>"]
pub struct AccelerationStructureMotionInstanceFlagsNV(pub(crate) Flags);
vk_bitflags_wrapped!(AccelerationStructureMotionInstanceFlagsNV, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplayModeCreateFlagsKHR.html>"]
pub struct DisplayModeCreateFlagsKHR(pub(crate) Flags);
vk_bitflags_wrapped!(DisplayModeCreateFlagsKHR, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplaySurfaceCreateFlagsKHR.html>"]
pub struct DisplaySurfaceCreateFlagsKHR(pub(crate) Flags);
vk_bitflags_wrapped!(DisplaySurfaceCreateFlagsKHR, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAndroidSurfaceCreateFlagsKHR.html>"]
pub struct AndroidSurfaceCreateFlagsKHR(pub(crate) Flags);
vk_bitflags_wrapped!(AndroidSurfaceCreateFlagsKHR, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkViSurfaceCreateFlagsNN.html>"]
pub struct ViSurfaceCreateFlagsNN(pub(crate) Flags);
vk_bitflags_wrapped!(ViSurfaceCreateFlagsNN, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkWaylandSurfaceCreateFlagsKHR.html>"]
pub struct WaylandSurfaceCreateFlagsKHR(pub(crate) Flags);
vk_bitflags_wrapped!(WaylandSurfaceCreateFlagsKHR, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkWin32SurfaceCreateFlagsKHR.html>"]
pub struct Win32SurfaceCreateFlagsKHR(pub(crate) Flags);
vk_bitflags_wrapped!(Win32SurfaceCreateFlagsKHR, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkXlibSurfaceCreateFlagsKHR.html>"]
pub struct XlibSurfaceCreateFlagsKHR(pub(crate) Flags);
vk_bitflags_wrapped!(XlibSurfaceCreateFlagsKHR, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkXcbSurfaceCreateFlagsKHR.html>"]
pub struct XcbSurfaceCreateFlagsKHR(pub(crate) Flags);
vk_bitflags_wrapped!(XcbSurfaceCreateFlagsKHR, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDirectFBSurfaceCreateFlagsEXT.html>"]
pub struct DirectFBSurfaceCreateFlagsEXT(pub(crate) Flags);
vk_bitflags_wrapped!(DirectFBSurfaceCreateFlagsEXT, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkIOSSurfaceCreateFlagsMVK.html>"]
pub struct IOSSurfaceCreateFlagsMVK(pub(crate) Flags);
vk_bitflags_wrapped!(IOSSurfaceCreateFlagsMVK, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMacOSSurfaceCreateFlagsMVK.html>"]
pub struct MacOSSurfaceCreateFlagsMVK(pub(crate) Flags);
vk_bitflags_wrapped!(MacOSSurfaceCreateFlagsMVK, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMetalSurfaceCreateFlagsEXT.html>"]
pub struct MetalSurfaceCreateFlagsEXT(pub(crate) Flags);
vk_bitflags_wrapped!(MetalSurfaceCreateFlagsEXT, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImagePipeSurfaceCreateFlagsFUCHSIA.html>"]
pub struct ImagePipeSurfaceCreateFlagsFUCHSIA(pub(crate) Flags);
vk_bitflags_wrapped!(ImagePipeSurfaceCreateFlagsFUCHSIA, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkStreamDescriptorSurfaceCreateFlagsGGP.html>"]
pub struct StreamDescriptorSurfaceCreateFlagsGGP(pub(crate) Flags);
vk_bitflags_wrapped!(StreamDescriptorSurfaceCreateFlagsGGP, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkHeadlessSurfaceCreateFlagsEXT.html>"]
pub struct HeadlessSurfaceCreateFlagsEXT(pub(crate) Flags);
vk_bitflags_wrapped!(HeadlessSurfaceCreateFlagsEXT, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkScreenSurfaceCreateFlagsQNX.html>"]
pub struct ScreenSurfaceCreateFlagsQNX(pub(crate) Flags);
vk_bitflags_wrapped!(ScreenSurfaceCreateFlagsQNX, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandPoolTrimFlags.html>"]
pub struct CommandPoolTrimFlags(pub(crate) Flags);
vk_bitflags_wrapped!(CommandPoolTrimFlags, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineViewportSwizzleStateCreateFlagsNV.html>"]
pub struct PipelineViewportSwizzleStateCreateFlagsNV(pub(crate) Flags);
vk_bitflags_wrapped!(PipelineViewportSwizzleStateCreateFlagsNV, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineDiscardRectangleStateCreateFlagsEXT.html>"]
pub struct PipelineDiscardRectangleStateCreateFlagsEXT(pub(crate) Flags);
vk_bitflags_wrapped!(PipelineDiscardRectangleStateCreateFlagsEXT, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineCoverageToColorStateCreateFlagsNV.html>"]
pub struct PipelineCoverageToColorStateCreateFlagsNV(pub(crate) Flags);
vk_bitflags_wrapped!(PipelineCoverageToColorStateCreateFlagsNV, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineCoverageModulationStateCreateFlagsNV.html>"]
pub struct PipelineCoverageModulationStateCreateFlagsNV(pub(crate) Flags);
vk_bitflags_wrapped!(PipelineCoverageModulationStateCreateFlagsNV, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineCoverageReductionStateCreateFlagsNV.html>"]
pub struct PipelineCoverageReductionStateCreateFlagsNV(pub(crate) Flags);
vk_bitflags_wrapped!(PipelineCoverageReductionStateCreateFlagsNV, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkValidationCacheCreateFlagsEXT.html>"]
pub struct ValidationCacheCreateFlagsEXT(pub(crate) Flags);
vk_bitflags_wrapped!(ValidationCacheCreateFlagsEXT, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDebugUtilsMessengerCreateFlagsEXT.html>"]
pub struct DebugUtilsMessengerCreateFlagsEXT(pub(crate) Flags);
vk_bitflags_wrapped!(DebugUtilsMessengerCreateFlagsEXT, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDebugUtilsMessengerCallbackDataFlagsEXT.html>"]
pub struct DebugUtilsMessengerCallbackDataFlagsEXT(pub(crate) Flags);
vk_bitflags_wrapped!(DebugUtilsMessengerCallbackDataFlagsEXT, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceMemoryReportFlagsEXT.html>"]
pub struct DeviceMemoryReportFlagsEXT(pub(crate) Flags);
vk_bitflags_wrapped!(DeviceMemoryReportFlagsEXT, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineRasterizationConservativeStateCreateFlagsEXT.html>"]
pub struct PipelineRasterizationConservativeStateCreateFlagsEXT(pub(crate) Flags);
vk_bitflags_wrapped!(PipelineRasterizationConservativeStateCreateFlagsEXT, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineRasterizationStateStreamCreateFlagsEXT.html>"]
pub struct PipelineRasterizationStateStreamCreateFlagsEXT(pub(crate) Flags);
vk_bitflags_wrapped!(PipelineRasterizationStateStreamCreateFlagsEXT, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineRasterizationDepthClipStateCreateFlagsEXT.html>"]
pub struct PipelineRasterizationDepthClipStateCreateFlagsEXT(pub(crate) Flags);
vk_bitflags_wrapped!(PipelineRasterizationDepthClipStateCreateFlagsEXT, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoBeginCodingFlagsKHR.html>"]
pub struct VideoBeginCodingFlagsKHR(pub(crate) Flags);
vk_bitflags_wrapped!(VideoBeginCodingFlagsKHR, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoEndCodingFlagsKHR.html>"]
pub struct VideoEndCodingFlagsKHR(pub(crate) Flags);
vk_bitflags_wrapped!(VideoEndCodingFlagsKHR, Flags);
define_handle!(
    Instance,
    INSTANCE,
    doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkInstance.html>"
);
define_handle ! (PhysicalDevice , PHYSICAL_DEVICE , doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevice.html>") ;
define_handle!(
    Device,
    DEVICE,
    doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDevice.html>"
);
define_handle!(
    Queue,
    QUEUE,
    doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkQueue.html>"
);
define_handle ! (CommandBuffer , COMMAND_BUFFER , doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandBuffer.html>") ;
handle_nondispatchable ! (DeviceMemory , DEVICE_MEMORY , doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceMemory.html>") ;
handle_nondispatchable ! (CommandPool , COMMAND_POOL , doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandPool.html>") ;
handle_nondispatchable!(
    Buffer,
    BUFFER,
    doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBuffer.html>"
);
handle_nondispatchable!(
    BufferView,
    BUFFER_VIEW,
    doc =
        "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferView.html>"
);
handle_nondispatchable!(
    Image,
    IMAGE,
    doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImage.html>"
);
handle_nondispatchable!(
    ImageView,
    IMAGE_VIEW,
    doc =
        "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageView.html>"
);
handle_nondispatchable ! (ShaderModule , SHADER_MODULE , doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkShaderModule.html>") ;
handle_nondispatchable!(
    Pipeline,
    PIPELINE,
    doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipeline.html>"
);
handle_nondispatchable ! (PipelineLayout , PIPELINE_LAYOUT , doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineLayout.html>") ;
handle_nondispatchable!(
    Sampler,
    SAMPLER,
    doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSampler.html>"
);
handle_nondispatchable ! (DescriptorSet , DESCRIPTOR_SET , doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorSet.html>") ;
handle_nondispatchable ! (DescriptorSetLayout , DESCRIPTOR_SET_LAYOUT , doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorSetLayout.html>") ;
handle_nondispatchable ! (DescriptorPool , DESCRIPTOR_POOL , doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorPool.html>") ;
handle_nondispatchable!(
    Fence,
    FENCE,
    doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFence.html>"
);
handle_nondispatchable!(
    Semaphore,
    SEMAPHORE,
    doc =
        "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSemaphore.html>"
);
handle_nondispatchable!(
    Event,
    EVENT,
    doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkEvent.html>"
);
handle_nondispatchable!(
    QueryPool,
    QUERY_POOL,
    doc =
        "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkQueryPool.html>"
);
handle_nondispatchable ! (Framebuffer , FRAMEBUFFER , doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFramebuffer.html>") ;
handle_nondispatchable!(
    RenderPass,
    RENDER_PASS,
    doc =
        "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderPass.html>"
);
handle_nondispatchable ! (PipelineCache , PIPELINE_CACHE , doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineCache.html>") ;
handle_nondispatchable ! (IndirectCommandsLayoutNV , INDIRECT_COMMANDS_LAYOUT_NV , doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkIndirectCommandsLayoutNV.html>") ;
handle_nondispatchable ! (DescriptorUpdateTemplate , DESCRIPTOR_UPDATE_TEMPLATE , doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorUpdateTemplate.html>") ;
handle_nondispatchable ! (SamplerYcbcrConversion , SAMPLER_YCBCR_CONVERSION , doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSamplerYcbcrConversion.html>") ;
handle_nondispatchable ! (ValidationCacheEXT , VALIDATION_CACHE_EXT , doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkValidationCacheEXT.html>") ;
handle_nondispatchable ! (AccelerationStructureKHR , ACCELERATION_STRUCTURE_KHR , doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAccelerationStructureKHR.html>") ;
handle_nondispatchable ! (AccelerationStructureNV , ACCELERATION_STRUCTURE_NV , doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAccelerationStructureNV.html>") ;
handle_nondispatchable ! (PerformanceConfigurationINTEL , PERFORMANCE_CONFIGURATION_INTEL , doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPerformanceConfigurationINTEL.html>") ;
handle_nondispatchable ! (BufferCollectionFUCHSIA , BUFFER_COLLECTION_FUCHSIA , doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferCollectionFUCHSIA.html>") ;
handle_nondispatchable ! (DeferredOperationKHR , DEFERRED_OPERATION_KHR , doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeferredOperationKHR.html>") ;
handle_nondispatchable ! (PrivateDataSlot , PRIVATE_DATA_SLOT , doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPrivateDataSlot.html>") ;
handle_nondispatchable ! (CuModuleNVX , CU_MODULE_NVX , doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCuModuleNVX.html>") ;
handle_nondispatchable ! (CuFunctionNVX , CU_FUNCTION_NVX , doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCuFunctionNVX.html>") ;
handle_nondispatchable!(
    DisplayKHR,
    DISPLAY_KHR,
    doc =
        "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplayKHR.html>"
);
handle_nondispatchable ! (DisplayModeKHR , DISPLAY_MODE_KHR , doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplayModeKHR.html>") ;
handle_nondispatchable!(
    SurfaceKHR,
    SURFACE_KHR,
    doc =
        "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSurfaceKHR.html>"
);
handle_nondispatchable ! (SwapchainKHR , SWAPCHAIN_KHR , doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSwapchainKHR.html>") ;
handle_nondispatchable ! (DebugReportCallbackEXT , DEBUG_REPORT_CALLBACK_EXT , doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDebugReportCallbackEXT.html>") ;
handle_nondispatchable ! (DebugUtilsMessengerEXT , DEBUG_UTILS_MESSENGER_EXT , doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDebugUtilsMessengerEXT.html>") ;
handle_nondispatchable ! (VideoSessionKHR , VIDEO_SESSION_KHR , doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoSessionKHR.html>") ;
handle_nondispatchable ! (VideoSessionParametersKHR , VIDEO_SESSION_PARAMETERS_KHR , doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoSessionParametersKHR.html>") ;
#[allow(non_camel_case_types)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/PFN_vkInternalAllocationNotification.html>"]
pub type PFN_vkInternalAllocationNotification = Option<
    unsafe extern "system" fn(
        p_user_data: *mut c_void,
        size: usize,
        allocation_type: InternalAllocationType,
        allocation_scope: SystemAllocationScope,
    ),
>;
#[allow(non_camel_case_types)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/PFN_vkInternalFreeNotification.html>"]
pub type PFN_vkInternalFreeNotification = Option<
    unsafe extern "system" fn(
        p_user_data: *mut c_void,
        size: usize,
        allocation_type: InternalAllocationType,
        allocation_scope: SystemAllocationScope,
    ),
>;
#[allow(non_camel_case_types)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/PFN_vkReallocationFunction.html>"]
pub type PFN_vkReallocationFunction = Option<
    unsafe extern "system" fn(
        p_user_data: *mut c_void,
        p_original: *mut c_void,
        size: usize,
        alignment: usize,
        allocation_scope: SystemAllocationScope,
    ) -> *mut c_void,
>;
#[allow(non_camel_case_types)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/PFN_vkAllocationFunction.html>"]
pub type PFN_vkAllocationFunction = Option<
    unsafe extern "system" fn(
        p_user_data: *mut c_void,
        size: usize,
        alignment: usize,
        allocation_scope: SystemAllocationScope,
    ) -> *mut c_void,
>;
#[allow(non_camel_case_types)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/PFN_vkFreeFunction.html>"]
pub type PFN_vkFreeFunction =
    Option<unsafe extern "system" fn(p_user_data: *mut c_void, p_memory: *mut c_void)>;
#[allow(non_camel_case_types)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/PFN_vkVoidFunction.html>"]
pub type PFN_vkVoidFunction = Option<unsafe extern "system" fn()>;
#[allow(non_camel_case_types)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/PFN_vkDebugReportCallbackEXT.html>"]
pub type PFN_vkDebugReportCallbackEXT = Option<
    unsafe extern "system" fn(
        flags: DebugReportFlagsEXT,
        object_type: DebugReportObjectTypeEXT,
        object: u64,
        location: usize,
        message_code: i32,
        p_layer_prefix: *const c_char,
        p_message: *const c_char,
        p_user_data: *mut c_void,
    ) -> Bool32,
>;
#[allow(non_camel_case_types)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/PFN_vkDebugUtilsMessengerCallbackEXT.html>"]
pub type PFN_vkDebugUtilsMessengerCallbackEXT = Option<
    unsafe extern "system" fn(
        message_severity: DebugUtilsMessageSeverityFlagsEXT,
        message_types: DebugUtilsMessageTypeFlagsEXT,
        p_callback_data: *const DebugUtilsMessengerCallbackDataEXT,
        p_user_data: *mut c_void,
    ) -> Bool32,
>;
#[allow(non_camel_case_types)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/PFN_vkDeviceMemoryReportCallbackEXT.html>"]
pub type PFN_vkDeviceMemoryReportCallbackEXT = Option<
    unsafe extern "system" fn(
        p_callback_data: *const DeviceMemoryReportCallbackDataEXT,
        p_user_data: *mut c_void,
    ),
>;
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBaseOutStructure.html>"]
pub struct BaseOutStructure<'a> {
    pub s_type: StructureType,
    pub p_next: *mut Self,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for BaseOutStructure<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: unsafe { ::std::mem::zeroed() },
            p_next: ::std::ptr::null_mut(),
            _marker: PhantomData,
        }
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBaseInStructure.html>"]
pub struct BaseInStructure<'a> {
    pub s_type: StructureType,
    pub p_next: *const Self,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for BaseInStructure<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: unsafe { ::std::mem::zeroed() },
            p_next: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default, PartialEq, Eq, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkOffset2D.html>"]
pub struct Offset2D {
    pub x: i32,
    pub y: i32,
}
impl Offset2D {
    #[inline]
    pub fn x(mut self, x: i32) -> Self {
        self.x = x;
        self
    }
    #[inline]
    pub fn y(mut self, y: i32) -> Self {
        self.y = y;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default, PartialEq, Eq, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkOffset3D.html>"]
pub struct Offset3D {
    pub x: i32,
    pub y: i32,
    pub z: i32,
}
impl Offset3D {
    #[inline]
    pub fn x(mut self, x: i32) -> Self {
        self.x = x;
        self
    }
    #[inline]
    pub fn y(mut self, y: i32) -> Self {
        self.y = y;
        self
    }
    #[inline]
    pub fn z(mut self, z: i32) -> Self {
        self.z = z;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default, PartialEq, Eq, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExtent2D.html>"]
pub struct Extent2D {
    pub width: u32,
    pub height: u32,
}
impl Extent2D {
    #[inline]
    pub fn width(mut self, width: u32) -> Self {
        self.width = width;
        self
    }
    #[inline]
    pub fn height(mut self, height: u32) -> Self {
        self.height = height;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default, PartialEq, Eq, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExtent3D.html>"]
pub struct Extent3D {
    pub width: u32,
    pub height: u32,
    pub depth: u32,
}
impl Extent3D {
    #[inline]
    pub fn width(mut self, width: u32) -> Self {
        self.width = width;
        self
    }
    #[inline]
    pub fn height(mut self, height: u32) -> Self {
        self.height = height;
        self
    }
    #[inline]
    pub fn depth(mut self, depth: u32) -> Self {
        self.depth = depth;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkViewport.html>"]
pub struct Viewport {
    pub x: f32,
    pub y: f32,
    pub width: f32,
    pub height: f32,
    pub min_depth: f32,
    pub max_depth: f32,
}
impl Viewport {
    #[inline]
    pub fn x(mut self, x: f32) -> Self {
        self.x = x;
        self
    }
    #[inline]
    pub fn y(mut self, y: f32) -> Self {
        self.y = y;
        self
    }
    #[inline]
    pub fn width(mut self, width: f32) -> Self {
        self.width = width;
        self
    }
    #[inline]
    pub fn height(mut self, height: f32) -> Self {
        self.height = height;
        self
    }
    #[inline]
    pub fn min_depth(mut self, min_depth: f32) -> Self {
        self.min_depth = min_depth;
        self
    }
    #[inline]
    pub fn max_depth(mut self, max_depth: f32) -> Self {
        self.max_depth = max_depth;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default, PartialEq, Eq, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRect2D.html>"]
pub struct Rect2D {
    pub offset: Offset2D,
    pub extent: Extent2D,
}
impl Rect2D {
    #[inline]
    pub fn offset(mut self, offset: Offset2D) -> Self {
        self.offset = offset;
        self
    }
    #[inline]
    pub fn extent(mut self, extent: Extent2D) -> Self {
        self.extent = extent;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default, PartialEq, Eq, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkClearRect.html>"]
pub struct ClearRect {
    pub rect: Rect2D,
    pub base_array_layer: u32,
    pub layer_count: u32,
}
impl ClearRect {
    #[inline]
    pub fn rect(mut self, rect: Rect2D) -> Self {
        self.rect = rect;
        self
    }
    #[inline]
    pub fn base_array_layer(mut self, base_array_layer: u32) -> Self {
        self.base_array_layer = base_array_layer;
        self
    }
    #[inline]
    pub fn layer_count(mut self, layer_count: u32) -> Self {
        self.layer_count = layer_count;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkComponentMapping.html>"]
pub struct ComponentMapping {
    pub r: ComponentSwizzle,
    pub g: ComponentSwizzle,
    pub b: ComponentSwizzle,
    pub a: ComponentSwizzle,
}
impl ComponentMapping {
    #[inline]
    pub fn r(mut self, r: ComponentSwizzle) -> Self {
        self.r = r;
        self
    }
    #[inline]
    pub fn g(mut self, g: ComponentSwizzle) -> Self {
        self.g = g;
        self
    }
    #[inline]
    pub fn b(mut self, b: ComponentSwizzle) -> Self {
        self.b = b;
        self
    }
    #[inline]
    pub fn a(mut self, a: ComponentSwizzle) -> Self {
        self.a = a;
        self
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceProperties.html>"]
pub struct PhysicalDeviceProperties {
    pub api_version: u32,
    pub driver_version: u32,
    pub vendor_id: u32,
    pub device_id: u32,
    pub device_type: PhysicalDeviceType,
    pub device_name: [c_char; MAX_PHYSICAL_DEVICE_NAME_SIZE],
    pub pipeline_cache_uuid: [u8; UUID_SIZE],
    pub limits: PhysicalDeviceLimits,
    pub sparse_properties: PhysicalDeviceSparseProperties,
}
#[cfg(feature = "debug")]
impl fmt::Debug for PhysicalDeviceProperties {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceProperties")
            .field("api_version", &self.api_version)
            .field("driver_version", &self.driver_version)
            .field("vendor_id", &self.vendor_id)
            .field("device_id", &self.device_id)
            .field("device_type", &self.device_type)
            .field("device_name", &unsafe {
                ::std::ffi::CStr::from_ptr(self.device_name.as_ptr())
            })
            .field("pipeline_cache_uuid", &self.pipeline_cache_uuid)
            .field("limits", &self.limits)
            .field("sparse_properties", &self.sparse_properties)
            .finish()
    }
}
impl ::std::default::Default for PhysicalDeviceProperties {
    #[inline]
    fn default() -> Self {
        Self {
            api_version: u32::default(),
            driver_version: u32::default(),
            vendor_id: u32::default(),
            device_id: u32::default(),
            device_type: PhysicalDeviceType::default(),
            device_name: unsafe { ::std::mem::zeroed() },
            pipeline_cache_uuid: unsafe { ::std::mem::zeroed() },
            limits: PhysicalDeviceLimits::default(),
            sparse_properties: PhysicalDeviceSparseProperties::default(),
        }
    }
}
impl PhysicalDeviceProperties {
    #[inline]
    pub fn api_version(mut self, api_version: u32) -> Self {
        self.api_version = api_version;
        self
    }
    #[inline]
    pub fn driver_version(mut self, driver_version: u32) -> Self {
        self.driver_version = driver_version;
        self
    }
    #[inline]
    pub fn vendor_id(mut self, vendor_id: u32) -> Self {
        self.vendor_id = vendor_id;
        self
    }
    #[inline]
    pub fn device_id(mut self, device_id: u32) -> Self {
        self.device_id = device_id;
        self
    }
    #[inline]
    pub fn device_type(mut self, device_type: PhysicalDeviceType) -> Self {
        self.device_type = device_type;
        self
    }
    #[inline]
    pub fn device_name(mut self, device_name: [c_char; MAX_PHYSICAL_DEVICE_NAME_SIZE]) -> Self {
        self.device_name = device_name;
        self
    }
    #[inline]
    pub fn pipeline_cache_uuid(mut self, pipeline_cache_uuid: [u8; UUID_SIZE]) -> Self {
        self.pipeline_cache_uuid = pipeline_cache_uuid;
        self
    }
    #[inline]
    pub fn limits(mut self, limits: PhysicalDeviceLimits) -> Self {
        self.limits = limits;
        self
    }
    #[inline]
    pub fn sparse_properties(mut self, sparse_properties: PhysicalDeviceSparseProperties) -> Self {
        self.sparse_properties = sparse_properties;
        self
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExtensionProperties.html>"]
pub struct ExtensionProperties {
    pub extension_name: [c_char; MAX_EXTENSION_NAME_SIZE],
    pub spec_version: u32,
}
#[cfg(feature = "debug")]
impl fmt::Debug for ExtensionProperties {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ExtensionProperties")
            .field("extension_name", &unsafe {
                ::std::ffi::CStr::from_ptr(self.extension_name.as_ptr())
            })
            .field("spec_version", &self.spec_version)
            .finish()
    }
}
impl ::std::default::Default for ExtensionProperties {
    #[inline]
    fn default() -> Self {
        Self {
            extension_name: unsafe { ::std::mem::zeroed() },
            spec_version: u32::default(),
        }
    }
}
impl ExtensionProperties {
    #[inline]
    pub fn extension_name(mut self, extension_name: [c_char; MAX_EXTENSION_NAME_SIZE]) -> Self {
        self.extension_name = extension_name;
        self
    }
    #[inline]
    pub fn spec_version(mut self, spec_version: u32) -> Self {
        self.spec_version = spec_version;
        self
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkLayerProperties.html>"]
pub struct LayerProperties {
    pub layer_name: [c_char; MAX_EXTENSION_NAME_SIZE],
    pub spec_version: u32,
    pub implementation_version: u32,
    pub description: [c_char; MAX_DESCRIPTION_SIZE],
}
#[cfg(feature = "debug")]
impl fmt::Debug for LayerProperties {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("LayerProperties")
            .field("layer_name", &unsafe {
                ::std::ffi::CStr::from_ptr(self.layer_name.as_ptr())
            })
            .field("spec_version", &self.spec_version)
            .field("implementation_version", &self.implementation_version)
            .field("description", &unsafe {
                ::std::ffi::CStr::from_ptr(self.description.as_ptr())
            })
            .finish()
    }
}
impl ::std::default::Default for LayerProperties {
    #[inline]
    fn default() -> Self {
        Self {
            layer_name: unsafe { ::std::mem::zeroed() },
            spec_version: u32::default(),
            implementation_version: u32::default(),
            description: unsafe { ::std::mem::zeroed() },
        }
    }
}
impl LayerProperties {
    #[inline]
    pub fn layer_name(mut self, layer_name: [c_char; MAX_EXTENSION_NAME_SIZE]) -> Self {
        self.layer_name = layer_name;
        self
    }
    #[inline]
    pub fn spec_version(mut self, spec_version: u32) -> Self {
        self.spec_version = spec_version;
        self
    }
    #[inline]
    pub fn implementation_version(mut self, implementation_version: u32) -> Self {
        self.implementation_version = implementation_version;
        self
    }
    #[inline]
    pub fn description(mut self, description: [c_char; MAX_DESCRIPTION_SIZE]) -> Self {
        self.description = description;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkApplicationInfo.html>"]
pub struct ApplicationInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub p_application_name: *const c_char,
    pub application_version: u32,
    pub p_engine_name: *const c_char,
    pub engine_version: u32,
    pub api_version: u32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for ApplicationInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            p_application_name: ::std::ptr::null(),
            application_version: u32::default(),
            p_engine_name: ::std::ptr::null(),
            engine_version: u32::default(),
            api_version: u32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for ApplicationInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::APPLICATION_INFO;
}
impl<'a> ApplicationInfo<'a> {
    #[inline]
    pub fn application_name(mut self, application_name: &'a ::std::ffi::CStr) -> Self {
        self.p_application_name = application_name.as_ptr();
        self
    }
    #[inline]
    pub fn application_version(mut self, application_version: u32) -> Self {
        self.application_version = application_version;
        self
    }
    #[inline]
    pub fn engine_name(mut self, engine_name: &'a ::std::ffi::CStr) -> Self {
        self.p_engine_name = engine_name.as_ptr();
        self
    }
    #[inline]
    pub fn engine_version(mut self, engine_version: u32) -> Self {
        self.engine_version = engine_version;
        self
    }
    #[inline]
    pub fn api_version(mut self, api_version: u32) -> Self {
        self.api_version = api_version;
        self
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAllocationCallbacks.html>"]
pub struct AllocationCallbacks<'a> {
    pub p_user_data: *mut c_void,
    pub pfn_allocation: PFN_vkAllocationFunction,
    pub pfn_reallocation: PFN_vkReallocationFunction,
    pub pfn_free: PFN_vkFreeFunction,
    pub pfn_internal_allocation: PFN_vkInternalAllocationNotification,
    pub pfn_internal_free: PFN_vkInternalFreeNotification,
    pub _marker: PhantomData<&'a ()>,
}
#[cfg(feature = "debug")]
impl fmt::Debug for AllocationCallbacks<'_> {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("AllocationCallbacks")
            .field("p_user_data", &self.p_user_data)
            .field(
                "pfn_allocation",
                &(self.pfn_allocation.map(|x| x as *const ())),
            )
            .field(
                "pfn_reallocation",
                &(self.pfn_reallocation.map(|x| x as *const ())),
            )
            .field("pfn_free", &(self.pfn_free.map(|x| x as *const ())))
            .field(
                "pfn_internal_allocation",
                &(self.pfn_internal_allocation.map(|x| x as *const ())),
            )
            .field(
                "pfn_internal_free",
                &(self.pfn_internal_free.map(|x| x as *const ())),
            )
            .finish()
    }
}
impl ::std::default::Default for AllocationCallbacks<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            p_user_data: ::std::ptr::null_mut(),
            pfn_allocation: PFN_vkAllocationFunction::default(),
            pfn_reallocation: PFN_vkReallocationFunction::default(),
            pfn_free: PFN_vkFreeFunction::default(),
            pfn_internal_allocation: PFN_vkInternalAllocationNotification::default(),
            pfn_internal_free: PFN_vkInternalFreeNotification::default(),
            _marker: PhantomData,
        }
    }
}
impl<'a> AllocationCallbacks<'a> {
    #[inline]
    pub fn user_data(mut self, user_data: *mut c_void) -> Self {
        self.p_user_data = user_data;
        self
    }
    #[inline]
    pub fn pfn_allocation(mut self, pfn_allocation: PFN_vkAllocationFunction) -> Self {
        self.pfn_allocation = pfn_allocation;
        self
    }
    #[inline]
    pub fn pfn_reallocation(mut self, pfn_reallocation: PFN_vkReallocationFunction) -> Self {
        self.pfn_reallocation = pfn_reallocation;
        self
    }
    #[inline]
    pub fn pfn_free(mut self, pfn_free: PFN_vkFreeFunction) -> Self {
        self.pfn_free = pfn_free;
        self
    }
    #[inline]
    pub fn pfn_internal_allocation(
        mut self,
        pfn_internal_allocation: PFN_vkInternalAllocationNotification,
    ) -> Self {
        self.pfn_internal_allocation = pfn_internal_allocation;
        self
    }
    #[inline]
    pub fn pfn_internal_free(mut self, pfn_internal_free: PFN_vkInternalFreeNotification) -> Self {
        self.pfn_internal_free = pfn_internal_free;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceQueueCreateInfo.html>"]
pub struct DeviceQueueCreateInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: DeviceQueueCreateFlags,
    pub queue_family_index: u32,
    pub queue_count: u32,
    pub p_queue_priorities: *const f32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for DeviceQueueCreateInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: DeviceQueueCreateFlags::default(),
            queue_family_index: u32::default(),
            queue_count: u32::default(),
            p_queue_priorities: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for DeviceQueueCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DEVICE_QUEUE_CREATE_INFO;
}
pub unsafe trait ExtendsDeviceQueueCreateInfo {}
impl<'a> DeviceQueueCreateInfo<'a> {
    #[inline]
    pub fn flags(mut self, flags: DeviceQueueCreateFlags) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn queue_family_index(mut self, queue_family_index: u32) -> Self {
        self.queue_family_index = queue_family_index;
        self
    }
    #[inline]
    pub fn queue_priorities(mut self, queue_priorities: &'a [f32]) -> Self {
        self.queue_count = queue_priorities.len() as _;
        self.p_queue_priorities = queue_priorities.as_ptr();
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `x.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsDeviceQueueCreateInfo>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.p_next as _;
            self.p_next = next_ptr;
        }
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceCreateInfo.html>"]
pub struct DeviceCreateInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: DeviceCreateFlags,
    pub queue_create_info_count: u32,
    pub p_queue_create_infos: *const DeviceQueueCreateInfo<'a>,
    pub enabled_layer_count: u32,
    pub pp_enabled_layer_names: *const *const c_char,
    pub enabled_extension_count: u32,
    pub pp_enabled_extension_names: *const *const c_char,
    pub p_enabled_features: *const PhysicalDeviceFeatures,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for DeviceCreateInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: DeviceCreateFlags::default(),
            queue_create_info_count: u32::default(),
            p_queue_create_infos: ::std::ptr::null(),
            enabled_layer_count: u32::default(),
            pp_enabled_layer_names: ::std::ptr::null(),
            enabled_extension_count: u32::default(),
            pp_enabled_extension_names: ::std::ptr::null(),
            p_enabled_features: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for DeviceCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DEVICE_CREATE_INFO;
}
pub unsafe trait ExtendsDeviceCreateInfo {}
impl<'a> DeviceCreateInfo<'a> {
    #[inline]
    pub fn flags(mut self, flags: DeviceCreateFlags) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn queue_create_infos(mut self, queue_create_infos: &'a [DeviceQueueCreateInfo]) -> Self {
        self.queue_create_info_count = queue_create_infos.len() as _;
        self.p_queue_create_infos = queue_create_infos.as_ptr();
        self
    }
    #[inline]
    pub fn enabled_layer_names(mut self, enabled_layer_names: &'a [*const c_char]) -> Self {
        self.enabled_layer_count = enabled_layer_names.len() as _;
        self.pp_enabled_layer_names = enabled_layer_names.as_ptr();
        self
    }
    #[inline]
    pub fn enabled_extension_names(mut self, enabled_extension_names: &'a [*const c_char]) -> Self {
        self.enabled_extension_count = enabled_extension_names.len() as _;
        self.pp_enabled_extension_names = enabled_extension_names.as_ptr();
        self
    }
    #[inline]
    pub fn enabled_features(mut self, enabled_features: &'a PhysicalDeviceFeatures) -> Self {
        self.p_enabled_features = enabled_features;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `x.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsDeviceCreateInfo>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.p_next as _;
            self.p_next = next_ptr;
        }
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkInstanceCreateInfo.html>"]
pub struct InstanceCreateInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: InstanceCreateFlags,
    pub p_application_info: *const ApplicationInfo<'a>,
    pub enabled_layer_count: u32,
    pub pp_enabled_layer_names: *const *const c_char,
    pub enabled_extension_count: u32,
    pub pp_enabled_extension_names: *const *const c_char,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for InstanceCreateInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: InstanceCreateFlags::default(),
            p_application_info: ::std::ptr::null(),
            enabled_layer_count: u32::default(),
            pp_enabled_layer_names: ::std::ptr::null(),
            enabled_extension_count: u32::default(),
            pp_enabled_extension_names: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for InstanceCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::INSTANCE_CREATE_INFO;
}
pub unsafe trait ExtendsInstanceCreateInfo {}
impl<'a> InstanceCreateInfo<'a> {
    #[inline]
    pub fn flags(mut self, flags: InstanceCreateFlags) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn application_info(mut self, application_info: &'a ApplicationInfo<'a>) -> Self {
        self.p_application_info = application_info;
        self
    }
    #[inline]
    pub fn enabled_layer_names(mut self, enabled_layer_names: &'a [*const c_char]) -> Self {
        self.enabled_layer_count = enabled_layer_names.len() as _;
        self.pp_enabled_layer_names = enabled_layer_names.as_ptr();
        self
    }
    #[inline]
    pub fn enabled_extension_names(mut self, enabled_extension_names: &'a [*const c_char]) -> Self {
        self.enabled_extension_count = enabled_extension_names.len() as _;
        self.pp_enabled_extension_names = enabled_extension_names.as_ptr();
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `x.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsInstanceCreateInfo>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.p_next as _;
            self.p_next = next_ptr;
        }
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkQueueFamilyProperties.html>"]
pub struct QueueFamilyProperties {
    pub queue_flags: QueueFlags,
    pub queue_count: u32,
    pub timestamp_valid_bits: u32,
    pub min_image_transfer_granularity: Extent3D,
}
impl QueueFamilyProperties {
    #[inline]
    pub fn queue_flags(mut self, queue_flags: QueueFlags) -> Self {
        self.queue_flags = queue_flags;
        self
    }
    #[inline]
    pub fn queue_count(mut self, queue_count: u32) -> Self {
        self.queue_count = queue_count;
        self
    }
    #[inline]
    pub fn timestamp_valid_bits(mut self, timestamp_valid_bits: u32) -> Self {
        self.timestamp_valid_bits = timestamp_valid_bits;
        self
    }
    #[inline]
    pub fn min_image_transfer_granularity(
        mut self,
        min_image_transfer_granularity: Extent3D,
    ) -> Self {
        self.min_image_transfer_granularity = min_image_transfer_granularity;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMemoryProperties.html>"]
pub struct PhysicalDeviceMemoryProperties {
    pub memory_type_count: u32,
    pub memory_types: [MemoryType; MAX_MEMORY_TYPES],
    pub memory_heap_count: u32,
    pub memory_heaps: [MemoryHeap; MAX_MEMORY_HEAPS],
}
impl ::std::default::Default for PhysicalDeviceMemoryProperties {
    #[inline]
    fn default() -> Self {
        Self {
            memory_type_count: u32::default(),
            memory_types: unsafe { ::std::mem::zeroed() },
            memory_heap_count: u32::default(),
            memory_heaps: unsafe { ::std::mem::zeroed() },
        }
    }
}
impl PhysicalDeviceMemoryProperties {
    #[inline]
    pub fn memory_type_count(mut self, memory_type_count: u32) -> Self {
        self.memory_type_count = memory_type_count;
        self
    }
    #[inline]
    pub fn memory_types(mut self, memory_types: [MemoryType; MAX_MEMORY_TYPES]) -> Self {
        self.memory_types = memory_types;
        self
    }
    #[inline]
    pub fn memory_heap_count(mut self, memory_heap_count: u32) -> Self {
        self.memory_heap_count = memory_heap_count;
        self
    }
    #[inline]
    pub fn memory_heaps(mut self, memory_heaps: [MemoryHeap; MAX_MEMORY_HEAPS]) -> Self {
        self.memory_heaps = memory_heaps;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryAllocateInfo.html>"]
pub struct MemoryAllocateInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub allocation_size: DeviceSize,
    pub memory_type_index: u32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for MemoryAllocateInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            allocation_size: DeviceSize::default(),
            memory_type_index: u32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for MemoryAllocateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::MEMORY_ALLOCATE_INFO;
}
pub unsafe trait ExtendsMemoryAllocateInfo {}
impl<'a> MemoryAllocateInfo<'a> {
    #[inline]
    pub fn allocation_size(mut self, allocation_size: DeviceSize) -> Self {
        self.allocation_size = allocation_size;
        self
    }
    #[inline]
    pub fn memory_type_index(mut self, memory_type_index: u32) -> Self {
        self.memory_type_index = memory_type_index;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `x.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsMemoryAllocateInfo>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.p_next as _;
            self.p_next = next_ptr;
        }
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryRequirements.html>"]
pub struct MemoryRequirements {
    pub size: DeviceSize,
    pub alignment: DeviceSize,
    pub memory_type_bits: u32,
}
impl MemoryRequirements {
    #[inline]
    pub fn size(mut self, size: DeviceSize) -> Self {
        self.size = size;
        self
    }
    #[inline]
    pub fn alignment(mut self, alignment: DeviceSize) -> Self {
        self.alignment = alignment;
        self
    }
    #[inline]
    pub fn memory_type_bits(mut self, memory_type_bits: u32) -> Self {
        self.memory_type_bits = memory_type_bits;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSparseImageFormatProperties.html>"]
pub struct SparseImageFormatProperties {
    pub aspect_mask: ImageAspectFlags,
    pub image_granularity: Extent3D,
    pub flags: SparseImageFormatFlags,
}
impl SparseImageFormatProperties {
    #[inline]
    pub fn aspect_mask(mut self, aspect_mask: ImageAspectFlags) -> Self {
        self.aspect_mask = aspect_mask;
        self
    }
    #[inline]
    pub fn image_granularity(mut self, image_granularity: Extent3D) -> Self {
        self.image_granularity = image_granularity;
        self
    }
    #[inline]
    pub fn flags(mut self, flags: SparseImageFormatFlags) -> Self {
        self.flags = flags;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSparseImageMemoryRequirements.html>"]
pub struct SparseImageMemoryRequirements {
    pub format_properties: SparseImageFormatProperties,
    pub image_mip_tail_first_lod: u32,
    pub image_mip_tail_size: DeviceSize,
    pub image_mip_tail_offset: DeviceSize,
    pub image_mip_tail_stride: DeviceSize,
}
impl SparseImageMemoryRequirements {
    #[inline]
    pub fn format_properties(mut self, format_properties: SparseImageFormatProperties) -> Self {
        self.format_properties = format_properties;
        self
    }
    #[inline]
    pub fn image_mip_tail_first_lod(mut self, image_mip_tail_first_lod: u32) -> Self {
        self.image_mip_tail_first_lod = image_mip_tail_first_lod;
        self
    }
    #[inline]
    pub fn image_mip_tail_size(mut self, image_mip_tail_size: DeviceSize) -> Self {
        self.image_mip_tail_size = image_mip_tail_size;
        self
    }
    #[inline]
    pub fn image_mip_tail_offset(mut self, image_mip_tail_offset: DeviceSize) -> Self {
        self.image_mip_tail_offset = image_mip_tail_offset;
        self
    }
    #[inline]
    pub fn image_mip_tail_stride(mut self, image_mip_tail_stride: DeviceSize) -> Self {
        self.image_mip_tail_stride = image_mip_tail_stride;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryType.html>"]
pub struct MemoryType {
    pub property_flags: MemoryPropertyFlags,
    pub heap_index: u32,
}
impl MemoryType {
    #[inline]
    pub fn property_flags(mut self, property_flags: MemoryPropertyFlags) -> Self {
        self.property_flags = property_flags;
        self
    }
    #[inline]
    pub fn heap_index(mut self, heap_index: u32) -> Self {
        self.heap_index = heap_index;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryHeap.html>"]
pub struct MemoryHeap {
    pub size: DeviceSize,
    pub flags: MemoryHeapFlags,
}
impl MemoryHeap {
    #[inline]
    pub fn size(mut self, size: DeviceSize) -> Self {
        self.size = size;
        self
    }
    #[inline]
    pub fn flags(mut self, flags: MemoryHeapFlags) -> Self {
        self.flags = flags;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMappedMemoryRange.html>"]
pub struct MappedMemoryRange<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub memory: DeviceMemory,
    pub offset: DeviceSize,
    pub size: DeviceSize,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for MappedMemoryRange<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            memory: DeviceMemory::default(),
            offset: DeviceSize::default(),
            size: DeviceSize::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for MappedMemoryRange<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::MAPPED_MEMORY_RANGE;
}
impl<'a> MappedMemoryRange<'a> {
    #[inline]
    pub fn memory(mut self, memory: DeviceMemory) -> Self {
        self.memory = memory;
        self
    }
    #[inline]
    pub fn offset(mut self, offset: DeviceSize) -> Self {
        self.offset = offset;
        self
    }
    #[inline]
    pub fn size(mut self, size: DeviceSize) -> Self {
        self.size = size;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFormatProperties.html>"]
pub struct FormatProperties {
    pub linear_tiling_features: FormatFeatureFlags,
    pub optimal_tiling_features: FormatFeatureFlags,
    pub buffer_features: FormatFeatureFlags,
}
impl FormatProperties {
    #[inline]
    pub fn linear_tiling_features(mut self, linear_tiling_features: FormatFeatureFlags) -> Self {
        self.linear_tiling_features = linear_tiling_features;
        self
    }
    #[inline]
    pub fn optimal_tiling_features(mut self, optimal_tiling_features: FormatFeatureFlags) -> Self {
        self.optimal_tiling_features = optimal_tiling_features;
        self
    }
    #[inline]
    pub fn buffer_features(mut self, buffer_features: FormatFeatureFlags) -> Self {
        self.buffer_features = buffer_features;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageFormatProperties.html>"]
pub struct ImageFormatProperties {
    pub max_extent: Extent3D,
    pub max_mip_levels: u32,
    pub max_array_layers: u32,
    pub sample_counts: SampleCountFlags,
    pub max_resource_size: DeviceSize,
}
impl ImageFormatProperties {
    #[inline]
    pub fn max_extent(mut self, max_extent: Extent3D) -> Self {
        self.max_extent = max_extent;
        self
    }
    #[inline]
    pub fn max_mip_levels(mut self, max_mip_levels: u32) -> Self {
        self.max_mip_levels = max_mip_levels;
        self
    }
    #[inline]
    pub fn max_array_layers(mut self, max_array_layers: u32) -> Self {
        self.max_array_layers = max_array_layers;
        self
    }
    #[inline]
    pub fn sample_counts(mut self, sample_counts: SampleCountFlags) -> Self {
        self.sample_counts = sample_counts;
        self
    }
    #[inline]
    pub fn max_resource_size(mut self, max_resource_size: DeviceSize) -> Self {
        self.max_resource_size = max_resource_size;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorBufferInfo.html>"]
pub struct DescriptorBufferInfo {
    pub buffer: Buffer,
    pub offset: DeviceSize,
    pub range: DeviceSize,
}
impl DescriptorBufferInfo {
    #[inline]
    pub fn buffer(mut self, buffer: Buffer) -> Self {
        self.buffer = buffer;
        self
    }
    #[inline]
    pub fn offset(mut self, offset: DeviceSize) -> Self {
        self.offset = offset;
        self
    }
    #[inline]
    pub fn range(mut self, range: DeviceSize) -> Self {
        self.range = range;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorImageInfo.html>"]
pub struct DescriptorImageInfo {
    pub sampler: Sampler,
    pub image_view: ImageView,
    pub image_layout: ImageLayout,
}
impl DescriptorImageInfo {
    #[inline]
    pub fn sampler(mut self, sampler: Sampler) -> Self {
        self.sampler = sampler;
        self
    }
    #[inline]
    pub fn image_view(mut self, image_view: ImageView) -> Self {
        self.image_view = image_view;
        self
    }
    #[inline]
    pub fn image_layout(mut self, image_layout: ImageLayout) -> Self {
        self.image_layout = image_layout;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkWriteDescriptorSet.html>"]
pub struct WriteDescriptorSet<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub dst_set: DescriptorSet,
    pub dst_binding: u32,
    pub dst_array_element: u32,
    pub descriptor_count: u32,
    pub descriptor_type: DescriptorType,
    pub p_image_info: *const DescriptorImageInfo,
    pub p_buffer_info: *const DescriptorBufferInfo,
    pub p_texel_buffer_view: *const BufferView,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for WriteDescriptorSet<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            dst_set: DescriptorSet::default(),
            dst_binding: u32::default(),
            dst_array_element: u32::default(),
            descriptor_count: u32::default(),
            descriptor_type: DescriptorType::default(),
            p_image_info: ::std::ptr::null(),
            p_buffer_info: ::std::ptr::null(),
            p_texel_buffer_view: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for WriteDescriptorSet<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::WRITE_DESCRIPTOR_SET;
}
pub unsafe trait ExtendsWriteDescriptorSet {}
impl<'a> WriteDescriptorSet<'a> {
    #[inline]
    pub fn dst_set(mut self, dst_set: DescriptorSet) -> Self {
        self.dst_set = dst_set;
        self
    }
    #[inline]
    pub fn dst_binding(mut self, dst_binding: u32) -> Self {
        self.dst_binding = dst_binding;
        self
    }
    #[inline]
    pub fn dst_array_element(mut self, dst_array_element: u32) -> Self {
        self.dst_array_element = dst_array_element;
        self
    }
    #[inline]
    pub fn descriptor_type(mut self, descriptor_type: DescriptorType) -> Self {
        self.descriptor_type = descriptor_type;
        self
    }
    #[inline]
    pub fn image_info(mut self, image_info: &'a [DescriptorImageInfo]) -> Self {
        self.descriptor_count = image_info.len() as _;
        self.p_image_info = image_info.as_ptr();
        self
    }
    #[inline]
    pub fn buffer_info(mut self, buffer_info: &'a [DescriptorBufferInfo]) -> Self {
        self.descriptor_count = buffer_info.len() as _;
        self.p_buffer_info = buffer_info.as_ptr();
        self
    }
    #[inline]
    pub fn texel_buffer_view(mut self, texel_buffer_view: &'a [BufferView]) -> Self {
        self.descriptor_count = texel_buffer_view.len() as _;
        self.p_texel_buffer_view = texel_buffer_view.as_ptr();
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `x.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsWriteDescriptorSet>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.p_next as _;
            self.p_next = next_ptr;
        }
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCopyDescriptorSet.html>"]
pub struct CopyDescriptorSet<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub src_set: DescriptorSet,
    pub src_binding: u32,
    pub src_array_element: u32,
    pub dst_set: DescriptorSet,
    pub dst_binding: u32,
    pub dst_array_element: u32,
    pub descriptor_count: u32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for CopyDescriptorSet<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            src_set: DescriptorSet::default(),
            src_binding: u32::default(),
            src_array_element: u32::default(),
            dst_set: DescriptorSet::default(),
            dst_binding: u32::default(),
            dst_array_element: u32::default(),
            descriptor_count: u32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for CopyDescriptorSet<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::COPY_DESCRIPTOR_SET;
}
impl<'a> CopyDescriptorSet<'a> {
    #[inline]
    pub fn src_set(mut self, src_set: DescriptorSet) -> Self {
        self.src_set = src_set;
        self
    }
    #[inline]
    pub fn src_binding(mut self, src_binding: u32) -> Self {
        self.src_binding = src_binding;
        self
    }
    #[inline]
    pub fn src_array_element(mut self, src_array_element: u32) -> Self {
        self.src_array_element = src_array_element;
        self
    }
    #[inline]
    pub fn dst_set(mut self, dst_set: DescriptorSet) -> Self {
        self.dst_set = dst_set;
        self
    }
    #[inline]
    pub fn dst_binding(mut self, dst_binding: u32) -> Self {
        self.dst_binding = dst_binding;
        self
    }
    #[inline]
    pub fn dst_array_element(mut self, dst_array_element: u32) -> Self {
        self.dst_array_element = dst_array_element;
        self
    }
    #[inline]
    pub fn descriptor_count(mut self, descriptor_count: u32) -> Self {
        self.descriptor_count = descriptor_count;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferCreateInfo.html>"]
pub struct BufferCreateInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: BufferCreateFlags,
    pub size: DeviceSize,
    pub usage: BufferUsageFlags,
    pub sharing_mode: SharingMode,
    pub queue_family_index_count: u32,
    pub p_queue_family_indices: *const u32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for BufferCreateInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: BufferCreateFlags::default(),
            size: DeviceSize::default(),
            usage: BufferUsageFlags::default(),
            sharing_mode: SharingMode::default(),
            queue_family_index_count: u32::default(),
            p_queue_family_indices: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for BufferCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::BUFFER_CREATE_INFO;
}
pub unsafe trait ExtendsBufferCreateInfo {}
impl<'a> BufferCreateInfo<'a> {
    #[inline]
    pub fn flags(mut self, flags: BufferCreateFlags) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn size(mut self, size: DeviceSize) -> Self {
        self.size = size;
        self
    }
    #[inline]
    pub fn usage(mut self, usage: BufferUsageFlags) -> Self {
        self.usage = usage;
        self
    }
    #[inline]
    pub fn sharing_mode(mut self, sharing_mode: SharingMode) -> Self {
        self.sharing_mode = sharing_mode;
        self
    }
    #[inline]
    pub fn queue_family_indices(mut self, queue_family_indices: &'a [u32]) -> Self {
        self.queue_family_index_count = queue_family_indices.len() as _;
        self.p_queue_family_indices = queue_family_indices.as_ptr();
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `x.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsBufferCreateInfo>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.p_next as _;
            self.p_next = next_ptr;
        }
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferViewCreateInfo.html>"]
pub struct BufferViewCreateInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: BufferViewCreateFlags,
    pub buffer: Buffer,
    pub format: Format,
    pub offset: DeviceSize,
    pub range: DeviceSize,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for BufferViewCreateInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: BufferViewCreateFlags::default(),
            buffer: Buffer::default(),
            format: Format::default(),
            offset: DeviceSize::default(),
            range: DeviceSize::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for BufferViewCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::BUFFER_VIEW_CREATE_INFO;
}
pub unsafe trait ExtendsBufferViewCreateInfo {}
impl<'a> BufferViewCreateInfo<'a> {
    #[inline]
    pub fn flags(mut self, flags: BufferViewCreateFlags) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn buffer(mut self, buffer: Buffer) -> Self {
        self.buffer = buffer;
        self
    }
    #[inline]
    pub fn format(mut self, format: Format) -> Self {
        self.format = format;
        self
    }
    #[inline]
    pub fn offset(mut self, offset: DeviceSize) -> Self {
        self.offset = offset;
        self
    }
    #[inline]
    pub fn range(mut self, range: DeviceSize) -> Self {
        self.range = range;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `x.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsBufferViewCreateInfo>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.p_next as _;
            self.p_next = next_ptr;
        }
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageSubresource.html>"]
pub struct ImageSubresource {
    pub aspect_mask: ImageAspectFlags,
    pub mip_level: u32,
    pub array_layer: u32,
}
impl ImageSubresource {
    #[inline]
    pub fn aspect_mask(mut self, aspect_mask: ImageAspectFlags) -> Self {
        self.aspect_mask = aspect_mask;
        self
    }
    #[inline]
    pub fn mip_level(mut self, mip_level: u32) -> Self {
        self.mip_level = mip_level;
        self
    }
    #[inline]
    pub fn array_layer(mut self, array_layer: u32) -> Self {
        self.array_layer = array_layer;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageSubresourceLayers.html>"]
pub struct ImageSubresourceLayers {
    pub aspect_mask: ImageAspectFlags,
    pub mip_level: u32,
    pub base_array_layer: u32,
    pub layer_count: u32,
}
impl ImageSubresourceLayers {
    #[inline]
    pub fn aspect_mask(mut self, aspect_mask: ImageAspectFlags) -> Self {
        self.aspect_mask = aspect_mask;
        self
    }
    #[inline]
    pub fn mip_level(mut self, mip_level: u32) -> Self {
        self.mip_level = mip_level;
        self
    }
    #[inline]
    pub fn base_array_layer(mut self, base_array_layer: u32) -> Self {
        self.base_array_layer = base_array_layer;
        self
    }
    #[inline]
    pub fn layer_count(mut self, layer_count: u32) -> Self {
        self.layer_count = layer_count;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageSubresourceRange.html>"]
pub struct ImageSubresourceRange {
    pub aspect_mask: ImageAspectFlags,
    pub base_mip_level: u32,
    pub level_count: u32,
    pub base_array_layer: u32,
    pub layer_count: u32,
}
impl ImageSubresourceRange {
    #[inline]
    pub fn aspect_mask(mut self, aspect_mask: ImageAspectFlags) -> Self {
        self.aspect_mask = aspect_mask;
        self
    }
    #[inline]
    pub fn base_mip_level(mut self, base_mip_level: u32) -> Self {
        self.base_mip_level = base_mip_level;
        self
    }
    #[inline]
    pub fn level_count(mut self, level_count: u32) -> Self {
        self.level_count = level_count;
        self
    }
    #[inline]
    pub fn base_array_layer(mut self, base_array_layer: u32) -> Self {
        self.base_array_layer = base_array_layer;
        self
    }
    #[inline]
    pub fn layer_count(mut self, layer_count: u32) -> Self {
        self.layer_count = layer_count;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryBarrier.html>"]
pub struct MemoryBarrier<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub src_access_mask: AccessFlags,
    pub dst_access_mask: AccessFlags,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for MemoryBarrier<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            src_access_mask: AccessFlags::default(),
            dst_access_mask: AccessFlags::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for MemoryBarrier<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::MEMORY_BARRIER;
}
impl<'a> MemoryBarrier<'a> {
    #[inline]
    pub fn src_access_mask(mut self, src_access_mask: AccessFlags) -> Self {
        self.src_access_mask = src_access_mask;
        self
    }
    #[inline]
    pub fn dst_access_mask(mut self, dst_access_mask: AccessFlags) -> Self {
        self.dst_access_mask = dst_access_mask;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferMemoryBarrier.html>"]
pub struct BufferMemoryBarrier<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub src_access_mask: AccessFlags,
    pub dst_access_mask: AccessFlags,
    pub src_queue_family_index: u32,
    pub dst_queue_family_index: u32,
    pub buffer: Buffer,
    pub offset: DeviceSize,
    pub size: DeviceSize,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for BufferMemoryBarrier<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            src_access_mask: AccessFlags::default(),
            dst_access_mask: AccessFlags::default(),
            src_queue_family_index: u32::default(),
            dst_queue_family_index: u32::default(),
            buffer: Buffer::default(),
            offset: DeviceSize::default(),
            size: DeviceSize::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for BufferMemoryBarrier<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::BUFFER_MEMORY_BARRIER;
}
impl<'a> BufferMemoryBarrier<'a> {
    #[inline]
    pub fn src_access_mask(mut self, src_access_mask: AccessFlags) -> Self {
        self.src_access_mask = src_access_mask;
        self
    }
    #[inline]
    pub fn dst_access_mask(mut self, dst_access_mask: AccessFlags) -> Self {
        self.dst_access_mask = dst_access_mask;
        self
    }
    #[inline]
    pub fn src_queue_family_index(mut self, src_queue_family_index: u32) -> Self {
        self.src_queue_family_index = src_queue_family_index;
        self
    }
    #[inline]
    pub fn dst_queue_family_index(mut self, dst_queue_family_index: u32) -> Self {
        self.dst_queue_family_index = dst_queue_family_index;
        self
    }
    #[inline]
    pub fn buffer(mut self, buffer: Buffer) -> Self {
        self.buffer = buffer;
        self
    }
    #[inline]
    pub fn offset(mut self, offset: DeviceSize) -> Self {
        self.offset = offset;
        self
    }
    #[inline]
    pub fn size(mut self, size: DeviceSize) -> Self {
        self.size = size;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageMemoryBarrier.html>"]
pub struct ImageMemoryBarrier<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub src_access_mask: AccessFlags,
    pub dst_access_mask: AccessFlags,
    pub old_layout: ImageLayout,
    pub new_layout: ImageLayout,
    pub src_queue_family_index: u32,
    pub dst_queue_family_index: u32,
    pub image: Image,
    pub subresource_range: ImageSubresourceRange,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for ImageMemoryBarrier<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            src_access_mask: AccessFlags::default(),
            dst_access_mask: AccessFlags::default(),
            old_layout: ImageLayout::default(),
            new_layout: ImageLayout::default(),
            src_queue_family_index: u32::default(),
            dst_queue_family_index: u32::default(),
            image: Image::default(),
            subresource_range: ImageSubresourceRange::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for ImageMemoryBarrier<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::IMAGE_MEMORY_BARRIER;
}
pub unsafe trait ExtendsImageMemoryBarrier {}
impl<'a> ImageMemoryBarrier<'a> {
    #[inline]
    pub fn src_access_mask(mut self, src_access_mask: AccessFlags) -> Self {
        self.src_access_mask = src_access_mask;
        self
    }
    #[inline]
    pub fn dst_access_mask(mut self, dst_access_mask: AccessFlags) -> Self {
        self.dst_access_mask = dst_access_mask;
        self
    }
    #[inline]
    pub fn old_layout(mut self, old_layout: ImageLayout) -> Self {
        self.old_layout = old_layout;
        self
    }
    #[inline]
    pub fn new_layout(mut self, new_layout: ImageLayout) -> Self {
        self.new_layout = new_layout;
        self
    }
    #[inline]
    pub fn src_queue_family_index(mut self, src_queue_family_index: u32) -> Self {
        self.src_queue_family_index = src_queue_family_index;
        self
    }
    #[inline]
    pub fn dst_queue_family_index(mut self, dst_queue_family_index: u32) -> Self {
        self.dst_queue_family_index = dst_queue_family_index;
        self
    }
    #[inline]
    pub fn image(mut self, image: Image) -> Self {
        self.image = image;
        self
    }
    #[inline]
    pub fn subresource_range(mut self, subresource_range: ImageSubresourceRange) -> Self {
        self.subresource_range = subresource_range;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `x.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsImageMemoryBarrier>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.p_next as _;
            self.p_next = next_ptr;
        }
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageCreateInfo.html>"]
pub struct ImageCreateInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: ImageCreateFlags,
    pub image_type: ImageType,
    pub format: Format,
    pub extent: Extent3D,
    pub mip_levels: u32,
    pub array_layers: u32,
    pub samples: SampleCountFlags,
    pub tiling: ImageTiling,
    pub usage: ImageUsageFlags,
    pub sharing_mode: SharingMode,
    pub queue_family_index_count: u32,
    pub p_queue_family_indices: *const u32,
    pub initial_layout: ImageLayout,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for ImageCreateInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: ImageCreateFlags::default(),
            image_type: ImageType::default(),
            format: Format::default(),
            extent: Extent3D::default(),
            mip_levels: u32::default(),
            array_layers: u32::default(),
            samples: SampleCountFlags::default(),
            tiling: ImageTiling::default(),
            usage: ImageUsageFlags::default(),
            sharing_mode: SharingMode::default(),
            queue_family_index_count: u32::default(),
            p_queue_family_indices: ::std::ptr::null(),
            initial_layout: ImageLayout::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for ImageCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::IMAGE_CREATE_INFO;
}
pub unsafe trait ExtendsImageCreateInfo {}
impl<'a> ImageCreateInfo<'a> {
    #[inline]
    pub fn flags(mut self, flags: ImageCreateFlags) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn image_type(mut self, image_type: ImageType) -> Self {
        self.image_type = image_type;
        self
    }
    #[inline]
    pub fn format(mut self, format: Format) -> Self {
        self.format = format;
        self
    }
    #[inline]
    pub fn extent(mut self, extent: Extent3D) -> Self {
        self.extent = extent;
        self
    }
    #[inline]
    pub fn mip_levels(mut self, mip_levels: u32) -> Self {
        self.mip_levels = mip_levels;
        self
    }
    #[inline]
    pub fn array_layers(mut self, array_layers: u32) -> Self {
        self.array_layers = array_layers;
        self
    }
    #[inline]
    pub fn samples(mut self, samples: SampleCountFlags) -> Self {
        self.samples = samples;
        self
    }
    #[inline]
    pub fn tiling(mut self, tiling: ImageTiling) -> Self {
        self.tiling = tiling;
        self
    }
    #[inline]
    pub fn usage(mut self, usage: ImageUsageFlags) -> Self {
        self.usage = usage;
        self
    }
    #[inline]
    pub fn sharing_mode(mut self, sharing_mode: SharingMode) -> Self {
        self.sharing_mode = sharing_mode;
        self
    }
    #[inline]
    pub fn queue_family_indices(mut self, queue_family_indices: &'a [u32]) -> Self {
        self.queue_family_index_count = queue_family_indices.len() as _;
        self.p_queue_family_indices = queue_family_indices.as_ptr();
        self
    }
    #[inline]
    pub fn initial_layout(mut self, initial_layout: ImageLayout) -> Self {
        self.initial_layout = initial_layout;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `x.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsImageCreateInfo>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.p_next as _;
            self.p_next = next_ptr;
        }
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSubresourceLayout.html>"]
pub struct SubresourceLayout {
    pub offset: DeviceSize,
    pub size: DeviceSize,
    pub row_pitch: DeviceSize,
    pub array_pitch: DeviceSize,
    pub depth_pitch: DeviceSize,
}
impl SubresourceLayout {
    #[inline]
    pub fn offset(mut self, offset: DeviceSize) -> Self {
        self.offset = offset;
        self
    }
    #[inline]
    pub fn size(mut self, size: DeviceSize) -> Self {
        self.size = size;
        self
    }
    #[inline]
    pub fn row_pitch(mut self, row_pitch: DeviceSize) -> Self {
        self.row_pitch = row_pitch;
        self
    }
    #[inline]
    pub fn array_pitch(mut self, array_pitch: DeviceSize) -> Self {
        self.array_pitch = array_pitch;
        self
    }
    #[inline]
    pub fn depth_pitch(mut self, depth_pitch: DeviceSize) -> Self {
        self.depth_pitch = depth_pitch;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageViewCreateInfo.html>"]
pub struct ImageViewCreateInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: ImageViewCreateFlags,
    pub image: Image,
    pub view_type: ImageViewType,
    pub format: Format,
    pub components: ComponentMapping,
    pub subresource_range: ImageSubresourceRange,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for ImageViewCreateInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: ImageViewCreateFlags::default(),
            image: Image::default(),
            view_type: ImageViewType::default(),
            format: Format::default(),
            components: ComponentMapping::default(),
            subresource_range: ImageSubresourceRange::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for ImageViewCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::IMAGE_VIEW_CREATE_INFO;
}
pub unsafe trait ExtendsImageViewCreateInfo {}
impl<'a> ImageViewCreateInfo<'a> {
    #[inline]
    pub fn flags(mut self, flags: ImageViewCreateFlags) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn image(mut self, image: Image) -> Self {
        self.image = image;
        self
    }
    #[inline]
    pub fn view_type(mut self, view_type: ImageViewType) -> Self {
        self.view_type = view_type;
        self
    }
    #[inline]
    pub fn format(mut self, format: Format) -> Self {
        self.format = format;
        self
    }
    #[inline]
    pub fn components(mut self, components: ComponentMapping) -> Self {
        self.components = components;
        self
    }
    #[inline]
    pub fn subresource_range(mut self, subresource_range: ImageSubresourceRange) -> Self {
        self.subresource_range = subresource_range;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `x.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsImageViewCreateInfo>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.p_next as _;
            self.p_next = next_ptr;
        }
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferCopy.html>"]
pub struct BufferCopy {
    pub src_offset: DeviceSize,
    pub dst_offset: DeviceSize,
    pub size: DeviceSize,
}
impl BufferCopy {
    #[inline]
    pub fn src_offset(mut self, src_offset: DeviceSize) -> Self {
        self.src_offset = src_offset;
        self
    }
    #[inline]
    pub fn dst_offset(mut self, dst_offset: DeviceSize) -> Self {
        self.dst_offset = dst_offset;
        self
    }
    #[inline]
    pub fn size(mut self, size: DeviceSize) -> Self {
        self.size = size;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSparseMemoryBind.html>"]
pub struct SparseMemoryBind {
    pub resource_offset: DeviceSize,
    pub size: DeviceSize,
    pub memory: DeviceMemory,
    pub memory_offset: DeviceSize,
    pub flags: SparseMemoryBindFlags,
}
impl SparseMemoryBind {
    #[inline]
    pub fn resource_offset(mut self, resource_offset: DeviceSize) -> Self {
        self.resource_offset = resource_offset;
        self
    }
    #[inline]
    pub fn size(mut self, size: DeviceSize) -> Self {
        self.size = size;
        self
    }
    #[inline]
    pub fn memory(mut self, memory: DeviceMemory) -> Self {
        self.memory = memory;
        self
    }
    #[inline]
    pub fn memory_offset(mut self, memory_offset: DeviceSize) -> Self {
        self.memory_offset = memory_offset;
        self
    }
    #[inline]
    pub fn flags(mut self, flags: SparseMemoryBindFlags) -> Self {
        self.flags = flags;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSparseImageMemoryBind.html>"]
pub struct SparseImageMemoryBind {
    pub subresource: ImageSubresource,
    pub offset: Offset3D,
    pub extent: Extent3D,
    pub memory: DeviceMemory,
    pub memory_offset: DeviceSize,
    pub flags: SparseMemoryBindFlags,
}
impl SparseImageMemoryBind {
    #[inline]
    pub fn subresource(mut self, subresource: ImageSubresource) -> Self {
        self.subresource = subresource;
        self
    }
    #[inline]
    pub fn offset(mut self, offset: Offset3D) -> Self {
        self.offset = offset;
        self
    }
    #[inline]
    pub fn extent(mut self, extent: Extent3D) -> Self {
        self.extent = extent;
        self
    }
    #[inline]
    pub fn memory(mut self, memory: DeviceMemory) -> Self {
        self.memory = memory;
        self
    }
    #[inline]
    pub fn memory_offset(mut self, memory_offset: DeviceSize) -> Self {
        self.memory_offset = memory_offset;
        self
    }
    #[inline]
    pub fn flags(mut self, flags: SparseMemoryBindFlags) -> Self {
        self.flags = flags;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSparseBufferMemoryBindInfo.html>"]
pub struct SparseBufferMemoryBindInfo<'a> {
    pub buffer: Buffer,
    pub bind_count: u32,
    pub p_binds: *const SparseMemoryBind,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for SparseBufferMemoryBindInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            buffer: Buffer::default(),
            bind_count: u32::default(),
            p_binds: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
impl<'a> SparseBufferMemoryBindInfo<'a> {
    #[inline]
    pub fn buffer(mut self, buffer: Buffer) -> Self {
        self.buffer = buffer;
        self
    }
    #[inline]
    pub fn binds(mut self, binds: &'a [SparseMemoryBind]) -> Self {
        self.bind_count = binds.len() as _;
        self.p_binds = binds.as_ptr();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSparseImageOpaqueMemoryBindInfo.html>"]
pub struct SparseImageOpaqueMemoryBindInfo<'a> {
    pub image: Image,
    pub bind_count: u32,
    pub p_binds: *const SparseMemoryBind,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for SparseImageOpaqueMemoryBindInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            image: Image::default(),
            bind_count: u32::default(),
            p_binds: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
impl<'a> SparseImageOpaqueMemoryBindInfo<'a> {
    #[inline]
    pub fn image(mut self, image: Image) -> Self {
        self.image = image;
        self
    }
    #[inline]
    pub fn binds(mut self, binds: &'a [SparseMemoryBind]) -> Self {
        self.bind_count = binds.len() as _;
        self.p_binds = binds.as_ptr();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSparseImageMemoryBindInfo.html>"]
pub struct SparseImageMemoryBindInfo<'a> {
    pub image: Image,
    pub bind_count: u32,
    pub p_binds: *const SparseImageMemoryBind,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for SparseImageMemoryBindInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            image: Image::default(),
            bind_count: u32::default(),
            p_binds: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
impl<'a> SparseImageMemoryBindInfo<'a> {
    #[inline]
    pub fn image(mut self, image: Image) -> Self {
        self.image = image;
        self
    }
    #[inline]
    pub fn binds(mut self, binds: &'a [SparseImageMemoryBind]) -> Self {
        self.bind_count = binds.len() as _;
        self.p_binds = binds.as_ptr();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBindSparseInfo.html>"]
pub struct BindSparseInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub wait_semaphore_count: u32,
    pub p_wait_semaphores: *const Semaphore,
    pub buffer_bind_count: u32,
    pub p_buffer_binds: *const SparseBufferMemoryBindInfo<'a>,
    pub image_opaque_bind_count: u32,
    pub p_image_opaque_binds: *const SparseImageOpaqueMemoryBindInfo<'a>,
    pub image_bind_count: u32,
    pub p_image_binds: *const SparseImageMemoryBindInfo<'a>,
    pub signal_semaphore_count: u32,
    pub p_signal_semaphores: *const Semaphore,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for BindSparseInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            wait_semaphore_count: u32::default(),
            p_wait_semaphores: ::std::ptr::null(),
            buffer_bind_count: u32::default(),
            p_buffer_binds: ::std::ptr::null(),
            image_opaque_bind_count: u32::default(),
            p_image_opaque_binds: ::std::ptr::null(),
            image_bind_count: u32::default(),
            p_image_binds: ::std::ptr::null(),
            signal_semaphore_count: u32::default(),
            p_signal_semaphores: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for BindSparseInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::BIND_SPARSE_INFO;
}
pub unsafe trait ExtendsBindSparseInfo {}
impl<'a> BindSparseInfo<'a> {
    #[inline]
    pub fn wait_semaphores(mut self, wait_semaphores: &'a [Semaphore]) -> Self {
        self.wait_semaphore_count = wait_semaphores.len() as _;
        self.p_wait_semaphores = wait_semaphores.as_ptr();
        self
    }
    #[inline]
    pub fn buffer_binds(mut self, buffer_binds: &'a [SparseBufferMemoryBindInfo]) -> Self {
        self.buffer_bind_count = buffer_binds.len() as _;
        self.p_buffer_binds = buffer_binds.as_ptr();
        self
    }
    #[inline]
    pub fn image_opaque_binds(
        mut self,
        image_opaque_binds: &'a [SparseImageOpaqueMemoryBindInfo],
    ) -> Self {
        self.image_opaque_bind_count = image_opaque_binds.len() as _;
        self.p_image_opaque_binds = image_opaque_binds.as_ptr();
        self
    }
    #[inline]
    pub fn image_binds(mut self, image_binds: &'a [SparseImageMemoryBindInfo]) -> Self {
        self.image_bind_count = image_binds.len() as _;
        self.p_image_binds = image_binds.as_ptr();
        self
    }
    #[inline]
    pub fn signal_semaphores(mut self, signal_semaphores: &'a [Semaphore]) -> Self {
        self.signal_semaphore_count = signal_semaphores.len() as _;
        self.p_signal_semaphores = signal_semaphores.as_ptr();
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `x.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsBindSparseInfo>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.p_next as _;
            self.p_next = next_ptr;
        }
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageCopy.html>"]
pub struct ImageCopy {
    pub src_subresource: ImageSubresourceLayers,
    pub src_offset: Offset3D,
    pub dst_subresource: ImageSubresourceLayers,
    pub dst_offset: Offset3D,
    pub extent: Extent3D,
}
impl ImageCopy {
    #[inline]
    pub fn src_subresource(mut self, src_subresource: ImageSubresourceLayers) -> Self {
        self.src_subresource = src_subresource;
        self
    }
    #[inline]
    pub fn src_offset(mut self, src_offset: Offset3D) -> Self {
        self.src_offset = src_offset;
        self
    }
    #[inline]
    pub fn dst_subresource(mut self, dst_subresource: ImageSubresourceLayers) -> Self {
        self.dst_subresource = dst_subresource;
        self
    }
    #[inline]
    pub fn dst_offset(mut self, dst_offset: Offset3D) -> Self {
        self.dst_offset = dst_offset;
        self
    }
    #[inline]
    pub fn extent(mut self, extent: Extent3D) -> Self {
        self.extent = extent;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageBlit.html>"]
pub struct ImageBlit {
    pub src_subresource: ImageSubresourceLayers,
    pub src_offsets: [Offset3D; 2],
    pub dst_subresource: ImageSubresourceLayers,
    pub dst_offsets: [Offset3D; 2],
}
impl ::std::default::Default for ImageBlit {
    #[inline]
    fn default() -> Self {
        Self {
            src_subresource: ImageSubresourceLayers::default(),
            src_offsets: unsafe { ::std::mem::zeroed() },
            dst_subresource: ImageSubresourceLayers::default(),
            dst_offsets: unsafe { ::std::mem::zeroed() },
        }
    }
}
impl ImageBlit {
    #[inline]
    pub fn src_subresource(mut self, src_subresource: ImageSubresourceLayers) -> Self {
        self.src_subresource = src_subresource;
        self
    }
    #[inline]
    pub fn src_offsets(mut self, src_offsets: [Offset3D; 2]) -> Self {
        self.src_offsets = src_offsets;
        self
    }
    #[inline]
    pub fn dst_subresource(mut self, dst_subresource: ImageSubresourceLayers) -> Self {
        self.dst_subresource = dst_subresource;
        self
    }
    #[inline]
    pub fn dst_offsets(mut self, dst_offsets: [Offset3D; 2]) -> Self {
        self.dst_offsets = dst_offsets;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferImageCopy.html>"]
pub struct BufferImageCopy {
    pub buffer_offset: DeviceSize,
    pub buffer_row_length: u32,
    pub buffer_image_height: u32,
    pub image_subresource: ImageSubresourceLayers,
    pub image_offset: Offset3D,
    pub image_extent: Extent3D,
}
impl BufferImageCopy {
    #[inline]
    pub fn buffer_offset(mut self, buffer_offset: DeviceSize) -> Self {
        self.buffer_offset = buffer_offset;
        self
    }
    #[inline]
    pub fn buffer_row_length(mut self, buffer_row_length: u32) -> Self {
        self.buffer_row_length = buffer_row_length;
        self
    }
    #[inline]
    pub fn buffer_image_height(mut self, buffer_image_height: u32) -> Self {
        self.buffer_image_height = buffer_image_height;
        self
    }
    #[inline]
    pub fn image_subresource(mut self, image_subresource: ImageSubresourceLayers) -> Self {
        self.image_subresource = image_subresource;
        self
    }
    #[inline]
    pub fn image_offset(mut self, image_offset: Offset3D) -> Self {
        self.image_offset = image_offset;
        self
    }
    #[inline]
    pub fn image_extent(mut self, image_extent: Extent3D) -> Self {
        self.image_extent = image_extent;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageResolve.html>"]
pub struct ImageResolve {
    pub src_subresource: ImageSubresourceLayers,
    pub src_offset: Offset3D,
    pub dst_subresource: ImageSubresourceLayers,
    pub dst_offset: Offset3D,
    pub extent: Extent3D,
}
impl ImageResolve {
    #[inline]
    pub fn src_subresource(mut self, src_subresource: ImageSubresourceLayers) -> Self {
        self.src_subresource = src_subresource;
        self
    }
    #[inline]
    pub fn src_offset(mut self, src_offset: Offset3D) -> Self {
        self.src_offset = src_offset;
        self
    }
    #[inline]
    pub fn dst_subresource(mut self, dst_subresource: ImageSubresourceLayers) -> Self {
        self.dst_subresource = dst_subresource;
        self
    }
    #[inline]
    pub fn dst_offset(mut self, dst_offset: Offset3D) -> Self {
        self.dst_offset = dst_offset;
        self
    }
    #[inline]
    pub fn extent(mut self, extent: Extent3D) -> Self {
        self.extent = extent;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkShaderModuleCreateInfo.html>"]
pub struct ShaderModuleCreateInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: ShaderModuleCreateFlags,
    pub code_size: usize,
    pub p_code: *const u32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for ShaderModuleCreateInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: ShaderModuleCreateFlags::default(),
            code_size: usize::default(),
            p_code: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for ShaderModuleCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::SHADER_MODULE_CREATE_INFO;
}
unsafe impl ExtendsPipelineShaderStageCreateInfo for ShaderModuleCreateInfo<'_> {}
pub unsafe trait ExtendsShaderModuleCreateInfo {}
impl<'a> ShaderModuleCreateInfo<'a> {
    #[inline]
    pub fn flags(mut self, flags: ShaderModuleCreateFlags) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn code(mut self, code: &'a [u32]) -> Self {
        self.code_size = code.len() * 4;
        self.p_code = code.as_ptr();
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `x.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsShaderModuleCreateInfo>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.p_next as _;
            self.p_next = next_ptr;
        }
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorSetLayoutBinding.html>"]
pub struct DescriptorSetLayoutBinding<'a> {
    pub binding: u32,
    pub descriptor_type: DescriptorType,
    pub descriptor_count: u32,
    pub stage_flags: ShaderStageFlags,
    pub p_immutable_samplers: *const Sampler,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for DescriptorSetLayoutBinding<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            binding: u32::default(),
            descriptor_type: DescriptorType::default(),
            descriptor_count: u32::default(),
            stage_flags: ShaderStageFlags::default(),
            p_immutable_samplers: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
impl<'a> DescriptorSetLayoutBinding<'a> {
    #[inline]
    pub fn binding(mut self, binding: u32) -> Self {
        self.binding = binding;
        self
    }
    #[inline]
    pub fn descriptor_type(mut self, descriptor_type: DescriptorType) -> Self {
        self.descriptor_type = descriptor_type;
        self
    }
    #[inline]
    pub fn descriptor_count(mut self, descriptor_count: u32) -> Self {
        self.descriptor_count = descriptor_count;
        self
    }
    #[inline]
    pub fn stage_flags(mut self, stage_flags: ShaderStageFlags) -> Self {
        self.stage_flags = stage_flags;
        self
    }
    #[inline]
    pub fn immutable_samplers(mut self, immutable_samplers: &'a [Sampler]) -> Self {
        self.descriptor_count = immutable_samplers.len() as _;
        self.p_immutable_samplers = immutable_samplers.as_ptr();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorSetLayoutCreateInfo.html>"]
pub struct DescriptorSetLayoutCreateInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: DescriptorSetLayoutCreateFlags,
    pub binding_count: u32,
    pub p_bindings: *const DescriptorSetLayoutBinding<'a>,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for DescriptorSetLayoutCreateInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: DescriptorSetLayoutCreateFlags::default(),
            binding_count: u32::default(),
            p_bindings: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for DescriptorSetLayoutCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
}
pub unsafe trait ExtendsDescriptorSetLayoutCreateInfo {}
impl<'a> DescriptorSetLayoutCreateInfo<'a> {
    #[inline]
    pub fn flags(mut self, flags: DescriptorSetLayoutCreateFlags) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn bindings(mut self, bindings: &'a [DescriptorSetLayoutBinding]) -> Self {
        self.binding_count = bindings.len() as _;
        self.p_bindings = bindings.as_ptr();
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `x.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsDescriptorSetLayoutCreateInfo>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.p_next as _;
            self.p_next = next_ptr;
        }
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorPoolSize.html>"]
pub struct DescriptorPoolSize {
    pub ty: DescriptorType,
    pub descriptor_count: u32,
}
impl DescriptorPoolSize {
    #[inline]
    pub fn ty(mut self, ty: DescriptorType) -> Self {
        self.ty = ty;
        self
    }
    #[inline]
    pub fn descriptor_count(mut self, descriptor_count: u32) -> Self {
        self.descriptor_count = descriptor_count;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorPoolCreateInfo.html>"]
pub struct DescriptorPoolCreateInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: DescriptorPoolCreateFlags,
    pub max_sets: u32,
    pub pool_size_count: u32,
    pub p_pool_sizes: *const DescriptorPoolSize,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for DescriptorPoolCreateInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: DescriptorPoolCreateFlags::default(),
            max_sets: u32::default(),
            pool_size_count: u32::default(),
            p_pool_sizes: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for DescriptorPoolCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DESCRIPTOR_POOL_CREATE_INFO;
}
pub unsafe trait ExtendsDescriptorPoolCreateInfo {}
impl<'a> DescriptorPoolCreateInfo<'a> {
    #[inline]
    pub fn flags(mut self, flags: DescriptorPoolCreateFlags) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn max_sets(mut self, max_sets: u32) -> Self {
        self.max_sets = max_sets;
        self
    }
    #[inline]
    pub fn pool_sizes(mut self, pool_sizes: &'a [DescriptorPoolSize]) -> Self {
        self.pool_size_count = pool_sizes.len() as _;
        self.p_pool_sizes = pool_sizes.as_ptr();
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `x.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsDescriptorPoolCreateInfo>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.p_next as _;
            self.p_next = next_ptr;
        }
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorSetAllocateInfo.html>"]
pub struct DescriptorSetAllocateInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub descriptor_pool: DescriptorPool,
    pub descriptor_set_count: u32,
    pub p_set_layouts: *const DescriptorSetLayout,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for DescriptorSetAllocateInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            descriptor_pool: DescriptorPool::default(),
            descriptor_set_count: u32::default(),
            p_set_layouts: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for DescriptorSetAllocateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DESCRIPTOR_SET_ALLOCATE_INFO;
}
pub unsafe trait ExtendsDescriptorSetAllocateInfo {}
impl<'a> DescriptorSetAllocateInfo<'a> {
    #[inline]
    pub fn descriptor_pool(mut self, descriptor_pool: DescriptorPool) -> Self {
        self.descriptor_pool = descriptor_pool;
        self
    }
    #[inline]
    pub fn set_layouts(mut self, set_layouts: &'a [DescriptorSetLayout]) -> Self {
        self.descriptor_set_count = set_layouts.len() as _;
        self.p_set_layouts = set_layouts.as_ptr();
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `x.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsDescriptorSetAllocateInfo>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.p_next as _;
            self.p_next = next_ptr;
        }
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSpecializationMapEntry.html>"]
pub struct SpecializationMapEntry {
    pub constant_id: u32,
    pub offset: u32,
    pub size: usize,
}
impl SpecializationMapEntry {
    #[inline]
    pub fn constant_id(mut self, constant_id: u32) -> Self {
        self.constant_id = constant_id;
        self
    }
    #[inline]
    pub fn offset(mut self, offset: u32) -> Self {
        self.offset = offset;
        self
    }
    #[inline]
    pub fn size(mut self, size: usize) -> Self {
        self.size = size;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSpecializationInfo.html>"]
pub struct SpecializationInfo<'a> {
    pub map_entry_count: u32,
    pub p_map_entries: *const SpecializationMapEntry,
    pub data_size: usize,
    pub p_data: *const c_void,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for SpecializationInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            map_entry_count: u32::default(),
            p_map_entries: ::std::ptr::null(),
            data_size: usize::default(),
            p_data: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
impl<'a> SpecializationInfo<'a> {
    #[inline]
    pub fn map_entries(mut self, map_entries: &'a [SpecializationMapEntry]) -> Self {
        self.map_entry_count = map_entries.len() as _;
        self.p_map_entries = map_entries.as_ptr();
        self
    }
    #[inline]
    pub fn data(mut self, data: &'a [u8]) -> Self {
        self.data_size = data.len();
        self.p_data = data.as_ptr() as *const c_void;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineShaderStageCreateInfo.html>"]
pub struct PipelineShaderStageCreateInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: PipelineShaderStageCreateFlags,
    pub stage: ShaderStageFlags,
    pub module: ShaderModule,
    pub p_name: *const c_char,
    pub p_specialization_info: *const SpecializationInfo<'a>,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PipelineShaderStageCreateInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: PipelineShaderStageCreateFlags::default(),
            stage: ShaderStageFlags::default(),
            module: ShaderModule::default(),
            p_name: ::std::ptr::null(),
            p_specialization_info: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PipelineShaderStageCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PIPELINE_SHADER_STAGE_CREATE_INFO;
}
pub unsafe trait ExtendsPipelineShaderStageCreateInfo {}
impl<'a> PipelineShaderStageCreateInfo<'a> {
    #[inline]
    pub fn flags(mut self, flags: PipelineShaderStageCreateFlags) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn stage(mut self, stage: ShaderStageFlags) -> Self {
        self.stage = stage;
        self
    }
    #[inline]
    pub fn module(mut self, module: ShaderModule) -> Self {
        self.module = module;
        self
    }
    #[inline]
    pub fn name(mut self, name: &'a ::std::ffi::CStr) -> Self {
        self.p_name = name.as_ptr();
        self
    }
    #[inline]
    pub fn specialization_info(mut self, specialization_info: &'a SpecializationInfo<'a>) -> Self {
        self.p_specialization_info = specialization_info;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `x.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsPipelineShaderStageCreateInfo>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.p_next as _;
            self.p_next = next_ptr;
        }
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkComputePipelineCreateInfo.html>"]
pub struct ComputePipelineCreateInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: PipelineCreateFlags,
    pub stage: PipelineShaderStageCreateInfo<'a>,
    pub layout: PipelineLayout,
    pub base_pipeline_handle: Pipeline,
    pub base_pipeline_index: i32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for ComputePipelineCreateInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: PipelineCreateFlags::default(),
            stage: PipelineShaderStageCreateInfo::default(),
            layout: PipelineLayout::default(),
            base_pipeline_handle: Pipeline::default(),
            base_pipeline_index: i32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for ComputePipelineCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::COMPUTE_PIPELINE_CREATE_INFO;
}
pub unsafe trait ExtendsComputePipelineCreateInfo {}
impl<'a> ComputePipelineCreateInfo<'a> {
    #[inline]
    pub fn flags(mut self, flags: PipelineCreateFlags) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn stage(mut self, stage: PipelineShaderStageCreateInfo<'a>) -> Self {
        self.stage = stage;
        self
    }
    #[inline]
    pub fn layout(mut self, layout: PipelineLayout) -> Self {
        self.layout = layout;
        self
    }
    #[inline]
    pub fn base_pipeline_handle(mut self, base_pipeline_handle: Pipeline) -> Self {
        self.base_pipeline_handle = base_pipeline_handle;
        self
    }
    #[inline]
    pub fn base_pipeline_index(mut self, base_pipeline_index: i32) -> Self {
        self.base_pipeline_index = base_pipeline_index;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `x.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsComputePipelineCreateInfo>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.p_next as _;
            self.p_next = next_ptr;
        }
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVertexInputBindingDescription.html>"]
pub struct VertexInputBindingDescription {
    pub binding: u32,
    pub stride: u32,
    pub input_rate: VertexInputRate,
}
impl VertexInputBindingDescription {
    #[inline]
    pub fn binding(mut self, binding: u32) -> Self {
        self.binding = binding;
        self
    }
    #[inline]
    pub fn stride(mut self, stride: u32) -> Self {
        self.stride = stride;
        self
    }
    #[inline]
    pub fn input_rate(mut self, input_rate: VertexInputRate) -> Self {
        self.input_rate = input_rate;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVertexInputAttributeDescription.html>"]
pub struct VertexInputAttributeDescription {
    pub location: u32,
    pub binding: u32,
    pub format: Format,
    pub offset: u32,
}
impl VertexInputAttributeDescription {
    #[inline]
    pub fn location(mut self, location: u32) -> Self {
        self.location = location;
        self
    }
    #[inline]
    pub fn binding(mut self, binding: u32) -> Self {
        self.binding = binding;
        self
    }
    #[inline]
    pub fn format(mut self, format: Format) -> Self {
        self.format = format;
        self
    }
    #[inline]
    pub fn offset(mut self, offset: u32) -> Self {
        self.offset = offset;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineVertexInputStateCreateInfo.html>"]
pub struct PipelineVertexInputStateCreateInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: PipelineVertexInputStateCreateFlags,
    pub vertex_binding_description_count: u32,
    pub p_vertex_binding_descriptions: *const VertexInputBindingDescription,
    pub vertex_attribute_description_count: u32,
    pub p_vertex_attribute_descriptions: *const VertexInputAttributeDescription,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PipelineVertexInputStateCreateInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: PipelineVertexInputStateCreateFlags::default(),
            vertex_binding_description_count: u32::default(),
            p_vertex_binding_descriptions: ::std::ptr::null(),
            vertex_attribute_description_count: u32::default(),
            p_vertex_attribute_descriptions: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PipelineVertexInputStateCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
}
pub unsafe trait ExtendsPipelineVertexInputStateCreateInfo {}
impl<'a> PipelineVertexInputStateCreateInfo<'a> {
    #[inline]
    pub fn flags(mut self, flags: PipelineVertexInputStateCreateFlags) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn vertex_binding_descriptions(
        mut self,
        vertex_binding_descriptions: &'a [VertexInputBindingDescription],
    ) -> Self {
        self.vertex_binding_description_count = vertex_binding_descriptions.len() as _;
        self.p_vertex_binding_descriptions = vertex_binding_descriptions.as_ptr();
        self
    }
    #[inline]
    pub fn vertex_attribute_descriptions(
        mut self,
        vertex_attribute_descriptions: &'a [VertexInputAttributeDescription],
    ) -> Self {
        self.vertex_attribute_description_count = vertex_attribute_descriptions.len() as _;
        self.p_vertex_attribute_descriptions = vertex_attribute_descriptions.as_ptr();
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `x.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsPipelineVertexInputStateCreateInfo>(
        mut self,
        next: &'a mut T,
    ) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.p_next as _;
            self.p_next = next_ptr;
        }
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineInputAssemblyStateCreateInfo.html>"]
pub struct PipelineInputAssemblyStateCreateInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: PipelineInputAssemblyStateCreateFlags,
    pub topology: PrimitiveTopology,
    pub primitive_restart_enable: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PipelineInputAssemblyStateCreateInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: PipelineInputAssemblyStateCreateFlags::default(),
            topology: PrimitiveTopology::default(),
            primitive_restart_enable: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PipelineInputAssemblyStateCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
}
impl<'a> PipelineInputAssemblyStateCreateInfo<'a> {
    #[inline]
    pub fn flags(mut self, flags: PipelineInputAssemblyStateCreateFlags) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn topology(mut self, topology: PrimitiveTopology) -> Self {
        self.topology = topology;
        self
    }
    #[inline]
    pub fn primitive_restart_enable(mut self, primitive_restart_enable: bool) -> Self {
        self.primitive_restart_enable = primitive_restart_enable.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineTessellationStateCreateInfo.html>"]
pub struct PipelineTessellationStateCreateInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: PipelineTessellationStateCreateFlags,
    pub patch_control_points: u32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PipelineTessellationStateCreateInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: PipelineTessellationStateCreateFlags::default(),
            patch_control_points: u32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PipelineTessellationStateCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PIPELINE_TESSELLATION_STATE_CREATE_INFO;
}
pub unsafe trait ExtendsPipelineTessellationStateCreateInfo {}
impl<'a> PipelineTessellationStateCreateInfo<'a> {
    #[inline]
    pub fn flags(mut self, flags: PipelineTessellationStateCreateFlags) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn patch_control_points(mut self, patch_control_points: u32) -> Self {
        self.patch_control_points = patch_control_points;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `x.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsPipelineTessellationStateCreateInfo>(
        mut self,
        next: &'a mut T,
    ) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.p_next as _;
            self.p_next = next_ptr;
        }
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineViewportStateCreateInfo.html>"]
pub struct PipelineViewportStateCreateInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: PipelineViewportStateCreateFlags,
    pub viewport_count: u32,
    pub p_viewports: *const Viewport,
    pub scissor_count: u32,
    pub p_scissors: *const Rect2D,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PipelineViewportStateCreateInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: PipelineViewportStateCreateFlags::default(),
            viewport_count: u32::default(),
            p_viewports: ::std::ptr::null(),
            scissor_count: u32::default(),
            p_scissors: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PipelineViewportStateCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PIPELINE_VIEWPORT_STATE_CREATE_INFO;
}
pub unsafe trait ExtendsPipelineViewportStateCreateInfo {}
impl<'a> PipelineViewportStateCreateInfo<'a> {
    #[inline]
    pub fn flags(mut self, flags: PipelineViewportStateCreateFlags) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn viewport_count(mut self, viewport_count: u32) -> Self {
        self.viewport_count = viewport_count;
        self
    }
    #[inline]
    pub fn viewports(mut self, viewports: &'a [Viewport]) -> Self {
        self.viewport_count = viewports.len() as _;
        self.p_viewports = viewports.as_ptr();
        self
    }
    #[inline]
    pub fn scissor_count(mut self, scissor_count: u32) -> Self {
        self.scissor_count = scissor_count;
        self
    }
    #[inline]
    pub fn scissors(mut self, scissors: &'a [Rect2D]) -> Self {
        self.scissor_count = scissors.len() as _;
        self.p_scissors = scissors.as_ptr();
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `x.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsPipelineViewportStateCreateInfo>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.p_next as _;
            self.p_next = next_ptr;
        }
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineRasterizationStateCreateInfo.html>"]
pub struct PipelineRasterizationStateCreateInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: PipelineRasterizationStateCreateFlags,
    pub depth_clamp_enable: Bool32,
    pub rasterizer_discard_enable: Bool32,
    pub polygon_mode: PolygonMode,
    pub cull_mode: CullModeFlags,
    pub front_face: FrontFace,
    pub depth_bias_enable: Bool32,
    pub depth_bias_constant_factor: f32,
    pub depth_bias_clamp: f32,
    pub depth_bias_slope_factor: f32,
    pub line_width: f32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PipelineRasterizationStateCreateInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: PipelineRasterizationStateCreateFlags::default(),
            depth_clamp_enable: Bool32::default(),
            rasterizer_discard_enable: Bool32::default(),
            polygon_mode: PolygonMode::default(),
            cull_mode: CullModeFlags::default(),
            front_face: FrontFace::default(),
            depth_bias_enable: Bool32::default(),
            depth_bias_constant_factor: f32::default(),
            depth_bias_clamp: f32::default(),
            depth_bias_slope_factor: f32::default(),
            line_width: f32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PipelineRasterizationStateCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
}
pub unsafe trait ExtendsPipelineRasterizationStateCreateInfo {}
impl<'a> PipelineRasterizationStateCreateInfo<'a> {
    #[inline]
    pub fn flags(mut self, flags: PipelineRasterizationStateCreateFlags) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn depth_clamp_enable(mut self, depth_clamp_enable: bool) -> Self {
        self.depth_clamp_enable = depth_clamp_enable.into();
        self
    }
    #[inline]
    pub fn rasterizer_discard_enable(mut self, rasterizer_discard_enable: bool) -> Self {
        self.rasterizer_discard_enable = rasterizer_discard_enable.into();
        self
    }
    #[inline]
    pub fn polygon_mode(mut self, polygon_mode: PolygonMode) -> Self {
        self.polygon_mode = polygon_mode;
        self
    }
    #[inline]
    pub fn cull_mode(mut self, cull_mode: CullModeFlags) -> Self {
        self.cull_mode = cull_mode;
        self
    }
    #[inline]
    pub fn front_face(mut self, front_face: FrontFace) -> Self {
        self.front_face = front_face;
        self
    }
    #[inline]
    pub fn depth_bias_enable(mut self, depth_bias_enable: bool) -> Self {
        self.depth_bias_enable = depth_bias_enable.into();
        self
    }
    #[inline]
    pub fn depth_bias_constant_factor(mut self, depth_bias_constant_factor: f32) -> Self {
        self.depth_bias_constant_factor = depth_bias_constant_factor;
        self
    }
    #[inline]
    pub fn depth_bias_clamp(mut self, depth_bias_clamp: f32) -> Self {
        self.depth_bias_clamp = depth_bias_clamp;
        self
    }
    #[inline]
    pub fn depth_bias_slope_factor(mut self, depth_bias_slope_factor: f32) -> Self {
        self.depth_bias_slope_factor = depth_bias_slope_factor;
        self
    }
    #[inline]
    pub fn line_width(mut self, line_width: f32) -> Self {
        self.line_width = line_width;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `x.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsPipelineRasterizationStateCreateInfo>(
        mut self,
        next: &'a mut T,
    ) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.p_next as _;
            self.p_next = next_ptr;
        }
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineMultisampleStateCreateInfo.html>"]
pub struct PipelineMultisampleStateCreateInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: PipelineMultisampleStateCreateFlags,
    pub rasterization_samples: SampleCountFlags,
    pub sample_shading_enable: Bool32,
    pub min_sample_shading: f32,
    pub p_sample_mask: *const SampleMask,
    pub alpha_to_coverage_enable: Bool32,
    pub alpha_to_one_enable: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PipelineMultisampleStateCreateInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: PipelineMultisampleStateCreateFlags::default(),
            rasterization_samples: SampleCountFlags::default(),
            sample_shading_enable: Bool32::default(),
            min_sample_shading: f32::default(),
            p_sample_mask: ::std::ptr::null(),
            alpha_to_coverage_enable: Bool32::default(),
            alpha_to_one_enable: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PipelineMultisampleStateCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
}
pub unsafe trait ExtendsPipelineMultisampleStateCreateInfo {}
impl<'a> PipelineMultisampleStateCreateInfo<'a> {
    #[inline]
    pub fn flags(mut self, flags: PipelineMultisampleStateCreateFlags) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn rasterization_samples(mut self, rasterization_samples: SampleCountFlags) -> Self {
        self.rasterization_samples = rasterization_samples;
        self
    }
    #[inline]
    pub fn sample_shading_enable(mut self, sample_shading_enable: bool) -> Self {
        self.sample_shading_enable = sample_shading_enable.into();
        self
    }
    #[inline]
    pub fn min_sample_shading(mut self, min_sample_shading: f32) -> Self {
        self.min_sample_shading = min_sample_shading;
        self
    }
    #[doc = r" Sets `p_sample_mask` to `null` if the slice is empty. The mask will"]
    #[doc = r" be treated as if it has all bits set to `1`."]
    #[doc = r""]
    #[doc = r" See <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineMultisampleStateCreateInfo.html#_description>"]
    #[doc = r" for more details."]
    #[inline]
    pub fn sample_mask(mut self, sample_mask: &'a [SampleMask]) -> Self {
        self.p_sample_mask = if sample_mask.is_empty() {
            std::ptr::null()
        } else {
            sample_mask.as_ptr()
        };
        self
    }
    #[inline]
    pub fn alpha_to_coverage_enable(mut self, alpha_to_coverage_enable: bool) -> Self {
        self.alpha_to_coverage_enable = alpha_to_coverage_enable.into();
        self
    }
    #[inline]
    pub fn alpha_to_one_enable(mut self, alpha_to_one_enable: bool) -> Self {
        self.alpha_to_one_enable = alpha_to_one_enable.into();
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `x.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsPipelineMultisampleStateCreateInfo>(
        mut self,
        next: &'a mut T,
    ) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.p_next as _;
            self.p_next = next_ptr;
        }
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineColorBlendAttachmentState.html>"]
pub struct PipelineColorBlendAttachmentState {
    pub blend_enable: Bool32,
    pub src_color_blend_factor: BlendFactor,
    pub dst_color_blend_factor: BlendFactor,
    pub color_blend_op: BlendOp,
    pub src_alpha_blend_factor: BlendFactor,
    pub dst_alpha_blend_factor: BlendFactor,
    pub alpha_blend_op: BlendOp,
    pub color_write_mask: ColorComponentFlags,
}
impl PipelineColorBlendAttachmentState {
    #[inline]
    pub fn blend_enable(mut self, blend_enable: bool) -> Self {
        self.blend_enable = blend_enable.into();
        self
    }
    #[inline]
    pub fn src_color_blend_factor(mut self, src_color_blend_factor: BlendFactor) -> Self {
        self.src_color_blend_factor = src_color_blend_factor;
        self
    }
    #[inline]
    pub fn dst_color_blend_factor(mut self, dst_color_blend_factor: BlendFactor) -> Self {
        self.dst_color_blend_factor = dst_color_blend_factor;
        self
    }
    #[inline]
    pub fn color_blend_op(mut self, color_blend_op: BlendOp) -> Self {
        self.color_blend_op = color_blend_op;
        self
    }
    #[inline]
    pub fn src_alpha_blend_factor(mut self, src_alpha_blend_factor: BlendFactor) -> Self {
        self.src_alpha_blend_factor = src_alpha_blend_factor;
        self
    }
    #[inline]
    pub fn dst_alpha_blend_factor(mut self, dst_alpha_blend_factor: BlendFactor) -> Self {
        self.dst_alpha_blend_factor = dst_alpha_blend_factor;
        self
    }
    #[inline]
    pub fn alpha_blend_op(mut self, alpha_blend_op: BlendOp) -> Self {
        self.alpha_blend_op = alpha_blend_op;
        self
    }
    #[inline]
    pub fn color_write_mask(mut self, color_write_mask: ColorComponentFlags) -> Self {
        self.color_write_mask = color_write_mask;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineColorBlendStateCreateInfo.html>"]
pub struct PipelineColorBlendStateCreateInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: PipelineColorBlendStateCreateFlags,
    pub logic_op_enable: Bool32,
    pub logic_op: LogicOp,
    pub attachment_count: u32,
    pub p_attachments: *const PipelineColorBlendAttachmentState,
    pub blend_constants: [f32; 4],
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PipelineColorBlendStateCreateInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: PipelineColorBlendStateCreateFlags::default(),
            logic_op_enable: Bool32::default(),
            logic_op: LogicOp::default(),
            attachment_count: u32::default(),
            p_attachments: ::std::ptr::null(),
            blend_constants: unsafe { ::std::mem::zeroed() },
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PipelineColorBlendStateCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
}
pub unsafe trait ExtendsPipelineColorBlendStateCreateInfo {}
impl<'a> PipelineColorBlendStateCreateInfo<'a> {
    #[inline]
    pub fn flags(mut self, flags: PipelineColorBlendStateCreateFlags) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn logic_op_enable(mut self, logic_op_enable: bool) -> Self {
        self.logic_op_enable = logic_op_enable.into();
        self
    }
    #[inline]
    pub fn logic_op(mut self, logic_op: LogicOp) -> Self {
        self.logic_op = logic_op;
        self
    }
    #[inline]
    pub fn attachments(mut self, attachments: &'a [PipelineColorBlendAttachmentState]) -> Self {
        self.attachment_count = attachments.len() as _;
        self.p_attachments = attachments.as_ptr();
        self
    }
    #[inline]
    pub fn blend_constants(mut self, blend_constants: [f32; 4]) -> Self {
        self.blend_constants = blend_constants;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `x.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsPipelineColorBlendStateCreateInfo>(
        mut self,
        next: &'a mut T,
    ) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.p_next as _;
            self.p_next = next_ptr;
        }
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineDynamicStateCreateInfo.html>"]
pub struct PipelineDynamicStateCreateInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: PipelineDynamicStateCreateFlags,
    pub dynamic_state_count: u32,
    pub p_dynamic_states: *const DynamicState,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PipelineDynamicStateCreateInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: PipelineDynamicStateCreateFlags::default(),
            dynamic_state_count: u32::default(),
            p_dynamic_states: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PipelineDynamicStateCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PIPELINE_DYNAMIC_STATE_CREATE_INFO;
}
impl<'a> PipelineDynamicStateCreateInfo<'a> {
    #[inline]
    pub fn flags(mut self, flags: PipelineDynamicStateCreateFlags) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn dynamic_states(mut self, dynamic_states: &'a [DynamicState]) -> Self {
        self.dynamic_state_count = dynamic_states.len() as _;
        self.p_dynamic_states = dynamic_states.as_ptr();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkStencilOpState.html>"]
pub struct StencilOpState {
    pub fail_op: StencilOp,
    pub pass_op: StencilOp,
    pub depth_fail_op: StencilOp,
    pub compare_op: CompareOp,
    pub compare_mask: u32,
    pub write_mask: u32,
    pub reference: u32,
}
impl StencilOpState {
    #[inline]
    pub fn fail_op(mut self, fail_op: StencilOp) -> Self {
        self.fail_op = fail_op;
        self
    }
    #[inline]
    pub fn pass_op(mut self, pass_op: StencilOp) -> Self {
        self.pass_op = pass_op;
        self
    }
    #[inline]
    pub fn depth_fail_op(mut self, depth_fail_op: StencilOp) -> Self {
        self.depth_fail_op = depth_fail_op;
        self
    }
    #[inline]
    pub fn compare_op(mut self, compare_op: CompareOp) -> Self {
        self.compare_op = compare_op;
        self
    }
    #[inline]
    pub fn compare_mask(mut self, compare_mask: u32) -> Self {
        self.compare_mask = compare_mask;
        self
    }
    #[inline]
    pub fn write_mask(mut self, write_mask: u32) -> Self {
        self.write_mask = write_mask;
        self
    }
    #[inline]
    pub fn reference(mut self, reference: u32) -> Self {
        self.reference = reference;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineDepthStencilStateCreateInfo.html>"]
pub struct PipelineDepthStencilStateCreateInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: PipelineDepthStencilStateCreateFlags,
    pub depth_test_enable: Bool32,
    pub depth_write_enable: Bool32,
    pub depth_compare_op: CompareOp,
    pub depth_bounds_test_enable: Bool32,
    pub stencil_test_enable: Bool32,
    pub front: StencilOpState,
    pub back: StencilOpState,
    pub min_depth_bounds: f32,
    pub max_depth_bounds: f32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PipelineDepthStencilStateCreateInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: PipelineDepthStencilStateCreateFlags::default(),
            depth_test_enable: Bool32::default(),
            depth_write_enable: Bool32::default(),
            depth_compare_op: CompareOp::default(),
            depth_bounds_test_enable: Bool32::default(),
            stencil_test_enable: Bool32::default(),
            front: StencilOpState::default(),
            back: StencilOpState::default(),
            min_depth_bounds: f32::default(),
            max_depth_bounds: f32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PipelineDepthStencilStateCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
}
impl<'a> PipelineDepthStencilStateCreateInfo<'a> {
    #[inline]
    pub fn flags(mut self, flags: PipelineDepthStencilStateCreateFlags) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn depth_test_enable(mut self, depth_test_enable: bool) -> Self {
        self.depth_test_enable = depth_test_enable.into();
        self
    }
    #[inline]
    pub fn depth_write_enable(mut self, depth_write_enable: bool) -> Self {
        self.depth_write_enable = depth_write_enable.into();
        self
    }
    #[inline]
    pub fn depth_compare_op(mut self, depth_compare_op: CompareOp) -> Self {
        self.depth_compare_op = depth_compare_op;
        self
    }
    #[inline]
    pub fn depth_bounds_test_enable(mut self, depth_bounds_test_enable: bool) -> Self {
        self.depth_bounds_test_enable = depth_bounds_test_enable.into();
        self
    }
    #[inline]
    pub fn stencil_test_enable(mut self, stencil_test_enable: bool) -> Self {
        self.stencil_test_enable = stencil_test_enable.into();
        self
    }
    #[inline]
    pub fn front(mut self, front: StencilOpState) -> Self {
        self.front = front;
        self
    }
    #[inline]
    pub fn back(mut self, back: StencilOpState) -> Self {
        self.back = back;
        self
    }
    #[inline]
    pub fn min_depth_bounds(mut self, min_depth_bounds: f32) -> Self {
        self.min_depth_bounds = min_depth_bounds;
        self
    }
    #[inline]
    pub fn max_depth_bounds(mut self, max_depth_bounds: f32) -> Self {
        self.max_depth_bounds = max_depth_bounds;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkGraphicsPipelineCreateInfo.html>"]
pub struct GraphicsPipelineCreateInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: PipelineCreateFlags,
    pub stage_count: u32,
    pub p_stages: *const PipelineShaderStageCreateInfo<'a>,
    pub p_vertex_input_state: *const PipelineVertexInputStateCreateInfo<'a>,
    pub p_input_assembly_state: *const PipelineInputAssemblyStateCreateInfo<'a>,
    pub p_tessellation_state: *const PipelineTessellationStateCreateInfo<'a>,
    pub p_viewport_state: *const PipelineViewportStateCreateInfo<'a>,
    pub p_rasterization_state: *const PipelineRasterizationStateCreateInfo<'a>,
    pub p_multisample_state: *const PipelineMultisampleStateCreateInfo<'a>,
    pub p_depth_stencil_state: *const PipelineDepthStencilStateCreateInfo<'a>,
    pub p_color_blend_state: *const PipelineColorBlendStateCreateInfo<'a>,
    pub p_dynamic_state: *const PipelineDynamicStateCreateInfo<'a>,
    pub layout: PipelineLayout,
    pub render_pass: RenderPass,
    pub subpass: u32,
    pub base_pipeline_handle: Pipeline,
    pub base_pipeline_index: i32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for GraphicsPipelineCreateInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: PipelineCreateFlags::default(),
            stage_count: u32::default(),
            p_stages: ::std::ptr::null(),
            p_vertex_input_state: ::std::ptr::null(),
            p_input_assembly_state: ::std::ptr::null(),
            p_tessellation_state: ::std::ptr::null(),
            p_viewport_state: ::std::ptr::null(),
            p_rasterization_state: ::std::ptr::null(),
            p_multisample_state: ::std::ptr::null(),
            p_depth_stencil_state: ::std::ptr::null(),
            p_color_blend_state: ::std::ptr::null(),
            p_dynamic_state: ::std::ptr::null(),
            layout: PipelineLayout::default(),
            render_pass: RenderPass::default(),
            subpass: u32::default(),
            base_pipeline_handle: Pipeline::default(),
            base_pipeline_index: i32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for GraphicsPipelineCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::GRAPHICS_PIPELINE_CREATE_INFO;
}
pub unsafe trait ExtendsGraphicsPipelineCreateInfo {}
impl<'a> GraphicsPipelineCreateInfo<'a> {
    #[inline]
    pub fn flags(mut self, flags: PipelineCreateFlags) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn stages(mut self, stages: &'a [PipelineShaderStageCreateInfo]) -> Self {
        self.stage_count = stages.len() as _;
        self.p_stages = stages.as_ptr();
        self
    }
    #[inline]
    pub fn vertex_input_state(
        mut self,
        vertex_input_state: &'a PipelineVertexInputStateCreateInfo<'a>,
    ) -> Self {
        self.p_vertex_input_state = vertex_input_state;
        self
    }
    #[inline]
    pub fn input_assembly_state(
        mut self,
        input_assembly_state: &'a PipelineInputAssemblyStateCreateInfo<'a>,
    ) -> Self {
        self.p_input_assembly_state = input_assembly_state;
        self
    }
    #[inline]
    pub fn tessellation_state(
        mut self,
        tessellation_state: &'a PipelineTessellationStateCreateInfo<'a>,
    ) -> Self {
        self.p_tessellation_state = tessellation_state;
        self
    }
    #[inline]
    pub fn viewport_state(
        mut self,
        viewport_state: &'a PipelineViewportStateCreateInfo<'a>,
    ) -> Self {
        self.p_viewport_state = viewport_state;
        self
    }
    #[inline]
    pub fn rasterization_state(
        mut self,
        rasterization_state: &'a PipelineRasterizationStateCreateInfo<'a>,
    ) -> Self {
        self.p_rasterization_state = rasterization_state;
        self
    }
    #[inline]
    pub fn multisample_state(
        mut self,
        multisample_state: &'a PipelineMultisampleStateCreateInfo<'a>,
    ) -> Self {
        self.p_multisample_state = multisample_state;
        self
    }
    #[inline]
    pub fn depth_stencil_state(
        mut self,
        depth_stencil_state: &'a PipelineDepthStencilStateCreateInfo<'a>,
    ) -> Self {
        self.p_depth_stencil_state = depth_stencil_state;
        self
    }
    #[inline]
    pub fn color_blend_state(
        mut self,
        color_blend_state: &'a PipelineColorBlendStateCreateInfo<'a>,
    ) -> Self {
        self.p_color_blend_state = color_blend_state;
        self
    }
    #[inline]
    pub fn dynamic_state(mut self, dynamic_state: &'a PipelineDynamicStateCreateInfo<'a>) -> Self {
        self.p_dynamic_state = dynamic_state;
        self
    }
    #[inline]
    pub fn layout(mut self, layout: PipelineLayout) -> Self {
        self.layout = layout;
        self
    }
    #[inline]
    pub fn render_pass(mut self, render_pass: RenderPass) -> Self {
        self.render_pass = render_pass;
        self
    }
    #[inline]
    pub fn subpass(mut self, subpass: u32) -> Self {
        self.subpass = subpass;
        self
    }
    #[inline]
    pub fn base_pipeline_handle(mut self, base_pipeline_handle: Pipeline) -> Self {
        self.base_pipeline_handle = base_pipeline_handle;
        self
    }
    #[inline]
    pub fn base_pipeline_index(mut self, base_pipeline_index: i32) -> Self {
        self.base_pipeline_index = base_pipeline_index;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `x.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsGraphicsPipelineCreateInfo>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.p_next as _;
            self.p_next = next_ptr;
        }
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineCacheCreateInfo.html>"]
pub struct PipelineCacheCreateInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: PipelineCacheCreateFlags,
    pub initial_data_size: usize,
    pub p_initial_data: *const c_void,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PipelineCacheCreateInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: PipelineCacheCreateFlags::default(),
            initial_data_size: usize::default(),
            p_initial_data: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PipelineCacheCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PIPELINE_CACHE_CREATE_INFO;
}
impl<'a> PipelineCacheCreateInfo<'a> {
    #[inline]
    pub fn flags(mut self, flags: PipelineCacheCreateFlags) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn initial_data(mut self, initial_data: &'a [u8]) -> Self {
        self.initial_data_size = initial_data.len();
        self.p_initial_data = initial_data.as_ptr() as *const c_void;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineCacheHeaderVersionOne.html>"]
pub struct PipelineCacheHeaderVersionOne {
    pub header_size: u32,
    pub header_version: PipelineCacheHeaderVersion,
    pub vendor_id: u32,
    pub device_id: u32,
    pub pipeline_cache_uuid: [u8; UUID_SIZE],
}
impl ::std::default::Default for PipelineCacheHeaderVersionOne {
    #[inline]
    fn default() -> Self {
        Self {
            header_size: u32::default(),
            header_version: PipelineCacheHeaderVersion::default(),
            vendor_id: u32::default(),
            device_id: u32::default(),
            pipeline_cache_uuid: unsafe { ::std::mem::zeroed() },
        }
    }
}
impl PipelineCacheHeaderVersionOne {
    #[inline]
    pub fn header_size(mut self, header_size: u32) -> Self {
        self.header_size = header_size;
        self
    }
    #[inline]
    pub fn header_version(mut self, header_version: PipelineCacheHeaderVersion) -> Self {
        self.header_version = header_version;
        self
    }
    #[inline]
    pub fn vendor_id(mut self, vendor_id: u32) -> Self {
        self.vendor_id = vendor_id;
        self
    }
    #[inline]
    pub fn device_id(mut self, device_id: u32) -> Self {
        self.device_id = device_id;
        self
    }
    #[inline]
    pub fn pipeline_cache_uuid(mut self, pipeline_cache_uuid: [u8; UUID_SIZE]) -> Self {
        self.pipeline_cache_uuid = pipeline_cache_uuid;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPushConstantRange.html>"]
pub struct PushConstantRange {
    pub stage_flags: ShaderStageFlags,
    pub offset: u32,
    pub size: u32,
}
impl PushConstantRange {
    #[inline]
    pub fn stage_flags(mut self, stage_flags: ShaderStageFlags) -> Self {
        self.stage_flags = stage_flags;
        self
    }
    #[inline]
    pub fn offset(mut self, offset: u32) -> Self {
        self.offset = offset;
        self
    }
    #[inline]
    pub fn size(mut self, size: u32) -> Self {
        self.size = size;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineLayoutCreateInfo.html>"]
pub struct PipelineLayoutCreateInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: PipelineLayoutCreateFlags,
    pub set_layout_count: u32,
    pub p_set_layouts: *const DescriptorSetLayout,
    pub push_constant_range_count: u32,
    pub p_push_constant_ranges: *const PushConstantRange,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PipelineLayoutCreateInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: PipelineLayoutCreateFlags::default(),
            set_layout_count: u32::default(),
            p_set_layouts: ::std::ptr::null(),
            push_constant_range_count: u32::default(),
            p_push_constant_ranges: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PipelineLayoutCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PIPELINE_LAYOUT_CREATE_INFO;
}
impl<'a> PipelineLayoutCreateInfo<'a> {
    #[inline]
    pub fn flags(mut self, flags: PipelineLayoutCreateFlags) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn set_layouts(mut self, set_layouts: &'a [DescriptorSetLayout]) -> Self {
        self.set_layout_count = set_layouts.len() as _;
        self.p_set_layouts = set_layouts.as_ptr();
        self
    }
    #[inline]
    pub fn push_constant_ranges(mut self, push_constant_ranges: &'a [PushConstantRange]) -> Self {
        self.push_constant_range_count = push_constant_ranges.len() as _;
        self.p_push_constant_ranges = push_constant_ranges.as_ptr();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSamplerCreateInfo.html>"]
pub struct SamplerCreateInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: SamplerCreateFlags,
    pub mag_filter: Filter,
    pub min_filter: Filter,
    pub mipmap_mode: SamplerMipmapMode,
    pub address_mode_u: SamplerAddressMode,
    pub address_mode_v: SamplerAddressMode,
    pub address_mode_w: SamplerAddressMode,
    pub mip_lod_bias: f32,
    pub anisotropy_enable: Bool32,
    pub max_anisotropy: f32,
    pub compare_enable: Bool32,
    pub compare_op: CompareOp,
    pub min_lod: f32,
    pub max_lod: f32,
    pub border_color: BorderColor,
    pub unnormalized_coordinates: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for SamplerCreateInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: SamplerCreateFlags::default(),
            mag_filter: Filter::default(),
            min_filter: Filter::default(),
            mipmap_mode: SamplerMipmapMode::default(),
            address_mode_u: SamplerAddressMode::default(),
            address_mode_v: SamplerAddressMode::default(),
            address_mode_w: SamplerAddressMode::default(),
            mip_lod_bias: f32::default(),
            anisotropy_enable: Bool32::default(),
            max_anisotropy: f32::default(),
            compare_enable: Bool32::default(),
            compare_op: CompareOp::default(),
            min_lod: f32::default(),
            max_lod: f32::default(),
            border_color: BorderColor::default(),
            unnormalized_coordinates: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for SamplerCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::SAMPLER_CREATE_INFO;
}
pub unsafe trait ExtendsSamplerCreateInfo {}
impl<'a> SamplerCreateInfo<'a> {
    #[inline]
    pub fn flags(mut self, flags: SamplerCreateFlags) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn mag_filter(mut self, mag_filter: Filter) -> Self {
        self.mag_filter = mag_filter;
        self
    }
    #[inline]
    pub fn min_filter(mut self, min_filter: Filter) -> Self {
        self.min_filter = min_filter;
        self
    }
    #[inline]
    pub fn mipmap_mode(mut self, mipmap_mode: SamplerMipmapMode) -> Self {
        self.mipmap_mode = mipmap_mode;
        self
    }
    #[inline]
    pub fn address_mode_u(mut self, address_mode_u: SamplerAddressMode) -> Self {
        self.address_mode_u = address_mode_u;
        self
    }
    #[inline]
    pub fn address_mode_v(mut self, address_mode_v: SamplerAddressMode) -> Self {
        self.address_mode_v = address_mode_v;
        self
    }
    #[inline]
    pub fn address_mode_w(mut self, address_mode_w: SamplerAddressMode) -> Self {
        self.address_mode_w = address_mode_w;
        self
    }
    #[inline]
    pub fn mip_lod_bias(mut self, mip_lod_bias: f32) -> Self {
        self.mip_lod_bias = mip_lod_bias;
        self
    }
    #[inline]
    pub fn anisotropy_enable(mut self, anisotropy_enable: bool) -> Self {
        self.anisotropy_enable = anisotropy_enable.into();
        self
    }
    #[inline]
    pub fn max_anisotropy(mut self, max_anisotropy: f32) -> Self {
        self.max_anisotropy = max_anisotropy;
        self
    }
    #[inline]
    pub fn compare_enable(mut self, compare_enable: bool) -> Self {
        self.compare_enable = compare_enable.into();
        self
    }
    #[inline]
    pub fn compare_op(mut self, compare_op: CompareOp) -> Self {
        self.compare_op = compare_op;
        self
    }
    #[inline]
    pub fn min_lod(mut self, min_lod: f32) -> Self {
        self.min_lod = min_lod;
        self
    }
    #[inline]
    pub fn max_lod(mut self, max_lod: f32) -> Self {
        self.max_lod = max_lod;
        self
    }
    #[inline]
    pub fn border_color(mut self, border_color: BorderColor) -> Self {
        self.border_color = border_color;
        self
    }
    #[inline]
    pub fn unnormalized_coordinates(mut self, unnormalized_coordinates: bool) -> Self {
        self.unnormalized_coordinates = unnormalized_coordinates.into();
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `x.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsSamplerCreateInfo>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.p_next as _;
            self.p_next = next_ptr;
        }
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandPoolCreateInfo.html>"]
pub struct CommandPoolCreateInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: CommandPoolCreateFlags,
    pub queue_family_index: u32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for CommandPoolCreateInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: CommandPoolCreateFlags::default(),
            queue_family_index: u32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for CommandPoolCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::COMMAND_POOL_CREATE_INFO;
}
impl<'a> CommandPoolCreateInfo<'a> {
    #[inline]
    pub fn flags(mut self, flags: CommandPoolCreateFlags) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn queue_family_index(mut self, queue_family_index: u32) -> Self {
        self.queue_family_index = queue_family_index;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandBufferAllocateInfo.html>"]
pub struct CommandBufferAllocateInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub command_pool: CommandPool,
    pub level: CommandBufferLevel,
    pub command_buffer_count: u32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for CommandBufferAllocateInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            command_pool: CommandPool::default(),
            level: CommandBufferLevel::default(),
            command_buffer_count: u32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for CommandBufferAllocateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::COMMAND_BUFFER_ALLOCATE_INFO;
}
impl<'a> CommandBufferAllocateInfo<'a> {
    #[inline]
    pub fn command_pool(mut self, command_pool: CommandPool) -> Self {
        self.command_pool = command_pool;
        self
    }
    #[inline]
    pub fn level(mut self, level: CommandBufferLevel) -> Self {
        self.level = level;
        self
    }
    #[inline]
    pub fn command_buffer_count(mut self, command_buffer_count: u32) -> Self {
        self.command_buffer_count = command_buffer_count;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandBufferInheritanceInfo.html>"]
pub struct CommandBufferInheritanceInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub render_pass: RenderPass,
    pub subpass: u32,
    pub framebuffer: Framebuffer,
    pub occlusion_query_enable: Bool32,
    pub query_flags: QueryControlFlags,
    pub pipeline_statistics: QueryPipelineStatisticFlags,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for CommandBufferInheritanceInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            render_pass: RenderPass::default(),
            subpass: u32::default(),
            framebuffer: Framebuffer::default(),
            occlusion_query_enable: Bool32::default(),
            query_flags: QueryControlFlags::default(),
            pipeline_statistics: QueryPipelineStatisticFlags::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for CommandBufferInheritanceInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::COMMAND_BUFFER_INHERITANCE_INFO;
}
pub unsafe trait ExtendsCommandBufferInheritanceInfo {}
impl<'a> CommandBufferInheritanceInfo<'a> {
    #[inline]
    pub fn render_pass(mut self, render_pass: RenderPass) -> Self {
        self.render_pass = render_pass;
        self
    }
    #[inline]
    pub fn subpass(mut self, subpass: u32) -> Self {
        self.subpass = subpass;
        self
    }
    #[inline]
    pub fn framebuffer(mut self, framebuffer: Framebuffer) -> Self {
        self.framebuffer = framebuffer;
        self
    }
    #[inline]
    pub fn occlusion_query_enable(mut self, occlusion_query_enable: bool) -> Self {
        self.occlusion_query_enable = occlusion_query_enable.into();
        self
    }
    #[inline]
    pub fn query_flags(mut self, query_flags: QueryControlFlags) -> Self {
        self.query_flags = query_flags;
        self
    }
    #[inline]
    pub fn pipeline_statistics(mut self, pipeline_statistics: QueryPipelineStatisticFlags) -> Self {
        self.pipeline_statistics = pipeline_statistics;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `x.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsCommandBufferInheritanceInfo>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.p_next as _;
            self.p_next = next_ptr;
        }
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandBufferBeginInfo.html>"]
pub struct CommandBufferBeginInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: CommandBufferUsageFlags,
    pub p_inheritance_info: *const CommandBufferInheritanceInfo<'a>,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for CommandBufferBeginInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: CommandBufferUsageFlags::default(),
            p_inheritance_info: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for CommandBufferBeginInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::COMMAND_BUFFER_BEGIN_INFO;
}
pub unsafe trait ExtendsCommandBufferBeginInfo {}
impl<'a> CommandBufferBeginInfo<'a> {
    #[inline]
    pub fn flags(mut self, flags: CommandBufferUsageFlags) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn inheritance_info(
        mut self,
        inheritance_info: &'a CommandBufferInheritanceInfo<'a>,
    ) -> Self {
        self.p_inheritance_info = inheritance_info;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `x.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsCommandBufferBeginInfo>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.p_next as _;
            self.p_next = next_ptr;
        }
        self
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderPassBeginInfo.html>"]
pub struct RenderPassBeginInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub render_pass: RenderPass,
    pub framebuffer: Framebuffer,
    pub render_area: Rect2D,
    pub clear_value_count: u32,
    pub p_clear_values: *const ClearValue,
    pub _marker: PhantomData<&'a ()>,
}
#[cfg(feature = "debug")]
impl fmt::Debug for RenderPassBeginInfo<'_> {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("RenderPassBeginInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("render_pass", &self.render_pass)
            .field("framebuffer", &self.framebuffer)
            .field("render_area", &self.render_area)
            .field("clear_value_count", &self.clear_value_count)
            .field("p_clear_values", &"union")
            .finish()
    }
}
impl ::std::default::Default for RenderPassBeginInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            render_pass: RenderPass::default(),
            framebuffer: Framebuffer::default(),
            render_area: Rect2D::default(),
            clear_value_count: u32::default(),
            p_clear_values: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for RenderPassBeginInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::RENDER_PASS_BEGIN_INFO;
}
pub unsafe trait ExtendsRenderPassBeginInfo {}
impl<'a> RenderPassBeginInfo<'a> {
    #[inline]
    pub fn render_pass(mut self, render_pass: RenderPass) -> Self {
        self.render_pass = render_pass;
        self
    }
    #[inline]
    pub fn framebuffer(mut self, framebuffer: Framebuffer) -> Self {
        self.framebuffer = framebuffer;
        self
    }
    #[inline]
    pub fn render_area(mut self, render_area: Rect2D) -> Self {
        self.render_area = render_area;
        self
    }
    #[inline]
    pub fn clear_values(mut self, clear_values: &'a [ClearValue]) -> Self {
        self.clear_value_count = clear_values.len() as _;
        self.p_clear_values = clear_values.as_ptr();
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `x.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsRenderPassBeginInfo>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.p_next as _;
            self.p_next = next_ptr;
        }
        self
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkClearColorValue.html>"]
pub union ClearColorValue {
    pub float32: [f32; 4],
    pub int32: [i32; 4],
    pub uint32: [u32; 4],
}
impl ::std::default::Default for ClearColorValue {
    #[inline]
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkClearDepthStencilValue.html>"]
pub struct ClearDepthStencilValue {
    pub depth: f32,
    pub stencil: u32,
}
impl ClearDepthStencilValue {
    #[inline]
    pub fn depth(mut self, depth: f32) -> Self {
        self.depth = depth;
        self
    }
    #[inline]
    pub fn stencil(mut self, stencil: u32) -> Self {
        self.stencil = stencil;
        self
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkClearValue.html>"]
pub union ClearValue {
    pub color: ClearColorValue,
    pub depth_stencil: ClearDepthStencilValue,
}
impl ::std::default::Default for ClearValue {
    #[inline]
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkClearAttachment.html>"]
pub struct ClearAttachment {
    pub aspect_mask: ImageAspectFlags,
    pub color_attachment: u32,
    pub clear_value: ClearValue,
}
#[cfg(feature = "debug")]
impl fmt::Debug for ClearAttachment {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ClearAttachment")
            .field("aspect_mask", &self.aspect_mask)
            .field("color_attachment", &self.color_attachment)
            .field("clear_value", &"union")
            .finish()
    }
}
impl ClearAttachment {
    #[inline]
    pub fn aspect_mask(mut self, aspect_mask: ImageAspectFlags) -> Self {
        self.aspect_mask = aspect_mask;
        self
    }
    #[inline]
    pub fn color_attachment(mut self, color_attachment: u32) -> Self {
        self.color_attachment = color_attachment;
        self
    }
    #[inline]
    pub fn clear_value(mut self, clear_value: ClearValue) -> Self {
        self.clear_value = clear_value;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAttachmentDescription.html>"]
pub struct AttachmentDescription {
    pub flags: AttachmentDescriptionFlags,
    pub format: Format,
    pub samples: SampleCountFlags,
    pub load_op: AttachmentLoadOp,
    pub store_op: AttachmentStoreOp,
    pub stencil_load_op: AttachmentLoadOp,
    pub stencil_store_op: AttachmentStoreOp,
    pub initial_layout: ImageLayout,
    pub final_layout: ImageLayout,
}
impl AttachmentDescription {
    #[inline]
    pub fn flags(mut self, flags: AttachmentDescriptionFlags) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn format(mut self, format: Format) -> Self {
        self.format = format;
        self
    }
    #[inline]
    pub fn samples(mut self, samples: SampleCountFlags) -> Self {
        self.samples = samples;
        self
    }
    #[inline]
    pub fn load_op(mut self, load_op: AttachmentLoadOp) -> Self {
        self.load_op = load_op;
        self
    }
    #[inline]
    pub fn store_op(mut self, store_op: AttachmentStoreOp) -> Self {
        self.store_op = store_op;
        self
    }
    #[inline]
    pub fn stencil_load_op(mut self, stencil_load_op: AttachmentLoadOp) -> Self {
        self.stencil_load_op = stencil_load_op;
        self
    }
    #[inline]
    pub fn stencil_store_op(mut self, stencil_store_op: AttachmentStoreOp) -> Self {
        self.stencil_store_op = stencil_store_op;
        self
    }
    #[inline]
    pub fn initial_layout(mut self, initial_layout: ImageLayout) -> Self {
        self.initial_layout = initial_layout;
        self
    }
    #[inline]
    pub fn final_layout(mut self, final_layout: ImageLayout) -> Self {
        self.final_layout = final_layout;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAttachmentReference.html>"]
pub struct AttachmentReference {
    pub attachment: u32,
    pub layout: ImageLayout,
}
impl AttachmentReference {
    #[inline]
    pub fn attachment(mut self, attachment: u32) -> Self {
        self.attachment = attachment;
        self
    }
    #[inline]
    pub fn layout(mut self, layout: ImageLayout) -> Self {
        self.layout = layout;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSubpassDescription.html>"]
pub struct SubpassDescription<'a> {
    pub flags: SubpassDescriptionFlags,
    pub pipeline_bind_point: PipelineBindPoint,
    pub input_attachment_count: u32,
    pub p_input_attachments: *const AttachmentReference,
    pub color_attachment_count: u32,
    pub p_color_attachments: *const AttachmentReference,
    pub p_resolve_attachments: *const AttachmentReference,
    pub p_depth_stencil_attachment: *const AttachmentReference,
    pub preserve_attachment_count: u32,
    pub p_preserve_attachments: *const u32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for SubpassDescription<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            flags: SubpassDescriptionFlags::default(),
            pipeline_bind_point: PipelineBindPoint::default(),
            input_attachment_count: u32::default(),
            p_input_attachments: ::std::ptr::null(),
            color_attachment_count: u32::default(),
            p_color_attachments: ::std::ptr::null(),
            p_resolve_attachments: ::std::ptr::null(),
            p_depth_stencil_attachment: ::std::ptr::null(),
            preserve_attachment_count: u32::default(),
            p_preserve_attachments: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
impl<'a> SubpassDescription<'a> {
    #[inline]
    pub fn flags(mut self, flags: SubpassDescriptionFlags) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn pipeline_bind_point(mut self, pipeline_bind_point: PipelineBindPoint) -> Self {
        self.pipeline_bind_point = pipeline_bind_point;
        self
    }
    #[inline]
    pub fn input_attachments(mut self, input_attachments: &'a [AttachmentReference]) -> Self {
        self.input_attachment_count = input_attachments.len() as _;
        self.p_input_attachments = input_attachments.as_ptr();
        self
    }
    #[inline]
    pub fn color_attachments(mut self, color_attachments: &'a [AttachmentReference]) -> Self {
        self.color_attachment_count = color_attachments.len() as _;
        self.p_color_attachments = color_attachments.as_ptr();
        self
    }
    #[inline]
    pub fn resolve_attachments(mut self, resolve_attachments: &'a [AttachmentReference]) -> Self {
        self.color_attachment_count = resolve_attachments.len() as _;
        self.p_resolve_attachments = resolve_attachments.as_ptr();
        self
    }
    #[inline]
    pub fn depth_stencil_attachment(
        mut self,
        depth_stencil_attachment: &'a AttachmentReference,
    ) -> Self {
        self.p_depth_stencil_attachment = depth_stencil_attachment;
        self
    }
    #[inline]
    pub fn preserve_attachments(mut self, preserve_attachments: &'a [u32]) -> Self {
        self.preserve_attachment_count = preserve_attachments.len() as _;
        self.p_preserve_attachments = preserve_attachments.as_ptr();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSubpassDependency.html>"]
pub struct SubpassDependency {
    pub src_subpass: u32,
    pub dst_subpass: u32,
    pub src_stage_mask: PipelineStageFlags,
    pub dst_stage_mask: PipelineStageFlags,
    pub src_access_mask: AccessFlags,
    pub dst_access_mask: AccessFlags,
    pub dependency_flags: DependencyFlags,
}
impl SubpassDependency {
    #[inline]
    pub fn src_subpass(mut self, src_subpass: u32) -> Self {
        self.src_subpass = src_subpass;
        self
    }
    #[inline]
    pub fn dst_subpass(mut self, dst_subpass: u32) -> Self {
        self.dst_subpass = dst_subpass;
        self
    }
    #[inline]
    pub fn src_stage_mask(mut self, src_stage_mask: PipelineStageFlags) -> Self {
        self.src_stage_mask = src_stage_mask;
        self
    }
    #[inline]
    pub fn dst_stage_mask(mut self, dst_stage_mask: PipelineStageFlags) -> Self {
        self.dst_stage_mask = dst_stage_mask;
        self
    }
    #[inline]
    pub fn src_access_mask(mut self, src_access_mask: AccessFlags) -> Self {
        self.src_access_mask = src_access_mask;
        self
    }
    #[inline]
    pub fn dst_access_mask(mut self, dst_access_mask: AccessFlags) -> Self {
        self.dst_access_mask = dst_access_mask;
        self
    }
    #[inline]
    pub fn dependency_flags(mut self, dependency_flags: DependencyFlags) -> Self {
        self.dependency_flags = dependency_flags;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderPassCreateInfo.html>"]
pub struct RenderPassCreateInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: RenderPassCreateFlags,
    pub attachment_count: u32,
    pub p_attachments: *const AttachmentDescription,
    pub subpass_count: u32,
    pub p_subpasses: *const SubpassDescription<'a>,
    pub dependency_count: u32,
    pub p_dependencies: *const SubpassDependency,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for RenderPassCreateInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: RenderPassCreateFlags::default(),
            attachment_count: u32::default(),
            p_attachments: ::std::ptr::null(),
            subpass_count: u32::default(),
            p_subpasses: ::std::ptr::null(),
            dependency_count: u32::default(),
            p_dependencies: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for RenderPassCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::RENDER_PASS_CREATE_INFO;
}
pub unsafe trait ExtendsRenderPassCreateInfo {}
impl<'a> RenderPassCreateInfo<'a> {
    #[inline]
    pub fn flags(mut self, flags: RenderPassCreateFlags) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn attachments(mut self, attachments: &'a [AttachmentDescription]) -> Self {
        self.attachment_count = attachments.len() as _;
        self.p_attachments = attachments.as_ptr();
        self
    }
    #[inline]
    pub fn subpasses(mut self, subpasses: &'a [SubpassDescription]) -> Self {
        self.subpass_count = subpasses.len() as _;
        self.p_subpasses = subpasses.as_ptr();
        self
    }
    #[inline]
    pub fn dependencies(mut self, dependencies: &'a [SubpassDependency]) -> Self {
        self.dependency_count = dependencies.len() as _;
        self.p_dependencies = dependencies.as_ptr();
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `x.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsRenderPassCreateInfo>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.p_next as _;
            self.p_next = next_ptr;
        }
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkEventCreateInfo.html>"]
pub struct EventCreateInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: EventCreateFlags,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for EventCreateInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: EventCreateFlags::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for EventCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::EVENT_CREATE_INFO;
}
pub unsafe trait ExtendsEventCreateInfo {}
impl<'a> EventCreateInfo<'a> {
    #[inline]
    pub fn flags(mut self, flags: EventCreateFlags) -> Self {
        self.flags = flags;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `x.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsEventCreateInfo>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.p_next as _;
            self.p_next = next_ptr;
        }
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFenceCreateInfo.html>"]
pub struct FenceCreateInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: FenceCreateFlags,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for FenceCreateInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: FenceCreateFlags::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for FenceCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::FENCE_CREATE_INFO;
}
pub unsafe trait ExtendsFenceCreateInfo {}
impl<'a> FenceCreateInfo<'a> {
    #[inline]
    pub fn flags(mut self, flags: FenceCreateFlags) -> Self {
        self.flags = flags;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `x.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsFenceCreateInfo>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.p_next as _;
            self.p_next = next_ptr;
        }
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFeatures.html>"]
pub struct PhysicalDeviceFeatures {
    pub robust_buffer_access: Bool32,
    pub full_draw_index_uint32: Bool32,
    pub image_cube_array: Bool32,
    pub independent_blend: Bool32,
    pub geometry_shader: Bool32,
    pub tessellation_shader: Bool32,
    pub sample_rate_shading: Bool32,
    pub dual_src_blend: Bool32,
    pub logic_op: Bool32,
    pub multi_draw_indirect: Bool32,
    pub draw_indirect_first_instance: Bool32,
    pub depth_clamp: Bool32,
    pub depth_bias_clamp: Bool32,
    pub fill_mode_non_solid: Bool32,
    pub depth_bounds: Bool32,
    pub wide_lines: Bool32,
    pub large_points: Bool32,
    pub alpha_to_one: Bool32,
    pub multi_viewport: Bool32,
    pub sampler_anisotropy: Bool32,
    pub texture_compression_etc2: Bool32,
    pub texture_compression_astc_ldr: Bool32,
    pub texture_compression_bc: Bool32,
    pub occlusion_query_precise: Bool32,
    pub pipeline_statistics_query: Bool32,
    pub vertex_pipeline_stores_and_atomics: Bool32,
    pub fragment_stores_and_atomics: Bool32,
    pub shader_tessellation_and_geometry_point_size: Bool32,
    pub shader_image_gather_extended: Bool32,
    pub shader_storage_image_extended_formats: Bool32,
    pub shader_storage_image_multisample: Bool32,
    pub shader_storage_image_read_without_format: Bool32,
    pub shader_storage_image_write_without_format: Bool32,
    pub shader_uniform_buffer_array_dynamic_indexing: Bool32,
    pub shader_sampled_image_array_dynamic_indexing: Bool32,
    pub shader_storage_buffer_array_dynamic_indexing: Bool32,
    pub shader_storage_image_array_dynamic_indexing: Bool32,
    pub shader_clip_distance: Bool32,
    pub shader_cull_distance: Bool32,
    pub shader_float64: Bool32,
    pub shader_int64: Bool32,
    pub shader_int16: Bool32,
    pub shader_resource_residency: Bool32,
    pub shader_resource_min_lod: Bool32,
    pub sparse_binding: Bool32,
    pub sparse_residency_buffer: Bool32,
    pub sparse_residency_image2_d: Bool32,
    pub sparse_residency_image3_d: Bool32,
    pub sparse_residency2_samples: Bool32,
    pub sparse_residency4_samples: Bool32,
    pub sparse_residency8_samples: Bool32,
    pub sparse_residency16_samples: Bool32,
    pub sparse_residency_aliased: Bool32,
    pub variable_multisample_rate: Bool32,
    pub inherited_queries: Bool32,
}
impl PhysicalDeviceFeatures {
    #[inline]
    pub fn robust_buffer_access(mut self, robust_buffer_access: bool) -> Self {
        self.robust_buffer_access = robust_buffer_access.into();
        self
    }
    #[inline]
    pub fn full_draw_index_uint32(mut self, full_draw_index_uint32: bool) -> Self {
        self.full_draw_index_uint32 = full_draw_index_uint32.into();
        self
    }
    #[inline]
    pub fn image_cube_array(mut self, image_cube_array: bool) -> Self {
        self.image_cube_array = image_cube_array.into();
        self
    }
    #[inline]
    pub fn independent_blend(mut self, independent_blend: bool) -> Self {
        self.independent_blend = independent_blend.into();
        self
    }
    #[inline]
    pub fn geometry_shader(mut self, geometry_shader: bool) -> Self {
        self.geometry_shader = geometry_shader.into();
        self
    }
    #[inline]
    pub fn tessellation_shader(mut self, tessellation_shader: bool) -> Self {
        self.tessellation_shader = tessellation_shader.into();
        self
    }
    #[inline]
    pub fn sample_rate_shading(mut self, sample_rate_shading: bool) -> Self {
        self.sample_rate_shading = sample_rate_shading.into();
        self
    }
    #[inline]
    pub fn dual_src_blend(mut self, dual_src_blend: bool) -> Self {
        self.dual_src_blend = dual_src_blend.into();
        self
    }
    #[inline]
    pub fn logic_op(mut self, logic_op: bool) -> Self {
        self.logic_op = logic_op.into();
        self
    }
    #[inline]
    pub fn multi_draw_indirect(mut self, multi_draw_indirect: bool) -> Self {
        self.multi_draw_indirect = multi_draw_indirect.into();
        self
    }
    #[inline]
    pub fn draw_indirect_first_instance(mut self, draw_indirect_first_instance: bool) -> Self {
        self.draw_indirect_first_instance = draw_indirect_first_instance.into();
        self
    }
    #[inline]
    pub fn depth_clamp(mut self, depth_clamp: bool) -> Self {
        self.depth_clamp = depth_clamp.into();
        self
    }
    #[inline]
    pub fn depth_bias_clamp(mut self, depth_bias_clamp: bool) -> Self {
        self.depth_bias_clamp = depth_bias_clamp.into();
        self
    }
    #[inline]
    pub fn fill_mode_non_solid(mut self, fill_mode_non_solid: bool) -> Self {
        self.fill_mode_non_solid = fill_mode_non_solid.into();
        self
    }
    #[inline]
    pub fn depth_bounds(mut self, depth_bounds: bool) -> Self {
        self.depth_bounds = depth_bounds.into();
        self
    }
    #[inline]
    pub fn wide_lines(mut self, wide_lines: bool) -> Self {
        self.wide_lines = wide_lines.into();
        self
    }
    #[inline]
    pub fn large_points(mut self, large_points: bool) -> Self {
        self.large_points = large_points.into();
        self
    }
    #[inline]
    pub fn alpha_to_one(mut self, alpha_to_one: bool) -> Self {
        self.alpha_to_one = alpha_to_one.into();
        self
    }
    #[inline]
    pub fn multi_viewport(mut self, multi_viewport: bool) -> Self {
        self.multi_viewport = multi_viewport.into();
        self
    }
    #[inline]
    pub fn sampler_anisotropy(mut self, sampler_anisotropy: bool) -> Self {
        self.sampler_anisotropy = sampler_anisotropy.into();
        self
    }
    #[inline]
    pub fn texture_compression_etc2(mut self, texture_compression_etc2: bool) -> Self {
        self.texture_compression_etc2 = texture_compression_etc2.into();
        self
    }
    #[inline]
    pub fn texture_compression_astc_ldr(mut self, texture_compression_astc_ldr: bool) -> Self {
        self.texture_compression_astc_ldr = texture_compression_astc_ldr.into();
        self
    }
    #[inline]
    pub fn texture_compression_bc(mut self, texture_compression_bc: bool) -> Self {
        self.texture_compression_bc = texture_compression_bc.into();
        self
    }
    #[inline]
    pub fn occlusion_query_precise(mut self, occlusion_query_precise: bool) -> Self {
        self.occlusion_query_precise = occlusion_query_precise.into();
        self
    }
    #[inline]
    pub fn pipeline_statistics_query(mut self, pipeline_statistics_query: bool) -> Self {
        self.pipeline_statistics_query = pipeline_statistics_query.into();
        self
    }
    #[inline]
    pub fn vertex_pipeline_stores_and_atomics(
        mut self,
        vertex_pipeline_stores_and_atomics: bool,
    ) -> Self {
        self.vertex_pipeline_stores_and_atomics = vertex_pipeline_stores_and_atomics.into();
        self
    }
    #[inline]
    pub fn fragment_stores_and_atomics(mut self, fragment_stores_and_atomics: bool) -> Self {
        self.fragment_stores_and_atomics = fragment_stores_and_atomics.into();
        self
    }
    #[inline]
    pub fn shader_tessellation_and_geometry_point_size(
        mut self,
        shader_tessellation_and_geometry_point_size: bool,
    ) -> Self {
        self.shader_tessellation_and_geometry_point_size =
            shader_tessellation_and_geometry_point_size.into();
        self
    }
    #[inline]
    pub fn shader_image_gather_extended(mut self, shader_image_gather_extended: bool) -> Self {
        self.shader_image_gather_extended = shader_image_gather_extended.into();
        self
    }
    #[inline]
    pub fn shader_storage_image_extended_formats(
        mut self,
        shader_storage_image_extended_formats: bool,
    ) -> Self {
        self.shader_storage_image_extended_formats = shader_storage_image_extended_formats.into();
        self
    }
    #[inline]
    pub fn shader_storage_image_multisample(
        mut self,
        shader_storage_image_multisample: bool,
    ) -> Self {
        self.shader_storage_image_multisample = shader_storage_image_multisample.into();
        self
    }
    #[inline]
    pub fn shader_storage_image_read_without_format(
        mut self,
        shader_storage_image_read_without_format: bool,
    ) -> Self {
        self.shader_storage_image_read_without_format =
            shader_storage_image_read_without_format.into();
        self
    }
    #[inline]
    pub fn shader_storage_image_write_without_format(
        mut self,
        shader_storage_image_write_without_format: bool,
    ) -> Self {
        self.shader_storage_image_write_without_format =
            shader_storage_image_write_without_format.into();
        self
    }
    #[inline]
    pub fn shader_uniform_buffer_array_dynamic_indexing(
        mut self,
        shader_uniform_buffer_array_dynamic_indexing: bool,
    ) -> Self {
        self.shader_uniform_buffer_array_dynamic_indexing =
            shader_uniform_buffer_array_dynamic_indexing.into();
        self
    }
    #[inline]
    pub fn shader_sampled_image_array_dynamic_indexing(
        mut self,
        shader_sampled_image_array_dynamic_indexing: bool,
    ) -> Self {
        self.shader_sampled_image_array_dynamic_indexing =
            shader_sampled_image_array_dynamic_indexing.into();
        self
    }
    #[inline]
    pub fn shader_storage_buffer_array_dynamic_indexing(
        mut self,
        shader_storage_buffer_array_dynamic_indexing: bool,
    ) -> Self {
        self.shader_storage_buffer_array_dynamic_indexing =
            shader_storage_buffer_array_dynamic_indexing.into();
        self
    }
    #[inline]
    pub fn shader_storage_image_array_dynamic_indexing(
        mut self,
        shader_storage_image_array_dynamic_indexing: bool,
    ) -> Self {
        self.shader_storage_image_array_dynamic_indexing =
            shader_storage_image_array_dynamic_indexing.into();
        self
    }
    #[inline]
    pub fn shader_clip_distance(mut self, shader_clip_distance: bool) -> Self {
        self.shader_clip_distance = shader_clip_distance.into();
        self
    }
    #[inline]
    pub fn shader_cull_distance(mut self, shader_cull_distance: bool) -> Self {
        self.shader_cull_distance = shader_cull_distance.into();
        self
    }
    #[inline]
    pub fn shader_float64(mut self, shader_float64: bool) -> Self {
        self.shader_float64 = shader_float64.into();
        self
    }
    #[inline]
    pub fn shader_int64(mut self, shader_int64: bool) -> Self {
        self.shader_int64 = shader_int64.into();
        self
    }
    #[inline]
    pub fn shader_int16(mut self, shader_int16: bool) -> Self {
        self.shader_int16 = shader_int16.into();
        self
    }
    #[inline]
    pub fn shader_resource_residency(mut self, shader_resource_residency: bool) -> Self {
        self.shader_resource_residency = shader_resource_residency.into();
        self
    }
    #[inline]
    pub fn shader_resource_min_lod(mut self, shader_resource_min_lod: bool) -> Self {
        self.shader_resource_min_lod = shader_resource_min_lod.into();
        self
    }
    #[inline]
    pub fn sparse_binding(mut self, sparse_binding: bool) -> Self {
        self.sparse_binding = sparse_binding.into();
        self
    }
    #[inline]
    pub fn sparse_residency_buffer(mut self, sparse_residency_buffer: bool) -> Self {
        self.sparse_residency_buffer = sparse_residency_buffer.into();
        self
    }
    #[inline]
    pub fn sparse_residency_image2_d(mut self, sparse_residency_image2_d: bool) -> Self {
        self.sparse_residency_image2_d = sparse_residency_image2_d.into();
        self
    }
    #[inline]
    pub fn sparse_residency_image3_d(mut self, sparse_residency_image3_d: bool) -> Self {
        self.sparse_residency_image3_d = sparse_residency_image3_d.into();
        self
    }
    #[inline]
    pub fn sparse_residency2_samples(mut self, sparse_residency2_samples: bool) -> Self {
        self.sparse_residency2_samples = sparse_residency2_samples.into();
        self
    }
    #[inline]
    pub fn sparse_residency4_samples(mut self, sparse_residency4_samples: bool) -> Self {
        self.sparse_residency4_samples = sparse_residency4_samples.into();
        self
    }
    #[inline]
    pub fn sparse_residency8_samples(mut self, sparse_residency8_samples: bool) -> Self {
        self.sparse_residency8_samples = sparse_residency8_samples.into();
        self
    }
    #[inline]
    pub fn sparse_residency16_samples(mut self, sparse_residency16_samples: bool) -> Self {
        self.sparse_residency16_samples = sparse_residency16_samples.into();
        self
    }
    #[inline]
    pub fn sparse_residency_aliased(mut self, sparse_residency_aliased: bool) -> Self {
        self.sparse_residency_aliased = sparse_residency_aliased.into();
        self
    }
    #[inline]
    pub fn variable_multisample_rate(mut self, variable_multisample_rate: bool) -> Self {
        self.variable_multisample_rate = variable_multisample_rate.into();
        self
    }
    #[inline]
    pub fn inherited_queries(mut self, inherited_queries: bool) -> Self {
        self.inherited_queries = inherited_queries.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceSparseProperties.html>"]
pub struct PhysicalDeviceSparseProperties {
    pub residency_standard2_d_block_shape: Bool32,
    pub residency_standard2_d_multisample_block_shape: Bool32,
    pub residency_standard3_d_block_shape: Bool32,
    pub residency_aligned_mip_size: Bool32,
    pub residency_non_resident_strict: Bool32,
}
impl PhysicalDeviceSparseProperties {
    #[inline]
    pub fn residency_standard2_d_block_shape(
        mut self,
        residency_standard2_d_block_shape: bool,
    ) -> Self {
        self.residency_standard2_d_block_shape = residency_standard2_d_block_shape.into();
        self
    }
    #[inline]
    pub fn residency_standard2_d_multisample_block_shape(
        mut self,
        residency_standard2_d_multisample_block_shape: bool,
    ) -> Self {
        self.residency_standard2_d_multisample_block_shape =
            residency_standard2_d_multisample_block_shape.into();
        self
    }
    #[inline]
    pub fn residency_standard3_d_block_shape(
        mut self,
        residency_standard3_d_block_shape: bool,
    ) -> Self {
        self.residency_standard3_d_block_shape = residency_standard3_d_block_shape.into();
        self
    }
    #[inline]
    pub fn residency_aligned_mip_size(mut self, residency_aligned_mip_size: bool) -> Self {
        self.residency_aligned_mip_size = residency_aligned_mip_size.into();
        self
    }
    #[inline]
    pub fn residency_non_resident_strict(mut self, residency_non_resident_strict: bool) -> Self {
        self.residency_non_resident_strict = residency_non_resident_strict.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceLimits.html>"]
pub struct PhysicalDeviceLimits {
    pub max_image_dimension1_d: u32,
    pub max_image_dimension2_d: u32,
    pub max_image_dimension3_d: u32,
    pub max_image_dimension_cube: u32,
    pub max_image_array_layers: u32,
    pub max_texel_buffer_elements: u32,
    pub max_uniform_buffer_range: u32,
    pub max_storage_buffer_range: u32,
    pub max_push_constants_size: u32,
    pub max_memory_allocation_count: u32,
    pub max_sampler_allocation_count: u32,
    pub buffer_image_granularity: DeviceSize,
    pub sparse_address_space_size: DeviceSize,
    pub max_bound_descriptor_sets: u32,
    pub max_per_stage_descriptor_samplers: u32,
    pub max_per_stage_descriptor_uniform_buffers: u32,
    pub max_per_stage_descriptor_storage_buffers: u32,
    pub max_per_stage_descriptor_sampled_images: u32,
    pub max_per_stage_descriptor_storage_images: u32,
    pub max_per_stage_descriptor_input_attachments: u32,
    pub max_per_stage_resources: u32,
    pub max_descriptor_set_samplers: u32,
    pub max_descriptor_set_uniform_buffers: u32,
    pub max_descriptor_set_uniform_buffers_dynamic: u32,
    pub max_descriptor_set_storage_buffers: u32,
    pub max_descriptor_set_storage_buffers_dynamic: u32,
    pub max_descriptor_set_sampled_images: u32,
    pub max_descriptor_set_storage_images: u32,
    pub max_descriptor_set_input_attachments: u32,
    pub max_vertex_input_attributes: u32,
    pub max_vertex_input_bindings: u32,
    pub max_vertex_input_attribute_offset: u32,
    pub max_vertex_input_binding_stride: u32,
    pub max_vertex_output_components: u32,
    pub max_tessellation_generation_level: u32,
    pub max_tessellation_patch_size: u32,
    pub max_tessellation_control_per_vertex_input_components: u32,
    pub max_tessellation_control_per_vertex_output_components: u32,
    pub max_tessellation_control_per_patch_output_components: u32,
    pub max_tessellation_control_total_output_components: u32,
    pub max_tessellation_evaluation_input_components: u32,
    pub max_tessellation_evaluation_output_components: u32,
    pub max_geometry_shader_invocations: u32,
    pub max_geometry_input_components: u32,
    pub max_geometry_output_components: u32,
    pub max_geometry_output_vertices: u32,
    pub max_geometry_total_output_components: u32,
    pub max_fragment_input_components: u32,
    pub max_fragment_output_attachments: u32,
    pub max_fragment_dual_src_attachments: u32,
    pub max_fragment_combined_output_resources: u32,
    pub max_compute_shared_memory_size: u32,
    pub max_compute_work_group_count: [u32; 3],
    pub max_compute_work_group_invocations: u32,
    pub max_compute_work_group_size: [u32; 3],
    pub sub_pixel_precision_bits: u32,
    pub sub_texel_precision_bits: u32,
    pub mipmap_precision_bits: u32,
    pub max_draw_indexed_index_value: u32,
    pub max_draw_indirect_count: u32,
    pub max_sampler_lod_bias: f32,
    pub max_sampler_anisotropy: f32,
    pub max_viewports: u32,
    pub max_viewport_dimensions: [u32; 2],
    pub viewport_bounds_range: [f32; 2],
    pub viewport_sub_pixel_bits: u32,
    pub min_memory_map_alignment: usize,
    pub min_texel_buffer_offset_alignment: DeviceSize,
    pub min_uniform_buffer_offset_alignment: DeviceSize,
    pub min_storage_buffer_offset_alignment: DeviceSize,
    pub min_texel_offset: i32,
    pub max_texel_offset: u32,
    pub min_texel_gather_offset: i32,
    pub max_texel_gather_offset: u32,
    pub min_interpolation_offset: f32,
    pub max_interpolation_offset: f32,
    pub sub_pixel_interpolation_offset_bits: u32,
    pub max_framebuffer_width: u32,
    pub max_framebuffer_height: u32,
    pub max_framebuffer_layers: u32,
    pub framebuffer_color_sample_counts: SampleCountFlags,
    pub framebuffer_depth_sample_counts: SampleCountFlags,
    pub framebuffer_stencil_sample_counts: SampleCountFlags,
    pub framebuffer_no_attachments_sample_counts: SampleCountFlags,
    pub max_color_attachments: u32,
    pub sampled_image_color_sample_counts: SampleCountFlags,
    pub sampled_image_integer_sample_counts: SampleCountFlags,
    pub sampled_image_depth_sample_counts: SampleCountFlags,
    pub sampled_image_stencil_sample_counts: SampleCountFlags,
    pub storage_image_sample_counts: SampleCountFlags,
    pub max_sample_mask_words: u32,
    pub timestamp_compute_and_graphics: Bool32,
    pub timestamp_period: f32,
    pub max_clip_distances: u32,
    pub max_cull_distances: u32,
    pub max_combined_clip_and_cull_distances: u32,
    pub discrete_queue_priorities: u32,
    pub point_size_range: [f32; 2],
    pub line_width_range: [f32; 2],
    pub point_size_granularity: f32,
    pub line_width_granularity: f32,
    pub strict_lines: Bool32,
    pub standard_sample_locations: Bool32,
    pub optimal_buffer_copy_offset_alignment: DeviceSize,
    pub optimal_buffer_copy_row_pitch_alignment: DeviceSize,
    pub non_coherent_atom_size: DeviceSize,
}
impl ::std::default::Default for PhysicalDeviceLimits {
    #[inline]
    fn default() -> Self {
        Self {
            max_image_dimension1_d: u32::default(),
            max_image_dimension2_d: u32::default(),
            max_image_dimension3_d: u32::default(),
            max_image_dimension_cube: u32::default(),
            max_image_array_layers: u32::default(),
            max_texel_buffer_elements: u32::default(),
            max_uniform_buffer_range: u32::default(),
            max_storage_buffer_range: u32::default(),
            max_push_constants_size: u32::default(),
            max_memory_allocation_count: u32::default(),
            max_sampler_allocation_count: u32::default(),
            buffer_image_granularity: DeviceSize::default(),
            sparse_address_space_size: DeviceSize::default(),
            max_bound_descriptor_sets: u32::default(),
            max_per_stage_descriptor_samplers: u32::default(),
            max_per_stage_descriptor_uniform_buffers: u32::default(),
            max_per_stage_descriptor_storage_buffers: u32::default(),
            max_per_stage_descriptor_sampled_images: u32::default(),
            max_per_stage_descriptor_storage_images: u32::default(),
            max_per_stage_descriptor_input_attachments: u32::default(),
            max_per_stage_resources: u32::default(),
            max_descriptor_set_samplers: u32::default(),
            max_descriptor_set_uniform_buffers: u32::default(),
            max_descriptor_set_uniform_buffers_dynamic: u32::default(),
            max_descriptor_set_storage_buffers: u32::default(),
            max_descriptor_set_storage_buffers_dynamic: u32::default(),
            max_descriptor_set_sampled_images: u32::default(),
            max_descriptor_set_storage_images: u32::default(),
            max_descriptor_set_input_attachments: u32::default(),
            max_vertex_input_attributes: u32::default(),
            max_vertex_input_bindings: u32::default(),
            max_vertex_input_attribute_offset: u32::default(),
            max_vertex_input_binding_stride: u32::default(),
            max_vertex_output_components: u32::default(),
            max_tessellation_generation_level: u32::default(),
            max_tessellation_patch_size: u32::default(),
            max_tessellation_control_per_vertex_input_components: u32::default(),
            max_tessellation_control_per_vertex_output_components: u32::default(),
            max_tessellation_control_per_patch_output_components: u32::default(),
            max_tessellation_control_total_output_components: u32::default(),
            max_tessellation_evaluation_input_components: u32::default(),
            max_tessellation_evaluation_output_components: u32::default(),
            max_geometry_shader_invocations: u32::default(),
            max_geometry_input_components: u32::default(),
            max_geometry_output_components: u32::default(),
            max_geometry_output_vertices: u32::default(),
            max_geometry_total_output_components: u32::default(),
            max_fragment_input_components: u32::default(),
            max_fragment_output_attachments: u32::default(),
            max_fragment_dual_src_attachments: u32::default(),
            max_fragment_combined_output_resources: u32::default(),
            max_compute_shared_memory_size: u32::default(),
            max_compute_work_group_count: unsafe { ::std::mem::zeroed() },
            max_compute_work_group_invocations: u32::default(),
            max_compute_work_group_size: unsafe { ::std::mem::zeroed() },
            sub_pixel_precision_bits: u32::default(),
            sub_texel_precision_bits: u32::default(),
            mipmap_precision_bits: u32::default(),
            max_draw_indexed_index_value: u32::default(),
            max_draw_indirect_count: u32::default(),
            max_sampler_lod_bias: f32::default(),
            max_sampler_anisotropy: f32::default(),
            max_viewports: u32::default(),
            max_viewport_dimensions: unsafe { ::std::mem::zeroed() },
            viewport_bounds_range: unsafe { ::std::mem::zeroed() },
            viewport_sub_pixel_bits: u32::default(),
            min_memory_map_alignment: usize::default(),
            min_texel_buffer_offset_alignment: DeviceSize::default(),
            min_uniform_buffer_offset_alignment: DeviceSize::default(),
            min_storage_buffer_offset_alignment: DeviceSize::default(),
            min_texel_offset: i32::default(),
            max_texel_offset: u32::default(),
            min_texel_gather_offset: i32::default(),
            max_texel_gather_offset: u32::default(),
            min_interpolation_offset: f32::default(),
            max_interpolation_offset: f32::default(),
            sub_pixel_interpolation_offset_bits: u32::default(),
            max_framebuffer_width: u32::default(),
            max_framebuffer_height: u32::default(),
            max_framebuffer_layers: u32::default(),
            framebuffer_color_sample_counts: SampleCountFlags::default(),
            framebuffer_depth_sample_counts: SampleCountFlags::default(),
            framebuffer_stencil_sample_counts: SampleCountFlags::default(),
            framebuffer_no_attachments_sample_counts: SampleCountFlags::default(),
            max_color_attachments: u32::default(),
            sampled_image_color_sample_counts: SampleCountFlags::default(),
            sampled_image_integer_sample_counts: SampleCountFlags::default(),
            sampled_image_depth_sample_counts: SampleCountFlags::default(),
            sampled_image_stencil_sample_counts: SampleCountFlags::default(),
            storage_image_sample_counts: SampleCountFlags::default(),
            max_sample_mask_words: u32::default(),
            timestamp_compute_and_graphics: Bool32::default(),
            timestamp_period: f32::default(),
            max_clip_distances: u32::default(),
            max_cull_distances: u32::default(),
            max_combined_clip_and_cull_distances: u32::default(),
            discrete_queue_priorities: u32::default(),
            point_size_range: unsafe { ::std::mem::zeroed() },
            line_width_range: unsafe { ::std::mem::zeroed() },
            point_size_granularity: f32::default(),
            line_width_granularity: f32::default(),
            strict_lines: Bool32::default(),
            standard_sample_locations: Bool32::default(),
            optimal_buffer_copy_offset_alignment: DeviceSize::default(),
            optimal_buffer_copy_row_pitch_alignment: DeviceSize::default(),
            non_coherent_atom_size: DeviceSize::default(),
        }
    }
}
impl PhysicalDeviceLimits {
    #[inline]
    pub fn max_image_dimension1_d(mut self, max_image_dimension1_d: u32) -> Self {
        self.max_image_dimension1_d = max_image_dimension1_d;
        self
    }
    #[inline]
    pub fn max_image_dimension2_d(mut self, max_image_dimension2_d: u32) -> Self {
        self.max_image_dimension2_d = max_image_dimension2_d;
        self
    }
    #[inline]
    pub fn max_image_dimension3_d(mut self, max_image_dimension3_d: u32) -> Self {
        self.max_image_dimension3_d = max_image_dimension3_d;
        self
    }
    #[inline]
    pub fn max_image_dimension_cube(mut self, max_image_dimension_cube: u32) -> Self {
        self.max_image_dimension_cube = max_image_dimension_cube;
        self
    }
    #[inline]
    pub fn max_image_array_layers(mut self, max_image_array_layers: u32) -> Self {
        self.max_image_array_layers = max_image_array_layers;
        self
    }
    #[inline]
    pub fn max_texel_buffer_elements(mut self, max_texel_buffer_elements: u32) -> Self {
        self.max_texel_buffer_elements = max_texel_buffer_elements;
        self
    }
    #[inline]
    pub fn max_uniform_buffer_range(mut self, max_uniform_buffer_range: u32) -> Self {
        self.max_uniform_buffer_range = max_uniform_buffer_range;
        self
    }
    #[inline]
    pub fn max_storage_buffer_range(mut self, max_storage_buffer_range: u32) -> Self {
        self.max_storage_buffer_range = max_storage_buffer_range;
        self
    }
    #[inline]
    pub fn max_push_constants_size(mut self, max_push_constants_size: u32) -> Self {
        self.max_push_constants_size = max_push_constants_size;
        self
    }
    #[inline]
    pub fn max_memory_allocation_count(mut self, max_memory_allocation_count: u32) -> Self {
        self.max_memory_allocation_count = max_memory_allocation_count;
        self
    }
    #[inline]
    pub fn max_sampler_allocation_count(mut self, max_sampler_allocation_count: u32) -> Self {
        self.max_sampler_allocation_count = max_sampler_allocation_count;
        self
    }
    #[inline]
    pub fn buffer_image_granularity(mut self, buffer_image_granularity: DeviceSize) -> Self {
        self.buffer_image_granularity = buffer_image_granularity;
        self
    }
    #[inline]
    pub fn sparse_address_space_size(mut self, sparse_address_space_size: DeviceSize) -> Self {
        self.sparse_address_space_size = sparse_address_space_size;
        self
    }
    #[inline]
    pub fn max_bound_descriptor_sets(mut self, max_bound_descriptor_sets: u32) -> Self {
        self.max_bound_descriptor_sets = max_bound_descriptor_sets;
        self
    }
    #[inline]
    pub fn max_per_stage_descriptor_samplers(
        mut self,
        max_per_stage_descriptor_samplers: u32,
    ) -> Self {
        self.max_per_stage_descriptor_samplers = max_per_stage_descriptor_samplers;
        self
    }
    #[inline]
    pub fn max_per_stage_descriptor_uniform_buffers(
        mut self,
        max_per_stage_descriptor_uniform_buffers: u32,
    ) -> Self {
        self.max_per_stage_descriptor_uniform_buffers = max_per_stage_descriptor_uniform_buffers;
        self
    }
    #[inline]
    pub fn max_per_stage_descriptor_storage_buffers(
        mut self,
        max_per_stage_descriptor_storage_buffers: u32,
    ) -> Self {
        self.max_per_stage_descriptor_storage_buffers = max_per_stage_descriptor_storage_buffers;
        self
    }
    #[inline]
    pub fn max_per_stage_descriptor_sampled_images(
        mut self,
        max_per_stage_descriptor_sampled_images: u32,
    ) -> Self {
        self.max_per_stage_descriptor_sampled_images = max_per_stage_descriptor_sampled_images;
        self
    }
    #[inline]
    pub fn max_per_stage_descriptor_storage_images(
        mut self,
        max_per_stage_descriptor_storage_images: u32,
    ) -> Self {
        self.max_per_stage_descriptor_storage_images = max_per_stage_descriptor_storage_images;
        self
    }
    #[inline]
    pub fn max_per_stage_descriptor_input_attachments(
        mut self,
        max_per_stage_descriptor_input_attachments: u32,
    ) -> Self {
        self.max_per_stage_descriptor_input_attachments =
            max_per_stage_descriptor_input_attachments;
        self
    }
    #[inline]
    pub fn max_per_stage_resources(mut self, max_per_stage_resources: u32) -> Self {
        self.max_per_stage_resources = max_per_stage_resources;
        self
    }
    #[inline]
    pub fn max_descriptor_set_samplers(mut self, max_descriptor_set_samplers: u32) -> Self {
        self.max_descriptor_set_samplers = max_descriptor_set_samplers;
        self
    }
    #[inline]
    pub fn max_descriptor_set_uniform_buffers(
        mut self,
        max_descriptor_set_uniform_buffers: u32,
    ) -> Self {
        self.max_descriptor_set_uniform_buffers = max_descriptor_set_uniform_buffers;
        self
    }
    #[inline]
    pub fn max_descriptor_set_uniform_buffers_dynamic(
        mut self,
        max_descriptor_set_uniform_buffers_dynamic: u32,
    ) -> Self {
        self.max_descriptor_set_uniform_buffers_dynamic =
            max_descriptor_set_uniform_buffers_dynamic;
        self
    }
    #[inline]
    pub fn max_descriptor_set_storage_buffers(
        mut self,
        max_descriptor_set_storage_buffers: u32,
    ) -> Self {
        self.max_descriptor_set_storage_buffers = max_descriptor_set_storage_buffers;
        self
    }
    #[inline]
    pub fn max_descriptor_set_storage_buffers_dynamic(
        mut self,
        max_descriptor_set_storage_buffers_dynamic: u32,
    ) -> Self {
        self.max_descriptor_set_storage_buffers_dynamic =
            max_descriptor_set_storage_buffers_dynamic;
        self
    }
    #[inline]
    pub fn max_descriptor_set_sampled_images(
        mut self,
        max_descriptor_set_sampled_images: u32,
    ) -> Self {
        self.max_descriptor_set_sampled_images = max_descriptor_set_sampled_images;
        self
    }
    #[inline]
    pub fn max_descriptor_set_storage_images(
        mut self,
        max_descriptor_set_storage_images: u32,
    ) -> Self {
        self.max_descriptor_set_storage_images = max_descriptor_set_storage_images;
        self
    }
    #[inline]
    pub fn max_descriptor_set_input_attachments(
        mut self,
        max_descriptor_set_input_attachments: u32,
    ) -> Self {
        self.max_descriptor_set_input_attachments = max_descriptor_set_input_attachments;
        self
    }
    #[inline]
    pub fn max_vertex_input_attributes(mut self, max_vertex_input_attributes: u32) -> Self {
        self.max_vertex_input_attributes = max_vertex_input_attributes;
        self
    }
    #[inline]
    pub fn max_vertex_input_bindings(mut self, max_vertex_input_bindings: u32) -> Self {
        self.max_vertex_input_bindings = max_vertex_input_bindings;
        self
    }
    #[inline]
    pub fn max_vertex_input_attribute_offset(
        mut self,
        max_vertex_input_attribute_offset: u32,
    ) -> Self {
        self.max_vertex_input_attribute_offset = max_vertex_input_attribute_offset;
        self
    }
    #[inline]
    pub fn max_vertex_input_binding_stride(mut self, max_vertex_input_binding_stride: u32) -> Self {
        self.max_vertex_input_binding_stride = max_vertex_input_binding_stride;
        self
    }
    #[inline]
    pub fn max_vertex_output_components(mut self, max_vertex_output_components: u32) -> Self {
        self.max_vertex_output_components = max_vertex_output_components;
        self
    }
    #[inline]
    pub fn max_tessellation_generation_level(
        mut self,
        max_tessellation_generation_level: u32,
    ) -> Self {
        self.max_tessellation_generation_level = max_tessellation_generation_level;
        self
    }
    #[inline]
    pub fn max_tessellation_patch_size(mut self, max_tessellation_patch_size: u32) -> Self {
        self.max_tessellation_patch_size = max_tessellation_patch_size;
        self
    }
    #[inline]
    pub fn max_tessellation_control_per_vertex_input_components(
        mut self,
        max_tessellation_control_per_vertex_input_components: u32,
    ) -> Self {
        self.max_tessellation_control_per_vertex_input_components =
            max_tessellation_control_per_vertex_input_components;
        self
    }
    #[inline]
    pub fn max_tessellation_control_per_vertex_output_components(
        mut self,
        max_tessellation_control_per_vertex_output_components: u32,
    ) -> Self {
        self.max_tessellation_control_per_vertex_output_components =
            max_tessellation_control_per_vertex_output_components;
        self
    }
    #[inline]
    pub fn max_tessellation_control_per_patch_output_components(
        mut self,
        max_tessellation_control_per_patch_output_components: u32,
    ) -> Self {
        self.max_tessellation_control_per_patch_output_components =
            max_tessellation_control_per_patch_output_components;
        self
    }
    #[inline]
    pub fn max_tessellation_control_total_output_components(
        mut self,
        max_tessellation_control_total_output_components: u32,
    ) -> Self {
        self.max_tessellation_control_total_output_components =
            max_tessellation_control_total_output_components;
        self
    }
    #[inline]
    pub fn max_tessellation_evaluation_input_components(
        mut self,
        max_tessellation_evaluation_input_components: u32,
    ) -> Self {
        self.max_tessellation_evaluation_input_components =
            max_tessellation_evaluation_input_components;
        self
    }
    #[inline]
    pub fn max_tessellation_evaluation_output_components(
        mut self,
        max_tessellation_evaluation_output_components: u32,
    ) -> Self {
        self.max_tessellation_evaluation_output_components =
            max_tessellation_evaluation_output_components;
        self
    }
    #[inline]
    pub fn max_geometry_shader_invocations(mut self, max_geometry_shader_invocations: u32) -> Self {
        self.max_geometry_shader_invocations = max_geometry_shader_invocations;
        self
    }
    #[inline]
    pub fn max_geometry_input_components(mut self, max_geometry_input_components: u32) -> Self {
        self.max_geometry_input_components = max_geometry_input_components;
        self
    }
    #[inline]
    pub fn max_geometry_output_components(mut self, max_geometry_output_components: u32) -> Self {
        self.max_geometry_output_components = max_geometry_output_components;
        self
    }
    #[inline]
    pub fn max_geometry_output_vertices(mut self, max_geometry_output_vertices: u32) -> Self {
        self.max_geometry_output_vertices = max_geometry_output_vertices;
        self
    }
    #[inline]
    pub fn max_geometry_total_output_components(
        mut self,
        max_geometry_total_output_components: u32,
    ) -> Self {
        self.max_geometry_total_output_components = max_geometry_total_output_components;
        self
    }
    #[inline]
    pub fn max_fragment_input_components(mut self, max_fragment_input_components: u32) -> Self {
        self.max_fragment_input_components = max_fragment_input_components;
        self
    }
    #[inline]
    pub fn max_fragment_output_attachments(mut self, max_fragment_output_attachments: u32) -> Self {
        self.max_fragment_output_attachments = max_fragment_output_attachments;
        self
    }
    #[inline]
    pub fn max_fragment_dual_src_attachments(
        mut self,
        max_fragment_dual_src_attachments: u32,
    ) -> Self {
        self.max_fragment_dual_src_attachments = max_fragment_dual_src_attachments;
        self
    }
    #[inline]
    pub fn max_fragment_combined_output_resources(
        mut self,
        max_fragment_combined_output_resources: u32,
    ) -> Self {
        self.max_fragment_combined_output_resources = max_fragment_combined_output_resources;
        self
    }
    #[inline]
    pub fn max_compute_shared_memory_size(mut self, max_compute_shared_memory_size: u32) -> Self {
        self.max_compute_shared_memory_size = max_compute_shared_memory_size;
        self
    }
    #[inline]
    pub fn max_compute_work_group_count(mut self, max_compute_work_group_count: [u32; 3]) -> Self {
        self.max_compute_work_group_count = max_compute_work_group_count;
        self
    }
    #[inline]
    pub fn max_compute_work_group_invocations(
        mut self,
        max_compute_work_group_invocations: u32,
    ) -> Self {
        self.max_compute_work_group_invocations = max_compute_work_group_invocations;
        self
    }
    #[inline]
    pub fn max_compute_work_group_size(mut self, max_compute_work_group_size: [u32; 3]) -> Self {
        self.max_compute_work_group_size = max_compute_work_group_size;
        self
    }
    #[inline]
    pub fn sub_pixel_precision_bits(mut self, sub_pixel_precision_bits: u32) -> Self {
        self.sub_pixel_precision_bits = sub_pixel_precision_bits;
        self
    }
    #[inline]
    pub fn sub_texel_precision_bits(mut self, sub_texel_precision_bits: u32) -> Self {
        self.sub_texel_precision_bits = sub_texel_precision_bits;
        self
    }
    #[inline]
    pub fn mipmap_precision_bits(mut self, mipmap_precision_bits: u32) -> Self {
        self.mipmap_precision_bits = mipmap_precision_bits;
        self
    }
    #[inline]
    pub fn max_draw_indexed_index_value(mut self, max_draw_indexed_index_value: u32) -> Self {
        self.max_draw_indexed_index_value = max_draw_indexed_index_value;
        self
    }
    #[inline]
    pub fn max_draw_indirect_count(mut self, max_draw_indirect_count: u32) -> Self {
        self.max_draw_indirect_count = max_draw_indirect_count;
        self
    }
    #[inline]
    pub fn max_sampler_lod_bias(mut self, max_sampler_lod_bias: f32) -> Self {
        self.max_sampler_lod_bias = max_sampler_lod_bias;
        self
    }
    #[inline]
    pub fn max_sampler_anisotropy(mut self, max_sampler_anisotropy: f32) -> Self {
        self.max_sampler_anisotropy = max_sampler_anisotropy;
        self
    }
    #[inline]
    pub fn max_viewports(mut self, max_viewports: u32) -> Self {
        self.max_viewports = max_viewports;
        self
    }
    #[inline]
    pub fn max_viewport_dimensions(mut self, max_viewport_dimensions: [u32; 2]) -> Self {
        self.max_viewport_dimensions = max_viewport_dimensions;
        self
    }
    #[inline]
    pub fn viewport_bounds_range(mut self, viewport_bounds_range: [f32; 2]) -> Self {
        self.viewport_bounds_range = viewport_bounds_range;
        self
    }
    #[inline]
    pub fn viewport_sub_pixel_bits(mut self, viewport_sub_pixel_bits: u32) -> Self {
        self.viewport_sub_pixel_bits = viewport_sub_pixel_bits;
        self
    }
    #[inline]
    pub fn min_memory_map_alignment(mut self, min_memory_map_alignment: usize) -> Self {
        self.min_memory_map_alignment = min_memory_map_alignment;
        self
    }
    #[inline]
    pub fn min_texel_buffer_offset_alignment(
        mut self,
        min_texel_buffer_offset_alignment: DeviceSize,
    ) -> Self {
        self.min_texel_buffer_offset_alignment = min_texel_buffer_offset_alignment;
        self
    }
    #[inline]
    pub fn min_uniform_buffer_offset_alignment(
        mut self,
        min_uniform_buffer_offset_alignment: DeviceSize,
    ) -> Self {
        self.min_uniform_buffer_offset_alignment = min_uniform_buffer_offset_alignment;
        self
    }
    #[inline]
    pub fn min_storage_buffer_offset_alignment(
        mut self,
        min_storage_buffer_offset_alignment: DeviceSize,
    ) -> Self {
        self.min_storage_buffer_offset_alignment = min_storage_buffer_offset_alignment;
        self
    }
    #[inline]
    pub fn min_texel_offset(mut self, min_texel_offset: i32) -> Self {
        self.min_texel_offset = min_texel_offset;
        self
    }
    #[inline]
    pub fn max_texel_offset(mut self, max_texel_offset: u32) -> Self {
        self.max_texel_offset = max_texel_offset;
        self
    }
    #[inline]
    pub fn min_texel_gather_offset(mut self, min_texel_gather_offset: i32) -> Self {
        self.min_texel_gather_offset = min_texel_gather_offset;
        self
    }
    #[inline]
    pub fn max_texel_gather_offset(mut self, max_texel_gather_offset: u32) -> Self {
        self.max_texel_gather_offset = max_texel_gather_offset;
        self
    }
    #[inline]
    pub fn min_interpolation_offset(mut self, min_interpolation_offset: f32) -> Self {
        self.min_interpolation_offset = min_interpolation_offset;
        self
    }
    #[inline]
    pub fn max_interpolation_offset(mut self, max_interpolation_offset: f32) -> Self {
        self.max_interpolation_offset = max_interpolation_offset;
        self
    }
    #[inline]
    pub fn sub_pixel_interpolation_offset_bits(
        mut self,
        sub_pixel_interpolation_offset_bits: u32,
    ) -> Self {
        self.sub_pixel_interpolation_offset_bits = sub_pixel_interpolation_offset_bits;
        self
    }
    #[inline]
    pub fn max_framebuffer_width(mut self, max_framebuffer_width: u32) -> Self {
        self.max_framebuffer_width = max_framebuffer_width;
        self
    }
    #[inline]
    pub fn max_framebuffer_height(mut self, max_framebuffer_height: u32) -> Self {
        self.max_framebuffer_height = max_framebuffer_height;
        self
    }
    #[inline]
    pub fn max_framebuffer_layers(mut self, max_framebuffer_layers: u32) -> Self {
        self.max_framebuffer_layers = max_framebuffer_layers;
        self
    }
    #[inline]
    pub fn framebuffer_color_sample_counts(
        mut self,
        framebuffer_color_sample_counts: SampleCountFlags,
    ) -> Self {
        self.framebuffer_color_sample_counts = framebuffer_color_sample_counts;
        self
    }
    #[inline]
    pub fn framebuffer_depth_sample_counts(
        mut self,
        framebuffer_depth_sample_counts: SampleCountFlags,
    ) -> Self {
        self.framebuffer_depth_sample_counts = framebuffer_depth_sample_counts;
        self
    }
    #[inline]
    pub fn framebuffer_stencil_sample_counts(
        mut self,
        framebuffer_stencil_sample_counts: SampleCountFlags,
    ) -> Self {
        self.framebuffer_stencil_sample_counts = framebuffer_stencil_sample_counts;
        self
    }
    #[inline]
    pub fn framebuffer_no_attachments_sample_counts(
        mut self,
        framebuffer_no_attachments_sample_counts: SampleCountFlags,
    ) -> Self {
        self.framebuffer_no_attachments_sample_counts = framebuffer_no_attachments_sample_counts;
        self
    }
    #[inline]
    pub fn max_color_attachments(mut self, max_color_attachments: u32) -> Self {
        self.max_color_attachments = max_color_attachments;
        self
    }
    #[inline]
    pub fn sampled_image_color_sample_counts(
        mut self,
        sampled_image_color_sample_counts: SampleCountFlags,
    ) -> Self {
        self.sampled_image_color_sample_counts = sampled_image_color_sample_counts;
        self
    }
    #[inline]
    pub fn sampled_image_integer_sample_counts(
        mut self,
        sampled_image_integer_sample_counts: SampleCountFlags,
    ) -> Self {
        self.sampled_image_integer_sample_counts = sampled_image_integer_sample_counts;
        self
    }
    #[inline]
    pub fn sampled_image_depth_sample_counts(
        mut self,
        sampled_image_depth_sample_counts: SampleCountFlags,
    ) -> Self {
        self.sampled_image_depth_sample_counts = sampled_image_depth_sample_counts;
        self
    }
    #[inline]
    pub fn sampled_image_stencil_sample_counts(
        mut self,
        sampled_image_stencil_sample_counts: SampleCountFlags,
    ) -> Self {
        self.sampled_image_stencil_sample_counts = sampled_image_stencil_sample_counts;
        self
    }
    #[inline]
    pub fn storage_image_sample_counts(
        mut self,
        storage_image_sample_counts: SampleCountFlags,
    ) -> Self {
        self.storage_image_sample_counts = storage_image_sample_counts;
        self
    }
    #[inline]
    pub fn max_sample_mask_words(mut self, max_sample_mask_words: u32) -> Self {
        self.max_sample_mask_words = max_sample_mask_words;
        self
    }
    #[inline]
    pub fn timestamp_compute_and_graphics(mut self, timestamp_compute_and_graphics: bool) -> Self {
        self.timestamp_compute_and_graphics = timestamp_compute_and_graphics.into();
        self
    }
    #[inline]
    pub fn timestamp_period(mut self, timestamp_period: f32) -> Self {
        self.timestamp_period = timestamp_period;
        self
    }
    #[inline]
    pub fn max_clip_distances(mut self, max_clip_distances: u32) -> Self {
        self.max_clip_distances = max_clip_distances;
        self
    }
    #[inline]
    pub fn max_cull_distances(mut self, max_cull_distances: u32) -> Self {
        self.max_cull_distances = max_cull_distances;
        self
    }
    #[inline]
    pub fn max_combined_clip_and_cull_distances(
        mut self,
        max_combined_clip_and_cull_distances: u32,
    ) -> Self {
        self.max_combined_clip_and_cull_distances = max_combined_clip_and_cull_distances;
        self
    }
    #[inline]
    pub fn discrete_queue_priorities(mut self, discrete_queue_priorities: u32) -> Self {
        self.discrete_queue_priorities = discrete_queue_priorities;
        self
    }
    #[inline]
    pub fn point_size_range(mut self, point_size_range: [f32; 2]) -> Self {
        self.point_size_range = point_size_range;
        self
    }
    #[inline]
    pub fn line_width_range(mut self, line_width_range: [f32; 2]) -> Self {
        self.line_width_range = line_width_range;
        self
    }
    #[inline]
    pub fn point_size_granularity(mut self, point_size_granularity: f32) -> Self {
        self.point_size_granularity = point_size_granularity;
        self
    }
    #[inline]
    pub fn line_width_granularity(mut self, line_width_granularity: f32) -> Self {
        self.line_width_granularity = line_width_granularity;
        self
    }
    #[inline]
    pub fn strict_lines(mut self, strict_lines: bool) -> Self {
        self.strict_lines = strict_lines.into();
        self
    }
    #[inline]
    pub fn standard_sample_locations(mut self, standard_sample_locations: bool) -> Self {
        self.standard_sample_locations = standard_sample_locations.into();
        self
    }
    #[inline]
    pub fn optimal_buffer_copy_offset_alignment(
        mut self,
        optimal_buffer_copy_offset_alignment: DeviceSize,
    ) -> Self {
        self.optimal_buffer_copy_offset_alignment = optimal_buffer_copy_offset_alignment;
        self
    }
    #[inline]
    pub fn optimal_buffer_copy_row_pitch_alignment(
        mut self,
        optimal_buffer_copy_row_pitch_alignment: DeviceSize,
    ) -> Self {
        self.optimal_buffer_copy_row_pitch_alignment = optimal_buffer_copy_row_pitch_alignment;
        self
    }
    #[inline]
    pub fn non_coherent_atom_size(mut self, non_coherent_atom_size: DeviceSize) -> Self {
        self.non_coherent_atom_size = non_coherent_atom_size;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSemaphoreCreateInfo.html>"]
pub struct SemaphoreCreateInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: SemaphoreCreateFlags,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for SemaphoreCreateInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: SemaphoreCreateFlags::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for SemaphoreCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::SEMAPHORE_CREATE_INFO;
}
pub unsafe trait ExtendsSemaphoreCreateInfo {}
impl<'a> SemaphoreCreateInfo<'a> {
    #[inline]
    pub fn flags(mut self, flags: SemaphoreCreateFlags) -> Self {
        self.flags = flags;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `x.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsSemaphoreCreateInfo>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.p_next as _;
            self.p_next = next_ptr;
        }
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkQueryPoolCreateInfo.html>"]
pub struct QueryPoolCreateInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: QueryPoolCreateFlags,
    pub query_type: QueryType,
    pub query_count: u32,
    pub pipeline_statistics: QueryPipelineStatisticFlags,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for QueryPoolCreateInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: QueryPoolCreateFlags::default(),
            query_type: QueryType::default(),
            query_count: u32::default(),
            pipeline_statistics: QueryPipelineStatisticFlags::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for QueryPoolCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::QUERY_POOL_CREATE_INFO;
}
pub unsafe trait ExtendsQueryPoolCreateInfo {}
impl<'a> QueryPoolCreateInfo<'a> {
    #[inline]
    pub fn flags(mut self, flags: QueryPoolCreateFlags) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn query_type(mut self, query_type: QueryType) -> Self {
        self.query_type = query_type;
        self
    }
    #[inline]
    pub fn query_count(mut self, query_count: u32) -> Self {
        self.query_count = query_count;
        self
    }
    #[inline]
    pub fn pipeline_statistics(mut self, pipeline_statistics: QueryPipelineStatisticFlags) -> Self {
        self.pipeline_statistics = pipeline_statistics;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `x.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsQueryPoolCreateInfo>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.p_next as _;
            self.p_next = next_ptr;
        }
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFramebufferCreateInfo.html>"]
pub struct FramebufferCreateInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: FramebufferCreateFlags,
    pub render_pass: RenderPass,
    pub attachment_count: u32,
    pub p_attachments: *const ImageView,
    pub width: u32,
    pub height: u32,
    pub layers: u32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for FramebufferCreateInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: FramebufferCreateFlags::default(),
            render_pass: RenderPass::default(),
            attachment_count: u32::default(),
            p_attachments: ::std::ptr::null(),
            width: u32::default(),
            height: u32::default(),
            layers: u32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for FramebufferCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::FRAMEBUFFER_CREATE_INFO;
}
pub unsafe trait ExtendsFramebufferCreateInfo {}
impl<'a> FramebufferCreateInfo<'a> {
    #[inline]
    pub fn flags(mut self, flags: FramebufferCreateFlags) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn render_pass(mut self, render_pass: RenderPass) -> Self {
        self.render_pass = render_pass;
        self
    }
    #[inline]
    pub fn attachments(mut self, attachments: &'a [ImageView]) -> Self {
        self.attachment_count = attachments.len() as _;
        self.p_attachments = attachments.as_ptr();
        self
    }
    #[inline]
    pub fn width(mut self, width: u32) -> Self {
        self.width = width;
        self
    }
    #[inline]
    pub fn height(mut self, height: u32) -> Self {
        self.height = height;
        self
    }
    #[inline]
    pub fn layers(mut self, layers: u32) -> Self {
        self.layers = layers;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `x.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsFramebufferCreateInfo>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.p_next as _;
            self.p_next = next_ptr;
        }
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDrawIndirectCommand.html>"]
pub struct DrawIndirectCommand {
    pub vertex_count: u32,
    pub instance_count: u32,
    pub first_vertex: u32,
    pub first_instance: u32,
}
impl DrawIndirectCommand {
    #[inline]
    pub fn vertex_count(mut self, vertex_count: u32) -> Self {
        self.vertex_count = vertex_count;
        self
    }
    #[inline]
    pub fn instance_count(mut self, instance_count: u32) -> Self {
        self.instance_count = instance_count;
        self
    }
    #[inline]
    pub fn first_vertex(mut self, first_vertex: u32) -> Self {
        self.first_vertex = first_vertex;
        self
    }
    #[inline]
    pub fn first_instance(mut self, first_instance: u32) -> Self {
        self.first_instance = first_instance;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDrawIndexedIndirectCommand.html>"]
pub struct DrawIndexedIndirectCommand {
    pub index_count: u32,
    pub instance_count: u32,
    pub first_index: u32,
    pub vertex_offset: i32,
    pub first_instance: u32,
}
impl DrawIndexedIndirectCommand {
    #[inline]
    pub fn index_count(mut self, index_count: u32) -> Self {
        self.index_count = index_count;
        self
    }
    #[inline]
    pub fn instance_count(mut self, instance_count: u32) -> Self {
        self.instance_count = instance_count;
        self
    }
    #[inline]
    pub fn first_index(mut self, first_index: u32) -> Self {
        self.first_index = first_index;
        self
    }
    #[inline]
    pub fn vertex_offset(mut self, vertex_offset: i32) -> Self {
        self.vertex_offset = vertex_offset;
        self
    }
    #[inline]
    pub fn first_instance(mut self, first_instance: u32) -> Self {
        self.first_instance = first_instance;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDispatchIndirectCommand.html>"]
pub struct DispatchIndirectCommand {
    pub x: u32,
    pub y: u32,
    pub z: u32,
}
impl DispatchIndirectCommand {
    #[inline]
    pub fn x(mut self, x: u32) -> Self {
        self.x = x;
        self
    }
    #[inline]
    pub fn y(mut self, y: u32) -> Self {
        self.y = y;
        self
    }
    #[inline]
    pub fn z(mut self, z: u32) -> Self {
        self.z = z;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMultiDrawInfoEXT.html>"]
pub struct MultiDrawInfoEXT {
    pub first_vertex: u32,
    pub vertex_count: u32,
}
impl MultiDrawInfoEXT {
    #[inline]
    pub fn first_vertex(mut self, first_vertex: u32) -> Self {
        self.first_vertex = first_vertex;
        self
    }
    #[inline]
    pub fn vertex_count(mut self, vertex_count: u32) -> Self {
        self.vertex_count = vertex_count;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMultiDrawIndexedInfoEXT.html>"]
pub struct MultiDrawIndexedInfoEXT {
    pub first_index: u32,
    pub index_count: u32,
    pub vertex_offset: i32,
}
impl MultiDrawIndexedInfoEXT {
    #[inline]
    pub fn first_index(mut self, first_index: u32) -> Self {
        self.first_index = first_index;
        self
    }
    #[inline]
    pub fn index_count(mut self, index_count: u32) -> Self {
        self.index_count = index_count;
        self
    }
    #[inline]
    pub fn vertex_offset(mut self, vertex_offset: i32) -> Self {
        self.vertex_offset = vertex_offset;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSubmitInfo.html>"]
pub struct SubmitInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub wait_semaphore_count: u32,
    pub p_wait_semaphores: *const Semaphore,
    pub p_wait_dst_stage_mask: *const PipelineStageFlags,
    pub command_buffer_count: u32,
    pub p_command_buffers: *const CommandBuffer,
    pub signal_semaphore_count: u32,
    pub p_signal_semaphores: *const Semaphore,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for SubmitInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            wait_semaphore_count: u32::default(),
            p_wait_semaphores: ::std::ptr::null(),
            p_wait_dst_stage_mask: ::std::ptr::null(),
            command_buffer_count: u32::default(),
            p_command_buffers: ::std::ptr::null(),
            signal_semaphore_count: u32::default(),
            p_signal_semaphores: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for SubmitInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::SUBMIT_INFO;
}
pub unsafe trait ExtendsSubmitInfo {}
impl<'a> SubmitInfo<'a> {
    #[inline]
    pub fn wait_semaphores(mut self, wait_semaphores: &'a [Semaphore]) -> Self {
        self.wait_semaphore_count = wait_semaphores.len() as _;
        self.p_wait_semaphores = wait_semaphores.as_ptr();
        self
    }
    #[inline]
    pub fn wait_dst_stage_mask(mut self, wait_dst_stage_mask: &'a [PipelineStageFlags]) -> Self {
        self.wait_semaphore_count = wait_dst_stage_mask.len() as _;
        self.p_wait_dst_stage_mask = wait_dst_stage_mask.as_ptr();
        self
    }
    #[inline]
    pub fn command_buffers(mut self, command_buffers: &'a [CommandBuffer]) -> Self {
        self.command_buffer_count = command_buffers.len() as _;
        self.p_command_buffers = command_buffers.as_ptr();
        self
    }
    #[inline]
    pub fn signal_semaphores(mut self, signal_semaphores: &'a [Semaphore]) -> Self {
        self.signal_semaphore_count = signal_semaphores.len() as _;
        self.p_signal_semaphores = signal_semaphores.as_ptr();
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `x.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsSubmitInfo>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.p_next as _;
            self.p_next = next_ptr;
        }
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplayPropertiesKHR.html>"]
pub struct DisplayPropertiesKHR<'a> {
    pub display: DisplayKHR,
    pub display_name: *const c_char,
    pub physical_dimensions: Extent2D,
    pub physical_resolution: Extent2D,
    pub supported_transforms: SurfaceTransformFlagsKHR,
    pub plane_reorder_possible: Bool32,
    pub persistent_content: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for DisplayPropertiesKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            display: DisplayKHR::default(),
            display_name: ::std::ptr::null(),
            physical_dimensions: Extent2D::default(),
            physical_resolution: Extent2D::default(),
            supported_transforms: SurfaceTransformFlagsKHR::default(),
            plane_reorder_possible: Bool32::default(),
            persistent_content: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
impl<'a> DisplayPropertiesKHR<'a> {
    #[inline]
    pub fn display(mut self, display: DisplayKHR) -> Self {
        self.display = display;
        self
    }
    #[inline]
    pub fn display_name(mut self, display_name: &'a ::std::ffi::CStr) -> Self {
        self.display_name = display_name.as_ptr();
        self
    }
    #[inline]
    pub fn physical_dimensions(mut self, physical_dimensions: Extent2D) -> Self {
        self.physical_dimensions = physical_dimensions;
        self
    }
    #[inline]
    pub fn physical_resolution(mut self, physical_resolution: Extent2D) -> Self {
        self.physical_resolution = physical_resolution;
        self
    }
    #[inline]
    pub fn supported_transforms(mut self, supported_transforms: SurfaceTransformFlagsKHR) -> Self {
        self.supported_transforms = supported_transforms;
        self
    }
    #[inline]
    pub fn plane_reorder_possible(mut self, plane_reorder_possible: bool) -> Self {
        self.plane_reorder_possible = plane_reorder_possible.into();
        self
    }
    #[inline]
    pub fn persistent_content(mut self, persistent_content: bool) -> Self {
        self.persistent_content = persistent_content.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplayPlanePropertiesKHR.html>"]
pub struct DisplayPlanePropertiesKHR {
    pub current_display: DisplayKHR,
    pub current_stack_index: u32,
}
impl DisplayPlanePropertiesKHR {
    #[inline]
    pub fn current_display(mut self, current_display: DisplayKHR) -> Self {
        self.current_display = current_display;
        self
    }
    #[inline]
    pub fn current_stack_index(mut self, current_stack_index: u32) -> Self {
        self.current_stack_index = current_stack_index;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplayModeParametersKHR.html>"]
pub struct DisplayModeParametersKHR {
    pub visible_region: Extent2D,
    pub refresh_rate: u32,
}
impl DisplayModeParametersKHR {
    #[inline]
    pub fn visible_region(mut self, visible_region: Extent2D) -> Self {
        self.visible_region = visible_region;
        self
    }
    #[inline]
    pub fn refresh_rate(mut self, refresh_rate: u32) -> Self {
        self.refresh_rate = refresh_rate;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplayModePropertiesKHR.html>"]
pub struct DisplayModePropertiesKHR {
    pub display_mode: DisplayModeKHR,
    pub parameters: DisplayModeParametersKHR,
}
impl DisplayModePropertiesKHR {
    #[inline]
    pub fn display_mode(mut self, display_mode: DisplayModeKHR) -> Self {
        self.display_mode = display_mode;
        self
    }
    #[inline]
    pub fn parameters(mut self, parameters: DisplayModeParametersKHR) -> Self {
        self.parameters = parameters;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplayModeCreateInfoKHR.html>"]
pub struct DisplayModeCreateInfoKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: DisplayModeCreateFlagsKHR,
    pub parameters: DisplayModeParametersKHR,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for DisplayModeCreateInfoKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: DisplayModeCreateFlagsKHR::default(),
            parameters: DisplayModeParametersKHR::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for DisplayModeCreateInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DISPLAY_MODE_CREATE_INFO_KHR;
}
impl<'a> DisplayModeCreateInfoKHR<'a> {
    #[inline]
    pub fn flags(mut self, flags: DisplayModeCreateFlagsKHR) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn parameters(mut self, parameters: DisplayModeParametersKHR) -> Self {
        self.parameters = parameters;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplayPlaneCapabilitiesKHR.html>"]
pub struct DisplayPlaneCapabilitiesKHR {
    pub supported_alpha: DisplayPlaneAlphaFlagsKHR,
    pub min_src_position: Offset2D,
    pub max_src_position: Offset2D,
    pub min_src_extent: Extent2D,
    pub max_src_extent: Extent2D,
    pub min_dst_position: Offset2D,
    pub max_dst_position: Offset2D,
    pub min_dst_extent: Extent2D,
    pub max_dst_extent: Extent2D,
}
impl DisplayPlaneCapabilitiesKHR {
    #[inline]
    pub fn supported_alpha(mut self, supported_alpha: DisplayPlaneAlphaFlagsKHR) -> Self {
        self.supported_alpha = supported_alpha;
        self
    }
    #[inline]
    pub fn min_src_position(mut self, min_src_position: Offset2D) -> Self {
        self.min_src_position = min_src_position;
        self
    }
    #[inline]
    pub fn max_src_position(mut self, max_src_position: Offset2D) -> Self {
        self.max_src_position = max_src_position;
        self
    }
    #[inline]
    pub fn min_src_extent(mut self, min_src_extent: Extent2D) -> Self {
        self.min_src_extent = min_src_extent;
        self
    }
    #[inline]
    pub fn max_src_extent(mut self, max_src_extent: Extent2D) -> Self {
        self.max_src_extent = max_src_extent;
        self
    }
    #[inline]
    pub fn min_dst_position(mut self, min_dst_position: Offset2D) -> Self {
        self.min_dst_position = min_dst_position;
        self
    }
    #[inline]
    pub fn max_dst_position(mut self, max_dst_position: Offset2D) -> Self {
        self.max_dst_position = max_dst_position;
        self
    }
    #[inline]
    pub fn min_dst_extent(mut self, min_dst_extent: Extent2D) -> Self {
        self.min_dst_extent = min_dst_extent;
        self
    }
    #[inline]
    pub fn max_dst_extent(mut self, max_dst_extent: Extent2D) -> Self {
        self.max_dst_extent = max_dst_extent;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplaySurfaceCreateInfoKHR.html>"]
pub struct DisplaySurfaceCreateInfoKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: DisplaySurfaceCreateFlagsKHR,
    pub display_mode: DisplayModeKHR,
    pub plane_index: u32,
    pub plane_stack_index: u32,
    pub transform: SurfaceTransformFlagsKHR,
    pub global_alpha: f32,
    pub alpha_mode: DisplayPlaneAlphaFlagsKHR,
    pub image_extent: Extent2D,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for DisplaySurfaceCreateInfoKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: DisplaySurfaceCreateFlagsKHR::default(),
            display_mode: DisplayModeKHR::default(),
            plane_index: u32::default(),
            plane_stack_index: u32::default(),
            transform: SurfaceTransformFlagsKHR::default(),
            global_alpha: f32::default(),
            alpha_mode: DisplayPlaneAlphaFlagsKHR::default(),
            image_extent: Extent2D::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for DisplaySurfaceCreateInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DISPLAY_SURFACE_CREATE_INFO_KHR;
}
impl<'a> DisplaySurfaceCreateInfoKHR<'a> {
    #[inline]
    pub fn flags(mut self, flags: DisplaySurfaceCreateFlagsKHR) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn display_mode(mut self, display_mode: DisplayModeKHR) -> Self {
        self.display_mode = display_mode;
        self
    }
    #[inline]
    pub fn plane_index(mut self, plane_index: u32) -> Self {
        self.plane_index = plane_index;
        self
    }
    #[inline]
    pub fn plane_stack_index(mut self, plane_stack_index: u32) -> Self {
        self.plane_stack_index = plane_stack_index;
        self
    }
    #[inline]
    pub fn transform(mut self, transform: SurfaceTransformFlagsKHR) -> Self {
        self.transform = transform;
        self
    }
    #[inline]
    pub fn global_alpha(mut self, global_alpha: f32) -> Self {
        self.global_alpha = global_alpha;
        self
    }
    #[inline]
    pub fn alpha_mode(mut self, alpha_mode: DisplayPlaneAlphaFlagsKHR) -> Self {
        self.alpha_mode = alpha_mode;
        self
    }
    #[inline]
    pub fn image_extent(mut self, image_extent: Extent2D) -> Self {
        self.image_extent = image_extent;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplayPresentInfoKHR.html>"]
pub struct DisplayPresentInfoKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub src_rect: Rect2D,
    pub dst_rect: Rect2D,
    pub persistent: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for DisplayPresentInfoKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            src_rect: Rect2D::default(),
            dst_rect: Rect2D::default(),
            persistent: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for DisplayPresentInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DISPLAY_PRESENT_INFO_KHR;
}
unsafe impl ExtendsPresentInfoKHR for DisplayPresentInfoKHR<'_> {}
impl<'a> DisplayPresentInfoKHR<'a> {
    #[inline]
    pub fn src_rect(mut self, src_rect: Rect2D) -> Self {
        self.src_rect = src_rect;
        self
    }
    #[inline]
    pub fn dst_rect(mut self, dst_rect: Rect2D) -> Self {
        self.dst_rect = dst_rect;
        self
    }
    #[inline]
    pub fn persistent(mut self, persistent: bool) -> Self {
        self.persistent = persistent.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSurfaceCapabilitiesKHR.html>"]
pub struct SurfaceCapabilitiesKHR {
    pub min_image_count: u32,
    pub max_image_count: u32,
    pub current_extent: Extent2D,
    pub min_image_extent: Extent2D,
    pub max_image_extent: Extent2D,
    pub max_image_array_layers: u32,
    pub supported_transforms: SurfaceTransformFlagsKHR,
    pub current_transform: SurfaceTransformFlagsKHR,
    pub supported_composite_alpha: CompositeAlphaFlagsKHR,
    pub supported_usage_flags: ImageUsageFlags,
}
impl SurfaceCapabilitiesKHR {
    #[inline]
    pub fn min_image_count(mut self, min_image_count: u32) -> Self {
        self.min_image_count = min_image_count;
        self
    }
    #[inline]
    pub fn max_image_count(mut self, max_image_count: u32) -> Self {
        self.max_image_count = max_image_count;
        self
    }
    #[inline]
    pub fn current_extent(mut self, current_extent: Extent2D) -> Self {
        self.current_extent = current_extent;
        self
    }
    #[inline]
    pub fn min_image_extent(mut self, min_image_extent: Extent2D) -> Self {
        self.min_image_extent = min_image_extent;
        self
    }
    #[inline]
    pub fn max_image_extent(mut self, max_image_extent: Extent2D) -> Self {
        self.max_image_extent = max_image_extent;
        self
    }
    #[inline]
    pub fn max_image_array_layers(mut self, max_image_array_layers: u32) -> Self {
        self.max_image_array_layers = max_image_array_layers;
        self
    }
    #[inline]
    pub fn supported_transforms(mut self, supported_transforms: SurfaceTransformFlagsKHR) -> Self {
        self.supported_transforms = supported_transforms;
        self
    }
    #[inline]
    pub fn current_transform(mut self, current_transform: SurfaceTransformFlagsKHR) -> Self {
        self.current_transform = current_transform;
        self
    }
    #[inline]
    pub fn supported_composite_alpha(
        mut self,
        supported_composite_alpha: CompositeAlphaFlagsKHR,
    ) -> Self {
        self.supported_composite_alpha = supported_composite_alpha;
        self
    }
    #[inline]
    pub fn supported_usage_flags(mut self, supported_usage_flags: ImageUsageFlags) -> Self {
        self.supported_usage_flags = supported_usage_flags;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAndroidSurfaceCreateInfoKHR.html>"]
pub struct AndroidSurfaceCreateInfoKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: AndroidSurfaceCreateFlagsKHR,
    pub window: *mut ANativeWindow,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for AndroidSurfaceCreateInfoKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: AndroidSurfaceCreateFlagsKHR::default(),
            window: ::std::ptr::null_mut(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for AndroidSurfaceCreateInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ANDROID_SURFACE_CREATE_INFO_KHR;
}
impl<'a> AndroidSurfaceCreateInfoKHR<'a> {
    #[inline]
    pub fn flags(mut self, flags: AndroidSurfaceCreateFlagsKHR) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn window(mut self, window: *mut ANativeWindow) -> Self {
        self.window = window;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkViSurfaceCreateInfoNN.html>"]
pub struct ViSurfaceCreateInfoNN<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: ViSurfaceCreateFlagsNN,
    pub window: *mut c_void,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for ViSurfaceCreateInfoNN<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: ViSurfaceCreateFlagsNN::default(),
            window: ::std::ptr::null_mut(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for ViSurfaceCreateInfoNN<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::VI_SURFACE_CREATE_INFO_NN;
}
impl<'a> ViSurfaceCreateInfoNN<'a> {
    #[inline]
    pub fn flags(mut self, flags: ViSurfaceCreateFlagsNN) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn window(mut self, window: *mut c_void) -> Self {
        self.window = window;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkWaylandSurfaceCreateInfoKHR.html>"]
pub struct WaylandSurfaceCreateInfoKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: WaylandSurfaceCreateFlagsKHR,
    pub display: *mut wl_display,
    pub surface: *mut wl_surface,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for WaylandSurfaceCreateInfoKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: WaylandSurfaceCreateFlagsKHR::default(),
            display: ::std::ptr::null_mut(),
            surface: ::std::ptr::null_mut(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for WaylandSurfaceCreateInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::WAYLAND_SURFACE_CREATE_INFO_KHR;
}
impl<'a> WaylandSurfaceCreateInfoKHR<'a> {
    #[inline]
    pub fn flags(mut self, flags: WaylandSurfaceCreateFlagsKHR) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn display(mut self, display: *mut wl_display) -> Self {
        self.display = display;
        self
    }
    #[inline]
    pub fn surface(mut self, surface: *mut wl_surface) -> Self {
        self.surface = surface;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkWin32SurfaceCreateInfoKHR.html>"]
pub struct Win32SurfaceCreateInfoKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: Win32SurfaceCreateFlagsKHR,
    pub hinstance: HINSTANCE,
    pub hwnd: HWND,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for Win32SurfaceCreateInfoKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: Win32SurfaceCreateFlagsKHR::default(),
            hinstance: unsafe { ::std::mem::zeroed() },
            hwnd: unsafe { ::std::mem::zeroed() },
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for Win32SurfaceCreateInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::WIN32_SURFACE_CREATE_INFO_KHR;
}
impl<'a> Win32SurfaceCreateInfoKHR<'a> {
    #[inline]
    pub fn flags(mut self, flags: Win32SurfaceCreateFlagsKHR) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn hinstance(mut self, hinstance: HINSTANCE) -> Self {
        self.hinstance = hinstance;
        self
    }
    #[inline]
    pub fn hwnd(mut self, hwnd: HWND) -> Self {
        self.hwnd = hwnd;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkXlibSurfaceCreateInfoKHR.html>"]
pub struct XlibSurfaceCreateInfoKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: XlibSurfaceCreateFlagsKHR,
    pub dpy: *mut Display,
    pub window: Window,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for XlibSurfaceCreateInfoKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: XlibSurfaceCreateFlagsKHR::default(),
            dpy: ::std::ptr::null_mut(),
            window: Window::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for XlibSurfaceCreateInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::XLIB_SURFACE_CREATE_INFO_KHR;
}
impl<'a> XlibSurfaceCreateInfoKHR<'a> {
    #[inline]
    pub fn flags(mut self, flags: XlibSurfaceCreateFlagsKHR) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn dpy(mut self, dpy: *mut Display) -> Self {
        self.dpy = dpy;
        self
    }
    #[inline]
    pub fn window(mut self, window: Window) -> Self {
        self.window = window;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkXcbSurfaceCreateInfoKHR.html>"]
pub struct XcbSurfaceCreateInfoKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: XcbSurfaceCreateFlagsKHR,
    pub connection: *mut xcb_connection_t,
    pub window: xcb_window_t,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for XcbSurfaceCreateInfoKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: XcbSurfaceCreateFlagsKHR::default(),
            connection: ::std::ptr::null_mut(),
            window: xcb_window_t::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for XcbSurfaceCreateInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::XCB_SURFACE_CREATE_INFO_KHR;
}
impl<'a> XcbSurfaceCreateInfoKHR<'a> {
    #[inline]
    pub fn flags(mut self, flags: XcbSurfaceCreateFlagsKHR) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn connection(mut self, connection: *mut xcb_connection_t) -> Self {
        self.connection = connection;
        self
    }
    #[inline]
    pub fn window(mut self, window: xcb_window_t) -> Self {
        self.window = window;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDirectFBSurfaceCreateInfoEXT.html>"]
pub struct DirectFBSurfaceCreateInfoEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: DirectFBSurfaceCreateFlagsEXT,
    pub dfb: *mut IDirectFB,
    pub surface: *mut IDirectFBSurface,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for DirectFBSurfaceCreateInfoEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: DirectFBSurfaceCreateFlagsEXT::default(),
            dfb: ::std::ptr::null_mut(),
            surface: ::std::ptr::null_mut(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for DirectFBSurfaceCreateInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DIRECTFB_SURFACE_CREATE_INFO_EXT;
}
impl<'a> DirectFBSurfaceCreateInfoEXT<'a> {
    #[inline]
    pub fn flags(mut self, flags: DirectFBSurfaceCreateFlagsEXT) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn dfb(mut self, dfb: *mut IDirectFB) -> Self {
        self.dfb = dfb;
        self
    }
    #[inline]
    pub fn surface(mut self, surface: *mut IDirectFBSurface) -> Self {
        self.surface = surface;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImagePipeSurfaceCreateInfoFUCHSIA.html>"]
pub struct ImagePipeSurfaceCreateInfoFUCHSIA<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: ImagePipeSurfaceCreateFlagsFUCHSIA,
    pub image_pipe_handle: zx_handle_t,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for ImagePipeSurfaceCreateInfoFUCHSIA<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: ImagePipeSurfaceCreateFlagsFUCHSIA::default(),
            image_pipe_handle: zx_handle_t::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for ImagePipeSurfaceCreateInfoFUCHSIA<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA;
}
impl<'a> ImagePipeSurfaceCreateInfoFUCHSIA<'a> {
    #[inline]
    pub fn flags(mut self, flags: ImagePipeSurfaceCreateFlagsFUCHSIA) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn image_pipe_handle(mut self, image_pipe_handle: zx_handle_t) -> Self {
        self.image_pipe_handle = image_pipe_handle;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkStreamDescriptorSurfaceCreateInfoGGP.html>"]
pub struct StreamDescriptorSurfaceCreateInfoGGP<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: StreamDescriptorSurfaceCreateFlagsGGP,
    pub stream_descriptor: GgpStreamDescriptor,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for StreamDescriptorSurfaceCreateInfoGGP<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: StreamDescriptorSurfaceCreateFlagsGGP::default(),
            stream_descriptor: GgpStreamDescriptor::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for StreamDescriptorSurfaceCreateInfoGGP<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::STREAM_DESCRIPTOR_SURFACE_CREATE_INFO_GGP;
}
impl<'a> StreamDescriptorSurfaceCreateInfoGGP<'a> {
    #[inline]
    pub fn flags(mut self, flags: StreamDescriptorSurfaceCreateFlagsGGP) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn stream_descriptor(mut self, stream_descriptor: GgpStreamDescriptor) -> Self {
        self.stream_descriptor = stream_descriptor;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkScreenSurfaceCreateInfoQNX.html>"]
pub struct ScreenSurfaceCreateInfoQNX<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: ScreenSurfaceCreateFlagsQNX,
    pub context: *mut _screen_context,
    pub window: *mut _screen_window,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for ScreenSurfaceCreateInfoQNX<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: ScreenSurfaceCreateFlagsQNX::default(),
            context: ::std::ptr::null_mut(),
            window: ::std::ptr::null_mut(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for ScreenSurfaceCreateInfoQNX<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::SCREEN_SURFACE_CREATE_INFO_QNX;
}
impl<'a> ScreenSurfaceCreateInfoQNX<'a> {
    #[inline]
    pub fn flags(mut self, flags: ScreenSurfaceCreateFlagsQNX) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn context(mut self, context: &'a mut _screen_context) -> Self {
        self.context = context;
        self
    }
    #[inline]
    pub fn window(mut self, window: &'a mut _screen_window) -> Self {
        self.window = window;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default, PartialEq, Eq, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSurfaceFormatKHR.html>"]
pub struct SurfaceFormatKHR {
    pub format: Format,
    pub color_space: ColorSpaceKHR,
}
impl SurfaceFormatKHR {
    #[inline]
    pub fn format(mut self, format: Format) -> Self {
        self.format = format;
        self
    }
    #[inline]
    pub fn color_space(mut self, color_space: ColorSpaceKHR) -> Self {
        self.color_space = color_space;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSwapchainCreateInfoKHR.html>"]
pub struct SwapchainCreateInfoKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: SwapchainCreateFlagsKHR,
    pub surface: SurfaceKHR,
    pub min_image_count: u32,
    pub image_format: Format,
    pub image_color_space: ColorSpaceKHR,
    pub image_extent: Extent2D,
    pub image_array_layers: u32,
    pub image_usage: ImageUsageFlags,
    pub image_sharing_mode: SharingMode,
    pub queue_family_index_count: u32,
    pub p_queue_family_indices: *const u32,
    pub pre_transform: SurfaceTransformFlagsKHR,
    pub composite_alpha: CompositeAlphaFlagsKHR,
    pub present_mode: PresentModeKHR,
    pub clipped: Bool32,
    pub old_swapchain: SwapchainKHR,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for SwapchainCreateInfoKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: SwapchainCreateFlagsKHR::default(),
            surface: SurfaceKHR::default(),
            min_image_count: u32::default(),
            image_format: Format::default(),
            image_color_space: ColorSpaceKHR::default(),
            image_extent: Extent2D::default(),
            image_array_layers: u32::default(),
            image_usage: ImageUsageFlags::default(),
            image_sharing_mode: SharingMode::default(),
            queue_family_index_count: u32::default(),
            p_queue_family_indices: ::std::ptr::null(),
            pre_transform: SurfaceTransformFlagsKHR::default(),
            composite_alpha: CompositeAlphaFlagsKHR::default(),
            present_mode: PresentModeKHR::default(),
            clipped: Bool32::default(),
            old_swapchain: SwapchainKHR::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for SwapchainCreateInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::SWAPCHAIN_CREATE_INFO_KHR;
}
pub unsafe trait ExtendsSwapchainCreateInfoKHR {}
impl<'a> SwapchainCreateInfoKHR<'a> {
    #[inline]
    pub fn flags(mut self, flags: SwapchainCreateFlagsKHR) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn surface(mut self, surface: SurfaceKHR) -> Self {
        self.surface = surface;
        self
    }
    #[inline]
    pub fn min_image_count(mut self, min_image_count: u32) -> Self {
        self.min_image_count = min_image_count;
        self
    }
    #[inline]
    pub fn image_format(mut self, image_format: Format) -> Self {
        self.image_format = image_format;
        self
    }
    #[inline]
    pub fn image_color_space(mut self, image_color_space: ColorSpaceKHR) -> Self {
        self.image_color_space = image_color_space;
        self
    }
    #[inline]
    pub fn image_extent(mut self, image_extent: Extent2D) -> Self {
        self.image_extent = image_extent;
        self
    }
    #[inline]
    pub fn image_array_layers(mut self, image_array_layers: u32) -> Self {
        self.image_array_layers = image_array_layers;
        self
    }
    #[inline]
    pub fn image_usage(mut self, image_usage: ImageUsageFlags) -> Self {
        self.image_usage = image_usage;
        self
    }
    #[inline]
    pub fn image_sharing_mode(mut self, image_sharing_mode: SharingMode) -> Self {
        self.image_sharing_mode = image_sharing_mode;
        self
    }
    #[inline]
    pub fn queue_family_indices(mut self, queue_family_indices: &'a [u32]) -> Self {
        self.queue_family_index_count = queue_family_indices.len() as _;
        self.p_queue_family_indices = queue_family_indices.as_ptr();
        self
    }
    #[inline]
    pub fn pre_transform(mut self, pre_transform: SurfaceTransformFlagsKHR) -> Self {
        self.pre_transform = pre_transform;
        self
    }
    #[inline]
    pub fn composite_alpha(mut self, composite_alpha: CompositeAlphaFlagsKHR) -> Self {
        self.composite_alpha = composite_alpha;
        self
    }
    #[inline]
    pub fn present_mode(mut self, present_mode: PresentModeKHR) -> Self {
        self.present_mode = present_mode;
        self
    }
    #[inline]
    pub fn clipped(mut self, clipped: bool) -> Self {
        self.clipped = clipped.into();
        self
    }
    #[inline]
    pub fn old_swapchain(mut self, old_swapchain: SwapchainKHR) -> Self {
        self.old_swapchain = old_swapchain;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `x.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsSwapchainCreateInfoKHR>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.p_next as _;
            self.p_next = next_ptr;
        }
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPresentInfoKHR.html>"]
pub struct PresentInfoKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub wait_semaphore_count: u32,
    pub p_wait_semaphores: *const Semaphore,
    pub swapchain_count: u32,
    pub p_swapchains: *const SwapchainKHR,
    pub p_image_indices: *const u32,
    pub p_results: *mut Result,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PresentInfoKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            wait_semaphore_count: u32::default(),
            p_wait_semaphores: ::std::ptr::null(),
            swapchain_count: u32::default(),
            p_swapchains: ::std::ptr::null(),
            p_image_indices: ::std::ptr::null(),
            p_results: ::std::ptr::null_mut(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PresentInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PRESENT_INFO_KHR;
}
pub unsafe trait ExtendsPresentInfoKHR {}
impl<'a> PresentInfoKHR<'a> {
    #[inline]
    pub fn wait_semaphores(mut self, wait_semaphores: &'a [Semaphore]) -> Self {
        self.wait_semaphore_count = wait_semaphores.len() as _;
        self.p_wait_semaphores = wait_semaphores.as_ptr();
        self
    }
    #[inline]
    pub fn swapchains(mut self, swapchains: &'a [SwapchainKHR]) -> Self {
        self.swapchain_count = swapchains.len() as _;
        self.p_swapchains = swapchains.as_ptr();
        self
    }
    #[inline]
    pub fn image_indices(mut self, image_indices: &'a [u32]) -> Self {
        self.swapchain_count = image_indices.len() as _;
        self.p_image_indices = image_indices.as_ptr();
        self
    }
    #[inline]
    pub fn results(mut self, results: &'a mut [Result]) -> Self {
        self.swapchain_count = results.len() as _;
        self.p_results = results.as_mut_ptr();
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `x.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsPresentInfoKHR>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.p_next as _;
            self.p_next = next_ptr;
        }
        self
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDebugReportCallbackCreateInfoEXT.html>"]
pub struct DebugReportCallbackCreateInfoEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: DebugReportFlagsEXT,
    pub pfn_callback: PFN_vkDebugReportCallbackEXT,
    pub p_user_data: *mut c_void,
    pub _marker: PhantomData<&'a ()>,
}
#[cfg(feature = "debug")]
impl fmt::Debug for DebugReportCallbackCreateInfoEXT<'_> {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DebugReportCallbackCreateInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("pfn_callback", &(self.pfn_callback.map(|x| x as *const ())))
            .field("p_user_data", &self.p_user_data)
            .finish()
    }
}
impl ::std::default::Default for DebugReportCallbackCreateInfoEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: DebugReportFlagsEXT::default(),
            pfn_callback: PFN_vkDebugReportCallbackEXT::default(),
            p_user_data: ::std::ptr::null_mut(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for DebugReportCallbackCreateInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT;
}
unsafe impl ExtendsInstanceCreateInfo for DebugReportCallbackCreateInfoEXT<'_> {}
impl<'a> DebugReportCallbackCreateInfoEXT<'a> {
    #[inline]
    pub fn flags(mut self, flags: DebugReportFlagsEXT) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn pfn_callback(mut self, pfn_callback: PFN_vkDebugReportCallbackEXT) -> Self {
        self.pfn_callback = pfn_callback;
        self
    }
    #[inline]
    pub fn user_data(mut self, user_data: *mut c_void) -> Self {
        self.p_user_data = user_data;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkValidationFlagsEXT.html>"]
pub struct ValidationFlagsEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub disabled_validation_check_count: u32,
    pub p_disabled_validation_checks: *const ValidationCheckEXT,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for ValidationFlagsEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            disabled_validation_check_count: u32::default(),
            p_disabled_validation_checks: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for ValidationFlagsEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::VALIDATION_FLAGS_EXT;
}
unsafe impl ExtendsInstanceCreateInfo for ValidationFlagsEXT<'_> {}
impl<'a> ValidationFlagsEXT<'a> {
    #[inline]
    pub fn disabled_validation_checks(
        mut self,
        disabled_validation_checks: &'a [ValidationCheckEXT],
    ) -> Self {
        self.disabled_validation_check_count = disabled_validation_checks.len() as _;
        self.p_disabled_validation_checks = disabled_validation_checks.as_ptr();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkValidationFeaturesEXT.html>"]
pub struct ValidationFeaturesEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub enabled_validation_feature_count: u32,
    pub p_enabled_validation_features: *const ValidationFeatureEnableEXT,
    pub disabled_validation_feature_count: u32,
    pub p_disabled_validation_features: *const ValidationFeatureDisableEXT,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for ValidationFeaturesEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            enabled_validation_feature_count: u32::default(),
            p_enabled_validation_features: ::std::ptr::null(),
            disabled_validation_feature_count: u32::default(),
            p_disabled_validation_features: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for ValidationFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::VALIDATION_FEATURES_EXT;
}
unsafe impl ExtendsInstanceCreateInfo for ValidationFeaturesEXT<'_> {}
impl<'a> ValidationFeaturesEXT<'a> {
    #[inline]
    pub fn enabled_validation_features(
        mut self,
        enabled_validation_features: &'a [ValidationFeatureEnableEXT],
    ) -> Self {
        self.enabled_validation_feature_count = enabled_validation_features.len() as _;
        self.p_enabled_validation_features = enabled_validation_features.as_ptr();
        self
    }
    #[inline]
    pub fn disabled_validation_features(
        mut self,
        disabled_validation_features: &'a [ValidationFeatureDisableEXT],
    ) -> Self {
        self.disabled_validation_feature_count = disabled_validation_features.len() as _;
        self.p_disabled_validation_features = disabled_validation_features.as_ptr();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineRasterizationStateRasterizationOrderAMD.html>"]
pub struct PipelineRasterizationStateRasterizationOrderAMD<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub rasterization_order: RasterizationOrderAMD,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PipelineRasterizationStateRasterizationOrderAMD<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            rasterization_order: RasterizationOrderAMD::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PipelineRasterizationStateRasterizationOrderAMD<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD;
}
unsafe impl ExtendsPipelineRasterizationStateCreateInfo
    for PipelineRasterizationStateRasterizationOrderAMD<'_>
{
}
impl<'a> PipelineRasterizationStateRasterizationOrderAMD<'a> {
    #[inline]
    pub fn rasterization_order(mut self, rasterization_order: RasterizationOrderAMD) -> Self {
        self.rasterization_order = rasterization_order;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDebugMarkerObjectNameInfoEXT.html>"]
pub struct DebugMarkerObjectNameInfoEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub object_type: DebugReportObjectTypeEXT,
    pub object: u64,
    pub p_object_name: *const c_char,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for DebugMarkerObjectNameInfoEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            object_type: DebugReportObjectTypeEXT::default(),
            object: u64::default(),
            p_object_name: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for DebugMarkerObjectNameInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DEBUG_MARKER_OBJECT_NAME_INFO_EXT;
}
impl<'a> DebugMarkerObjectNameInfoEXT<'a> {
    #[inline]
    pub fn object_type(mut self, object_type: DebugReportObjectTypeEXT) -> Self {
        self.object_type = object_type;
        self
    }
    #[inline]
    pub fn object(mut self, object: u64) -> Self {
        self.object = object;
        self
    }
    #[inline]
    pub fn object_name(mut self, object_name: &'a ::std::ffi::CStr) -> Self {
        self.p_object_name = object_name.as_ptr();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDebugMarkerObjectTagInfoEXT.html>"]
pub struct DebugMarkerObjectTagInfoEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub object_type: DebugReportObjectTypeEXT,
    pub object: u64,
    pub tag_name: u64,
    pub tag_size: usize,
    pub p_tag: *const c_void,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for DebugMarkerObjectTagInfoEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            object_type: DebugReportObjectTypeEXT::default(),
            object: u64::default(),
            tag_name: u64::default(),
            tag_size: usize::default(),
            p_tag: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for DebugMarkerObjectTagInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DEBUG_MARKER_OBJECT_TAG_INFO_EXT;
}
impl<'a> DebugMarkerObjectTagInfoEXT<'a> {
    #[inline]
    pub fn object_type(mut self, object_type: DebugReportObjectTypeEXT) -> Self {
        self.object_type = object_type;
        self
    }
    #[inline]
    pub fn object(mut self, object: u64) -> Self {
        self.object = object;
        self
    }
    #[inline]
    pub fn tag_name(mut self, tag_name: u64) -> Self {
        self.tag_name = tag_name;
        self
    }
    #[inline]
    pub fn tag(mut self, tag: &'a [u8]) -> Self {
        self.tag_size = tag.len();
        self.p_tag = tag.as_ptr() as *const c_void;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDebugMarkerMarkerInfoEXT.html>"]
pub struct DebugMarkerMarkerInfoEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub p_marker_name: *const c_char,
    pub color: [f32; 4],
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for DebugMarkerMarkerInfoEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            p_marker_name: ::std::ptr::null(),
            color: unsafe { ::std::mem::zeroed() },
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for DebugMarkerMarkerInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DEBUG_MARKER_MARKER_INFO_EXT;
}
impl<'a> DebugMarkerMarkerInfoEXT<'a> {
    #[inline]
    pub fn marker_name(mut self, marker_name: &'a ::std::ffi::CStr) -> Self {
        self.p_marker_name = marker_name.as_ptr();
        self
    }
    #[inline]
    pub fn color(mut self, color: [f32; 4]) -> Self {
        self.color = color;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDedicatedAllocationImageCreateInfoNV.html>"]
pub struct DedicatedAllocationImageCreateInfoNV<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub dedicated_allocation: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for DedicatedAllocationImageCreateInfoNV<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            dedicated_allocation: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for DedicatedAllocationImageCreateInfoNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV;
}
unsafe impl ExtendsImageCreateInfo for DedicatedAllocationImageCreateInfoNV<'_> {}
impl<'a> DedicatedAllocationImageCreateInfoNV<'a> {
    #[inline]
    pub fn dedicated_allocation(mut self, dedicated_allocation: bool) -> Self {
        self.dedicated_allocation = dedicated_allocation.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDedicatedAllocationBufferCreateInfoNV.html>"]
pub struct DedicatedAllocationBufferCreateInfoNV<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub dedicated_allocation: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for DedicatedAllocationBufferCreateInfoNV<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            dedicated_allocation: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for DedicatedAllocationBufferCreateInfoNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV;
}
unsafe impl ExtendsBufferCreateInfo for DedicatedAllocationBufferCreateInfoNV<'_> {}
impl<'a> DedicatedAllocationBufferCreateInfoNV<'a> {
    #[inline]
    pub fn dedicated_allocation(mut self, dedicated_allocation: bool) -> Self {
        self.dedicated_allocation = dedicated_allocation.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDedicatedAllocationMemoryAllocateInfoNV.html>"]
pub struct DedicatedAllocationMemoryAllocateInfoNV<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub image: Image,
    pub buffer: Buffer,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for DedicatedAllocationMemoryAllocateInfoNV<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            image: Image::default(),
            buffer: Buffer::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for DedicatedAllocationMemoryAllocateInfoNV<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV;
}
unsafe impl ExtendsMemoryAllocateInfo for DedicatedAllocationMemoryAllocateInfoNV<'_> {}
impl<'a> DedicatedAllocationMemoryAllocateInfoNV<'a> {
    #[inline]
    pub fn image(mut self, image: Image) -> Self {
        self.image = image;
        self
    }
    #[inline]
    pub fn buffer(mut self, buffer: Buffer) -> Self {
        self.buffer = buffer;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExternalImageFormatPropertiesNV.html>"]
pub struct ExternalImageFormatPropertiesNV {
    pub image_format_properties: ImageFormatProperties,
    pub external_memory_features: ExternalMemoryFeatureFlagsNV,
    pub export_from_imported_handle_types: ExternalMemoryHandleTypeFlagsNV,
    pub compatible_handle_types: ExternalMemoryHandleTypeFlagsNV,
}
impl ExternalImageFormatPropertiesNV {
    #[inline]
    pub fn image_format_properties(
        mut self,
        image_format_properties: ImageFormatProperties,
    ) -> Self {
        self.image_format_properties = image_format_properties;
        self
    }
    #[inline]
    pub fn external_memory_features(
        mut self,
        external_memory_features: ExternalMemoryFeatureFlagsNV,
    ) -> Self {
        self.external_memory_features = external_memory_features;
        self
    }
    #[inline]
    pub fn export_from_imported_handle_types(
        mut self,
        export_from_imported_handle_types: ExternalMemoryHandleTypeFlagsNV,
    ) -> Self {
        self.export_from_imported_handle_types = export_from_imported_handle_types;
        self
    }
    #[inline]
    pub fn compatible_handle_types(
        mut self,
        compatible_handle_types: ExternalMemoryHandleTypeFlagsNV,
    ) -> Self {
        self.compatible_handle_types = compatible_handle_types;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExternalMemoryImageCreateInfoNV.html>"]
pub struct ExternalMemoryImageCreateInfoNV<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub handle_types: ExternalMemoryHandleTypeFlagsNV,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for ExternalMemoryImageCreateInfoNV<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            handle_types: ExternalMemoryHandleTypeFlagsNV::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for ExternalMemoryImageCreateInfoNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV;
}
unsafe impl ExtendsImageCreateInfo for ExternalMemoryImageCreateInfoNV<'_> {}
impl<'a> ExternalMemoryImageCreateInfoNV<'a> {
    #[inline]
    pub fn handle_types(mut self, handle_types: ExternalMemoryHandleTypeFlagsNV) -> Self {
        self.handle_types = handle_types;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExportMemoryAllocateInfoNV.html>"]
pub struct ExportMemoryAllocateInfoNV<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub handle_types: ExternalMemoryHandleTypeFlagsNV,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for ExportMemoryAllocateInfoNV<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            handle_types: ExternalMemoryHandleTypeFlagsNV::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for ExportMemoryAllocateInfoNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::EXPORT_MEMORY_ALLOCATE_INFO_NV;
}
unsafe impl ExtendsMemoryAllocateInfo for ExportMemoryAllocateInfoNV<'_> {}
impl<'a> ExportMemoryAllocateInfoNV<'a> {
    #[inline]
    pub fn handle_types(mut self, handle_types: ExternalMemoryHandleTypeFlagsNV) -> Self {
        self.handle_types = handle_types;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImportMemoryWin32HandleInfoNV.html>"]
pub struct ImportMemoryWin32HandleInfoNV<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub handle_type: ExternalMemoryHandleTypeFlagsNV,
    pub handle: HANDLE,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for ImportMemoryWin32HandleInfoNV<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            handle_type: ExternalMemoryHandleTypeFlagsNV::default(),
            handle: unsafe { ::std::mem::zeroed() },
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for ImportMemoryWin32HandleInfoNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::IMPORT_MEMORY_WIN32_HANDLE_INFO_NV;
}
unsafe impl ExtendsMemoryAllocateInfo for ImportMemoryWin32HandleInfoNV<'_> {}
impl<'a> ImportMemoryWin32HandleInfoNV<'a> {
    #[inline]
    pub fn handle_type(mut self, handle_type: ExternalMemoryHandleTypeFlagsNV) -> Self {
        self.handle_type = handle_type;
        self
    }
    #[inline]
    pub fn handle(mut self, handle: HANDLE) -> Self {
        self.handle = handle;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExportMemoryWin32HandleInfoNV.html>"]
pub struct ExportMemoryWin32HandleInfoNV<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub p_attributes: *const SECURITY_ATTRIBUTES,
    pub dw_access: DWORD,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for ExportMemoryWin32HandleInfoNV<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            p_attributes: ::std::ptr::null(),
            dw_access: DWORD::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for ExportMemoryWin32HandleInfoNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::EXPORT_MEMORY_WIN32_HANDLE_INFO_NV;
}
unsafe impl ExtendsMemoryAllocateInfo for ExportMemoryWin32HandleInfoNV<'_> {}
impl<'a> ExportMemoryWin32HandleInfoNV<'a> {
    #[inline]
    pub fn attributes(mut self, attributes: &'a SECURITY_ATTRIBUTES) -> Self {
        self.p_attributes = attributes;
        self
    }
    #[inline]
    pub fn dw_access(mut self, dw_access: DWORD) -> Self {
        self.dw_access = dw_access;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkWin32KeyedMutexAcquireReleaseInfoNV.html>"]
pub struct Win32KeyedMutexAcquireReleaseInfoNV<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub acquire_count: u32,
    pub p_acquire_syncs: *const DeviceMemory,
    pub p_acquire_keys: *const u64,
    pub p_acquire_timeout_milliseconds: *const u32,
    pub release_count: u32,
    pub p_release_syncs: *const DeviceMemory,
    pub p_release_keys: *const u64,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for Win32KeyedMutexAcquireReleaseInfoNV<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            acquire_count: u32::default(),
            p_acquire_syncs: ::std::ptr::null(),
            p_acquire_keys: ::std::ptr::null(),
            p_acquire_timeout_milliseconds: ::std::ptr::null(),
            release_count: u32::default(),
            p_release_syncs: ::std::ptr::null(),
            p_release_keys: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for Win32KeyedMutexAcquireReleaseInfoNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV;
}
unsafe impl ExtendsSubmitInfo for Win32KeyedMutexAcquireReleaseInfoNV<'_> {}
unsafe impl ExtendsSubmitInfo2 for Win32KeyedMutexAcquireReleaseInfoNV<'_> {}
impl<'a> Win32KeyedMutexAcquireReleaseInfoNV<'a> {
    #[inline]
    pub fn acquire_syncs(mut self, acquire_syncs: &'a [DeviceMemory]) -> Self {
        self.acquire_count = acquire_syncs.len() as _;
        self.p_acquire_syncs = acquire_syncs.as_ptr();
        self
    }
    #[inline]
    pub fn acquire_keys(mut self, acquire_keys: &'a [u64]) -> Self {
        self.acquire_count = acquire_keys.len() as _;
        self.p_acquire_keys = acquire_keys.as_ptr();
        self
    }
    #[inline]
    pub fn acquire_timeout_milliseconds(mut self, acquire_timeout_milliseconds: &'a [u32]) -> Self {
        self.acquire_count = acquire_timeout_milliseconds.len() as _;
        self.p_acquire_timeout_milliseconds = acquire_timeout_milliseconds.as_ptr();
        self
    }
    #[inline]
    pub fn release_syncs(mut self, release_syncs: &'a [DeviceMemory]) -> Self {
        self.release_count = release_syncs.len() as _;
        self.p_release_syncs = release_syncs.as_ptr();
        self
    }
    #[inline]
    pub fn release_keys(mut self, release_keys: &'a [u64]) -> Self {
        self.release_count = release_keys.len() as _;
        self.p_release_keys = release_keys.as_ptr();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV.html>"]
pub struct PhysicalDeviceDeviceGeneratedCommandsFeaturesNV<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub device_generated_commands: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceDeviceGeneratedCommandsFeaturesNV<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            device_generated_commands: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceDeviceGeneratedCommandsFeaturesNV<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV;
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceDeviceGeneratedCommandsFeaturesNV<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceDeviceGeneratedCommandsFeaturesNV<'_> {}
impl<'a> PhysicalDeviceDeviceGeneratedCommandsFeaturesNV<'a> {
    #[inline]
    pub fn device_generated_commands(mut self, device_generated_commands: bool) -> Self {
        self.device_generated_commands = device_generated_commands.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDevicePrivateDataCreateInfo.html>"]
pub struct DevicePrivateDataCreateInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub private_data_slot_request_count: u32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for DevicePrivateDataCreateInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            private_data_slot_request_count: u32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for DevicePrivateDataCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DEVICE_PRIVATE_DATA_CREATE_INFO;
}
unsafe impl ExtendsDeviceCreateInfo for DevicePrivateDataCreateInfo<'_> {}
impl<'a> DevicePrivateDataCreateInfo<'a> {
    #[inline]
    pub fn private_data_slot_request_count(mut self, private_data_slot_request_count: u32) -> Self {
        self.private_data_slot_request_count = private_data_slot_request_count;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPrivateDataSlotCreateInfo.html>"]
pub struct PrivateDataSlotCreateInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: PrivateDataSlotCreateFlags,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PrivateDataSlotCreateInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: PrivateDataSlotCreateFlags::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PrivateDataSlotCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PRIVATE_DATA_SLOT_CREATE_INFO;
}
impl<'a> PrivateDataSlotCreateInfo<'a> {
    #[inline]
    pub fn flags(mut self, flags: PrivateDataSlotCreateFlags) -> Self {
        self.flags = flags;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePrivateDataFeatures.html>"]
pub struct PhysicalDevicePrivateDataFeatures<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub private_data: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDevicePrivateDataFeatures<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            private_data: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDevicePrivateDataFeatures<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES;
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDevicePrivateDataFeatures<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDevicePrivateDataFeatures<'_> {}
impl<'a> PhysicalDevicePrivateDataFeatures<'a> {
    #[inline]
    pub fn private_data(mut self, private_data: bool) -> Self {
        self.private_data = private_data.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV.html>"]
pub struct PhysicalDeviceDeviceGeneratedCommandsPropertiesNV<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub max_graphics_shader_group_count: u32,
    pub max_indirect_sequence_count: u32,
    pub max_indirect_commands_token_count: u32,
    pub max_indirect_commands_stream_count: u32,
    pub max_indirect_commands_token_offset: u32,
    pub max_indirect_commands_stream_stride: u32,
    pub min_sequences_count_buffer_offset_alignment: u32,
    pub min_sequences_index_buffer_offset_alignment: u32,
    pub min_indirect_commands_buffer_offset_alignment: u32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceDeviceGeneratedCommandsPropertiesNV<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            max_graphics_shader_group_count: u32::default(),
            max_indirect_sequence_count: u32::default(),
            max_indirect_commands_token_count: u32::default(),
            max_indirect_commands_stream_count: u32::default(),
            max_indirect_commands_token_offset: u32::default(),
            max_indirect_commands_stream_stride: u32::default(),
            min_sequences_count_buffer_offset_alignment: u32::default(),
            min_sequences_index_buffer_offset_alignment: u32::default(),
            min_indirect_commands_buffer_offset_alignment: u32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceDeviceGeneratedCommandsPropertiesNV<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV;
}
unsafe impl ExtendsPhysicalDeviceProperties2
    for PhysicalDeviceDeviceGeneratedCommandsPropertiesNV<'_>
{
}
impl<'a> PhysicalDeviceDeviceGeneratedCommandsPropertiesNV<'a> {
    #[inline]
    pub fn max_graphics_shader_group_count(mut self, max_graphics_shader_group_count: u32) -> Self {
        self.max_graphics_shader_group_count = max_graphics_shader_group_count;
        self
    }
    #[inline]
    pub fn max_indirect_sequence_count(mut self, max_indirect_sequence_count: u32) -> Self {
        self.max_indirect_sequence_count = max_indirect_sequence_count;
        self
    }
    #[inline]
    pub fn max_indirect_commands_token_count(
        mut self,
        max_indirect_commands_token_count: u32,
    ) -> Self {
        self.max_indirect_commands_token_count = max_indirect_commands_token_count;
        self
    }
    #[inline]
    pub fn max_indirect_commands_stream_count(
        mut self,
        max_indirect_commands_stream_count: u32,
    ) -> Self {
        self.max_indirect_commands_stream_count = max_indirect_commands_stream_count;
        self
    }
    #[inline]
    pub fn max_indirect_commands_token_offset(
        mut self,
        max_indirect_commands_token_offset: u32,
    ) -> Self {
        self.max_indirect_commands_token_offset = max_indirect_commands_token_offset;
        self
    }
    #[inline]
    pub fn max_indirect_commands_stream_stride(
        mut self,
        max_indirect_commands_stream_stride: u32,
    ) -> Self {
        self.max_indirect_commands_stream_stride = max_indirect_commands_stream_stride;
        self
    }
    #[inline]
    pub fn min_sequences_count_buffer_offset_alignment(
        mut self,
        min_sequences_count_buffer_offset_alignment: u32,
    ) -> Self {
        self.min_sequences_count_buffer_offset_alignment =
            min_sequences_count_buffer_offset_alignment;
        self
    }
    #[inline]
    pub fn min_sequences_index_buffer_offset_alignment(
        mut self,
        min_sequences_index_buffer_offset_alignment: u32,
    ) -> Self {
        self.min_sequences_index_buffer_offset_alignment =
            min_sequences_index_buffer_offset_alignment;
        self
    }
    #[inline]
    pub fn min_indirect_commands_buffer_offset_alignment(
        mut self,
        min_indirect_commands_buffer_offset_alignment: u32,
    ) -> Self {
        self.min_indirect_commands_buffer_offset_alignment =
            min_indirect_commands_buffer_offset_alignment;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMultiDrawPropertiesEXT.html>"]
pub struct PhysicalDeviceMultiDrawPropertiesEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub max_multi_draw_count: u32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceMultiDrawPropertiesEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            max_multi_draw_count: u32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceMultiDrawPropertiesEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT;
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceMultiDrawPropertiesEXT<'_> {}
impl<'a> PhysicalDeviceMultiDrawPropertiesEXT<'a> {
    #[inline]
    pub fn max_multi_draw_count(mut self, max_multi_draw_count: u32) -> Self {
        self.max_multi_draw_count = max_multi_draw_count;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkGraphicsShaderGroupCreateInfoNV.html>"]
pub struct GraphicsShaderGroupCreateInfoNV<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub stage_count: u32,
    pub p_stages: *const PipelineShaderStageCreateInfo<'a>,
    pub p_vertex_input_state: *const PipelineVertexInputStateCreateInfo<'a>,
    pub p_tessellation_state: *const PipelineTessellationStateCreateInfo<'a>,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for GraphicsShaderGroupCreateInfoNV<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            stage_count: u32::default(),
            p_stages: ::std::ptr::null(),
            p_vertex_input_state: ::std::ptr::null(),
            p_tessellation_state: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for GraphicsShaderGroupCreateInfoNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::GRAPHICS_SHADER_GROUP_CREATE_INFO_NV;
}
impl<'a> GraphicsShaderGroupCreateInfoNV<'a> {
    #[inline]
    pub fn stages(mut self, stages: &'a [PipelineShaderStageCreateInfo]) -> Self {
        self.stage_count = stages.len() as _;
        self.p_stages = stages.as_ptr();
        self
    }
    #[inline]
    pub fn vertex_input_state(
        mut self,
        vertex_input_state: &'a PipelineVertexInputStateCreateInfo<'a>,
    ) -> Self {
        self.p_vertex_input_state = vertex_input_state;
        self
    }
    #[inline]
    pub fn tessellation_state(
        mut self,
        tessellation_state: &'a PipelineTessellationStateCreateInfo<'a>,
    ) -> Self {
        self.p_tessellation_state = tessellation_state;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkGraphicsPipelineShaderGroupsCreateInfoNV.html>"]
pub struct GraphicsPipelineShaderGroupsCreateInfoNV<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub group_count: u32,
    pub p_groups: *const GraphicsShaderGroupCreateInfoNV<'a>,
    pub pipeline_count: u32,
    pub p_pipelines: *const Pipeline,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for GraphicsPipelineShaderGroupsCreateInfoNV<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            group_count: u32::default(),
            p_groups: ::std::ptr::null(),
            pipeline_count: u32::default(),
            p_pipelines: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for GraphicsPipelineShaderGroupsCreateInfoNV<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV;
}
unsafe impl ExtendsGraphicsPipelineCreateInfo for GraphicsPipelineShaderGroupsCreateInfoNV<'_> {}
impl<'a> GraphicsPipelineShaderGroupsCreateInfoNV<'a> {
    #[inline]
    pub fn groups(mut self, groups: &'a [GraphicsShaderGroupCreateInfoNV]) -> Self {
        self.group_count = groups.len() as _;
        self.p_groups = groups.as_ptr();
        self
    }
    #[inline]
    pub fn pipelines(mut self, pipelines: &'a [Pipeline]) -> Self {
        self.pipeline_count = pipelines.len() as _;
        self.p_pipelines = pipelines.as_ptr();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBindShaderGroupIndirectCommandNV.html>"]
pub struct BindShaderGroupIndirectCommandNV {
    pub group_index: u32,
}
impl BindShaderGroupIndirectCommandNV {
    #[inline]
    pub fn group_index(mut self, group_index: u32) -> Self {
        self.group_index = group_index;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBindIndexBufferIndirectCommandNV.html>"]
pub struct BindIndexBufferIndirectCommandNV {
    pub buffer_address: DeviceAddress,
    pub size: u32,
    pub index_type: IndexType,
}
impl BindIndexBufferIndirectCommandNV {
    #[inline]
    pub fn buffer_address(mut self, buffer_address: DeviceAddress) -> Self {
        self.buffer_address = buffer_address;
        self
    }
    #[inline]
    pub fn size(mut self, size: u32) -> Self {
        self.size = size;
        self
    }
    #[inline]
    pub fn index_type(mut self, index_type: IndexType) -> Self {
        self.index_type = index_type;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBindVertexBufferIndirectCommandNV.html>"]
pub struct BindVertexBufferIndirectCommandNV {
    pub buffer_address: DeviceAddress,
    pub size: u32,
    pub stride: u32,
}
impl BindVertexBufferIndirectCommandNV {
    #[inline]
    pub fn buffer_address(mut self, buffer_address: DeviceAddress) -> Self {
        self.buffer_address = buffer_address;
        self
    }
    #[inline]
    pub fn size(mut self, size: u32) -> Self {
        self.size = size;
        self
    }
    #[inline]
    pub fn stride(mut self, stride: u32) -> Self {
        self.stride = stride;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSetStateFlagsIndirectCommandNV.html>"]
pub struct SetStateFlagsIndirectCommandNV {
    pub data: u32,
}
impl SetStateFlagsIndirectCommandNV {
    #[inline]
    pub fn data(mut self, data: u32) -> Self {
        self.data = data;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkIndirectCommandsStreamNV.html>"]
pub struct IndirectCommandsStreamNV {
    pub buffer: Buffer,
    pub offset: DeviceSize,
}
impl IndirectCommandsStreamNV {
    #[inline]
    pub fn buffer(mut self, buffer: Buffer) -> Self {
        self.buffer = buffer;
        self
    }
    #[inline]
    pub fn offset(mut self, offset: DeviceSize) -> Self {
        self.offset = offset;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkIndirectCommandsLayoutTokenNV.html>"]
pub struct IndirectCommandsLayoutTokenNV<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub token_type: IndirectCommandsTokenTypeNV,
    pub stream: u32,
    pub offset: u32,
    pub vertex_binding_unit: u32,
    pub vertex_dynamic_stride: Bool32,
    pub pushconstant_pipeline_layout: PipelineLayout,
    pub pushconstant_shader_stage_flags: ShaderStageFlags,
    pub pushconstant_offset: u32,
    pub pushconstant_size: u32,
    pub indirect_state_flags: IndirectStateFlagsNV,
    pub index_type_count: u32,
    pub p_index_types: *const IndexType,
    pub p_index_type_values: *const u32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for IndirectCommandsLayoutTokenNV<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            token_type: IndirectCommandsTokenTypeNV::default(),
            stream: u32::default(),
            offset: u32::default(),
            vertex_binding_unit: u32::default(),
            vertex_dynamic_stride: Bool32::default(),
            pushconstant_pipeline_layout: PipelineLayout::default(),
            pushconstant_shader_stage_flags: ShaderStageFlags::default(),
            pushconstant_offset: u32::default(),
            pushconstant_size: u32::default(),
            indirect_state_flags: IndirectStateFlagsNV::default(),
            index_type_count: u32::default(),
            p_index_types: ::std::ptr::null(),
            p_index_type_values: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for IndirectCommandsLayoutTokenNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::INDIRECT_COMMANDS_LAYOUT_TOKEN_NV;
}
impl<'a> IndirectCommandsLayoutTokenNV<'a> {
    #[inline]
    pub fn token_type(mut self, token_type: IndirectCommandsTokenTypeNV) -> Self {
        self.token_type = token_type;
        self
    }
    #[inline]
    pub fn stream(mut self, stream: u32) -> Self {
        self.stream = stream;
        self
    }
    #[inline]
    pub fn offset(mut self, offset: u32) -> Self {
        self.offset = offset;
        self
    }
    #[inline]
    pub fn vertex_binding_unit(mut self, vertex_binding_unit: u32) -> Self {
        self.vertex_binding_unit = vertex_binding_unit;
        self
    }
    #[inline]
    pub fn vertex_dynamic_stride(mut self, vertex_dynamic_stride: bool) -> Self {
        self.vertex_dynamic_stride = vertex_dynamic_stride.into();
        self
    }
    #[inline]
    pub fn pushconstant_pipeline_layout(
        mut self,
        pushconstant_pipeline_layout: PipelineLayout,
    ) -> Self {
        self.pushconstant_pipeline_layout = pushconstant_pipeline_layout;
        self
    }
    #[inline]
    pub fn pushconstant_shader_stage_flags(
        mut self,
        pushconstant_shader_stage_flags: ShaderStageFlags,
    ) -> Self {
        self.pushconstant_shader_stage_flags = pushconstant_shader_stage_flags;
        self
    }
    #[inline]
    pub fn pushconstant_offset(mut self, pushconstant_offset: u32) -> Self {
        self.pushconstant_offset = pushconstant_offset;
        self
    }
    #[inline]
    pub fn pushconstant_size(mut self, pushconstant_size: u32) -> Self {
        self.pushconstant_size = pushconstant_size;
        self
    }
    #[inline]
    pub fn indirect_state_flags(mut self, indirect_state_flags: IndirectStateFlagsNV) -> Self {
        self.indirect_state_flags = indirect_state_flags;
        self
    }
    #[inline]
    pub fn index_types(mut self, index_types: &'a [IndexType]) -> Self {
        self.index_type_count = index_types.len() as _;
        self.p_index_types = index_types.as_ptr();
        self
    }
    #[inline]
    pub fn index_type_values(mut self, index_type_values: &'a [u32]) -> Self {
        self.index_type_count = index_type_values.len() as _;
        self.p_index_type_values = index_type_values.as_ptr();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkIndirectCommandsLayoutCreateInfoNV.html>"]
pub struct IndirectCommandsLayoutCreateInfoNV<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: IndirectCommandsLayoutUsageFlagsNV,
    pub pipeline_bind_point: PipelineBindPoint,
    pub token_count: u32,
    pub p_tokens: *const IndirectCommandsLayoutTokenNV<'a>,
    pub stream_count: u32,
    pub p_stream_strides: *const u32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for IndirectCommandsLayoutCreateInfoNV<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: IndirectCommandsLayoutUsageFlagsNV::default(),
            pipeline_bind_point: PipelineBindPoint::default(),
            token_count: u32::default(),
            p_tokens: ::std::ptr::null(),
            stream_count: u32::default(),
            p_stream_strides: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for IndirectCommandsLayoutCreateInfoNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NV;
}
impl<'a> IndirectCommandsLayoutCreateInfoNV<'a> {
    #[inline]
    pub fn flags(mut self, flags: IndirectCommandsLayoutUsageFlagsNV) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn pipeline_bind_point(mut self, pipeline_bind_point: PipelineBindPoint) -> Self {
        self.pipeline_bind_point = pipeline_bind_point;
        self
    }
    #[inline]
    pub fn tokens(mut self, tokens: &'a [IndirectCommandsLayoutTokenNV]) -> Self {
        self.token_count = tokens.len() as _;
        self.p_tokens = tokens.as_ptr();
        self
    }
    #[inline]
    pub fn stream_strides(mut self, stream_strides: &'a [u32]) -> Self {
        self.stream_count = stream_strides.len() as _;
        self.p_stream_strides = stream_strides.as_ptr();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkGeneratedCommandsInfoNV.html>"]
pub struct GeneratedCommandsInfoNV<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub pipeline_bind_point: PipelineBindPoint,
    pub pipeline: Pipeline,
    pub indirect_commands_layout: IndirectCommandsLayoutNV,
    pub stream_count: u32,
    pub p_streams: *const IndirectCommandsStreamNV,
    pub sequences_count: u32,
    pub preprocess_buffer: Buffer,
    pub preprocess_offset: DeviceSize,
    pub preprocess_size: DeviceSize,
    pub sequences_count_buffer: Buffer,
    pub sequences_count_offset: DeviceSize,
    pub sequences_index_buffer: Buffer,
    pub sequences_index_offset: DeviceSize,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for GeneratedCommandsInfoNV<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            pipeline_bind_point: PipelineBindPoint::default(),
            pipeline: Pipeline::default(),
            indirect_commands_layout: IndirectCommandsLayoutNV::default(),
            stream_count: u32::default(),
            p_streams: ::std::ptr::null(),
            sequences_count: u32::default(),
            preprocess_buffer: Buffer::default(),
            preprocess_offset: DeviceSize::default(),
            preprocess_size: DeviceSize::default(),
            sequences_count_buffer: Buffer::default(),
            sequences_count_offset: DeviceSize::default(),
            sequences_index_buffer: Buffer::default(),
            sequences_index_offset: DeviceSize::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for GeneratedCommandsInfoNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::GENERATED_COMMANDS_INFO_NV;
}
impl<'a> GeneratedCommandsInfoNV<'a> {
    #[inline]
    pub fn pipeline_bind_point(mut self, pipeline_bind_point: PipelineBindPoint) -> Self {
        self.pipeline_bind_point = pipeline_bind_point;
        self
    }
    #[inline]
    pub fn pipeline(mut self, pipeline: Pipeline) -> Self {
        self.pipeline = pipeline;
        self
    }
    #[inline]
    pub fn indirect_commands_layout(
        mut self,
        indirect_commands_layout: IndirectCommandsLayoutNV,
    ) -> Self {
        self.indirect_commands_layout = indirect_commands_layout;
        self
    }
    #[inline]
    pub fn streams(mut self, streams: &'a [IndirectCommandsStreamNV]) -> Self {
        self.stream_count = streams.len() as _;
        self.p_streams = streams.as_ptr();
        self
    }
    #[inline]
    pub fn sequences_count(mut self, sequences_count: u32) -> Self {
        self.sequences_count = sequences_count;
        self
    }
    #[inline]
    pub fn preprocess_buffer(mut self, preprocess_buffer: Buffer) -> Self {
        self.preprocess_buffer = preprocess_buffer;
        self
    }
    #[inline]
    pub fn preprocess_offset(mut self, preprocess_offset: DeviceSize) -> Self {
        self.preprocess_offset = preprocess_offset;
        self
    }
    #[inline]
    pub fn preprocess_size(mut self, preprocess_size: DeviceSize) -> Self {
        self.preprocess_size = preprocess_size;
        self
    }
    #[inline]
    pub fn sequences_count_buffer(mut self, sequences_count_buffer: Buffer) -> Self {
        self.sequences_count_buffer = sequences_count_buffer;
        self
    }
    #[inline]
    pub fn sequences_count_offset(mut self, sequences_count_offset: DeviceSize) -> Self {
        self.sequences_count_offset = sequences_count_offset;
        self
    }
    #[inline]
    pub fn sequences_index_buffer(mut self, sequences_index_buffer: Buffer) -> Self {
        self.sequences_index_buffer = sequences_index_buffer;
        self
    }
    #[inline]
    pub fn sequences_index_offset(mut self, sequences_index_offset: DeviceSize) -> Self {
        self.sequences_index_offset = sequences_index_offset;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkGeneratedCommandsMemoryRequirementsInfoNV.html>"]
pub struct GeneratedCommandsMemoryRequirementsInfoNV<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub pipeline_bind_point: PipelineBindPoint,
    pub pipeline: Pipeline,
    pub indirect_commands_layout: IndirectCommandsLayoutNV,
    pub max_sequences_count: u32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for GeneratedCommandsMemoryRequirementsInfoNV<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            pipeline_bind_point: PipelineBindPoint::default(),
            pipeline: Pipeline::default(),
            indirect_commands_layout: IndirectCommandsLayoutNV::default(),
            max_sequences_count: u32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for GeneratedCommandsMemoryRequirementsInfoNV<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV;
}
impl<'a> GeneratedCommandsMemoryRequirementsInfoNV<'a> {
    #[inline]
    pub fn pipeline_bind_point(mut self, pipeline_bind_point: PipelineBindPoint) -> Self {
        self.pipeline_bind_point = pipeline_bind_point;
        self
    }
    #[inline]
    pub fn pipeline(mut self, pipeline: Pipeline) -> Self {
        self.pipeline = pipeline;
        self
    }
    #[inline]
    pub fn indirect_commands_layout(
        mut self,
        indirect_commands_layout: IndirectCommandsLayoutNV,
    ) -> Self {
        self.indirect_commands_layout = indirect_commands_layout;
        self
    }
    #[inline]
    pub fn max_sequences_count(mut self, max_sequences_count: u32) -> Self {
        self.max_sequences_count = max_sequences_count;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFeatures2.html>"]
pub struct PhysicalDeviceFeatures2<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub features: PhysicalDeviceFeatures,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceFeatures2<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            features: PhysicalDeviceFeatures::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceFeatures2<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_FEATURES_2;
}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceFeatures2<'_> {}
pub unsafe trait ExtendsPhysicalDeviceFeatures2 {}
impl<'a> PhysicalDeviceFeatures2<'a> {
    #[inline]
    pub fn features(mut self, features: PhysicalDeviceFeatures) -> Self {
        self.features = features;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `x.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsPhysicalDeviceFeatures2>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*mut T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.p_next as _;
            self.p_next = next_ptr;
        }
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceProperties2.html>"]
pub struct PhysicalDeviceProperties2<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub properties: PhysicalDeviceProperties,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceProperties2<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            properties: PhysicalDeviceProperties::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceProperties2<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_PROPERTIES_2;
}
pub unsafe trait ExtendsPhysicalDeviceProperties2 {}
impl<'a> PhysicalDeviceProperties2<'a> {
    #[inline]
    pub fn properties(mut self, properties: PhysicalDeviceProperties) -> Self {
        self.properties = properties;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `x.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsPhysicalDeviceProperties2>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*mut T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.p_next as _;
            self.p_next = next_ptr;
        }
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFormatProperties2.html>"]
pub struct FormatProperties2<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub format_properties: FormatProperties,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for FormatProperties2<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            format_properties: FormatProperties::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for FormatProperties2<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::FORMAT_PROPERTIES_2;
}
pub unsafe trait ExtendsFormatProperties2 {}
impl<'a> FormatProperties2<'a> {
    #[inline]
    pub fn format_properties(mut self, format_properties: FormatProperties) -> Self {
        self.format_properties = format_properties;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `x.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsFormatProperties2>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*mut T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.p_next as _;
            self.p_next = next_ptr;
        }
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageFormatProperties2.html>"]
pub struct ImageFormatProperties2<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub image_format_properties: ImageFormatProperties,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for ImageFormatProperties2<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            image_format_properties: ImageFormatProperties::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for ImageFormatProperties2<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::IMAGE_FORMAT_PROPERTIES_2;
}
pub unsafe trait ExtendsImageFormatProperties2 {}
impl<'a> ImageFormatProperties2<'a> {
    #[inline]
    pub fn image_format_properties(
        mut self,
        image_format_properties: ImageFormatProperties,
    ) -> Self {
        self.image_format_properties = image_format_properties;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `x.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsImageFormatProperties2>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*mut T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.p_next as _;
            self.p_next = next_ptr;
        }
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceImageFormatInfo2.html>"]
pub struct PhysicalDeviceImageFormatInfo2<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub format: Format,
    pub ty: ImageType,
    pub tiling: ImageTiling,
    pub usage: ImageUsageFlags,
    pub flags: ImageCreateFlags,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceImageFormatInfo2<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            format: Format::default(),
            ty: ImageType::default(),
            tiling: ImageTiling::default(),
            usage: ImageUsageFlags::default(),
            flags: ImageCreateFlags::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceImageFormatInfo2<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2;
}
pub unsafe trait ExtendsPhysicalDeviceImageFormatInfo2 {}
impl<'a> PhysicalDeviceImageFormatInfo2<'a> {
    #[inline]
    pub fn format(mut self, format: Format) -> Self {
        self.format = format;
        self
    }
    #[inline]
    pub fn ty(mut self, ty: ImageType) -> Self {
        self.ty = ty;
        self
    }
    #[inline]
    pub fn tiling(mut self, tiling: ImageTiling) -> Self {
        self.tiling = tiling;
        self
    }
    #[inline]
    pub fn usage(mut self, usage: ImageUsageFlags) -> Self {
        self.usage = usage;
        self
    }
    #[inline]
    pub fn flags(mut self, flags: ImageCreateFlags) -> Self {
        self.flags = flags;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `x.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsPhysicalDeviceImageFormatInfo2>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.p_next as _;
            self.p_next = next_ptr;
        }
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkQueueFamilyProperties2.html>"]
pub struct QueueFamilyProperties2<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub queue_family_properties: QueueFamilyProperties,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for QueueFamilyProperties2<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            queue_family_properties: QueueFamilyProperties::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for QueueFamilyProperties2<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::QUEUE_FAMILY_PROPERTIES_2;
}
pub unsafe trait ExtendsQueueFamilyProperties2 {}
impl<'a> QueueFamilyProperties2<'a> {
    #[inline]
    pub fn queue_family_properties(
        mut self,
        queue_family_properties: QueueFamilyProperties,
    ) -> Self {
        self.queue_family_properties = queue_family_properties;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `x.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsQueueFamilyProperties2>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*mut T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.p_next as _;
            self.p_next = next_ptr;
        }
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMemoryProperties2.html>"]
pub struct PhysicalDeviceMemoryProperties2<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub memory_properties: PhysicalDeviceMemoryProperties,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceMemoryProperties2<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            memory_properties: PhysicalDeviceMemoryProperties::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceMemoryProperties2<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_MEMORY_PROPERTIES_2;
}
pub unsafe trait ExtendsPhysicalDeviceMemoryProperties2 {}
impl<'a> PhysicalDeviceMemoryProperties2<'a> {
    #[inline]
    pub fn memory_properties(mut self, memory_properties: PhysicalDeviceMemoryProperties) -> Self {
        self.memory_properties = memory_properties;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `x.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsPhysicalDeviceMemoryProperties2>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*mut T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.p_next as _;
            self.p_next = next_ptr;
        }
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSparseImageFormatProperties2.html>"]
pub struct SparseImageFormatProperties2<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub properties: SparseImageFormatProperties,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for SparseImageFormatProperties2<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            properties: SparseImageFormatProperties::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for SparseImageFormatProperties2<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::SPARSE_IMAGE_FORMAT_PROPERTIES_2;
}
impl<'a> SparseImageFormatProperties2<'a> {
    #[inline]
    pub fn properties(mut self, properties: SparseImageFormatProperties) -> Self {
        self.properties = properties;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceSparseImageFormatInfo2.html>"]
pub struct PhysicalDeviceSparseImageFormatInfo2<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub format: Format,
    pub ty: ImageType,
    pub samples: SampleCountFlags,
    pub usage: ImageUsageFlags,
    pub tiling: ImageTiling,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceSparseImageFormatInfo2<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            format: Format::default(),
            ty: ImageType::default(),
            samples: SampleCountFlags::default(),
            usage: ImageUsageFlags::default(),
            tiling: ImageTiling::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceSparseImageFormatInfo2<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2;
}
impl<'a> PhysicalDeviceSparseImageFormatInfo2<'a> {
    #[inline]
    pub fn format(mut self, format: Format) -> Self {
        self.format = format;
        self
    }
    #[inline]
    pub fn ty(mut self, ty: ImageType) -> Self {
        self.ty = ty;
        self
    }
    #[inline]
    pub fn samples(mut self, samples: SampleCountFlags) -> Self {
        self.samples = samples;
        self
    }
    #[inline]
    pub fn usage(mut self, usage: ImageUsageFlags) -> Self {
        self.usage = usage;
        self
    }
    #[inline]
    pub fn tiling(mut self, tiling: ImageTiling) -> Self {
        self.tiling = tiling;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePushDescriptorPropertiesKHR.html>"]
pub struct PhysicalDevicePushDescriptorPropertiesKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub max_push_descriptors: u32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDevicePushDescriptorPropertiesKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            max_push_descriptors: u32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDevicePushDescriptorPropertiesKHR<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR;
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDevicePushDescriptorPropertiesKHR<'_> {}
impl<'a> PhysicalDevicePushDescriptorPropertiesKHR<'a> {
    #[inline]
    pub fn max_push_descriptors(mut self, max_push_descriptors: u32) -> Self {
        self.max_push_descriptors = max_push_descriptors;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkConformanceVersion.html>"]
pub struct ConformanceVersion {
    pub major: u8,
    pub minor: u8,
    pub subminor: u8,
    pub patch: u8,
}
impl ConformanceVersion {
    #[inline]
    pub fn major(mut self, major: u8) -> Self {
        self.major = major;
        self
    }
    #[inline]
    pub fn minor(mut self, minor: u8) -> Self {
        self.minor = minor;
        self
    }
    #[inline]
    pub fn subminor(mut self, subminor: u8) -> Self {
        self.subminor = subminor;
        self
    }
    #[inline]
    pub fn patch(mut self, patch: u8) -> Self {
        self.patch = patch;
        self
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDriverProperties.html>"]
pub struct PhysicalDeviceDriverProperties<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub driver_id: DriverId,
    pub driver_name: [c_char; MAX_DRIVER_NAME_SIZE],
    pub driver_info: [c_char; MAX_DRIVER_INFO_SIZE],
    pub conformance_version: ConformanceVersion,
    pub _marker: PhantomData<&'a ()>,
}
#[cfg(feature = "debug")]
impl fmt::Debug for PhysicalDeviceDriverProperties<'_> {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceDriverProperties")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("driver_id", &self.driver_id)
            .field("driver_name", &unsafe {
                ::std::ffi::CStr::from_ptr(self.driver_name.as_ptr())
            })
            .field("driver_info", &unsafe {
                ::std::ffi::CStr::from_ptr(self.driver_info.as_ptr())
            })
            .field("conformance_version", &self.conformance_version)
            .finish()
    }
}
impl ::std::default::Default for PhysicalDeviceDriverProperties<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            driver_id: DriverId::default(),
            driver_name: unsafe { ::std::mem::zeroed() },
            driver_info: unsafe { ::std::mem::zeroed() },
            conformance_version: ConformanceVersion::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceDriverProperties<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_DRIVER_PROPERTIES;
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceDriverProperties<'_> {}
impl<'a> PhysicalDeviceDriverProperties<'a> {
    #[inline]
    pub fn driver_id(mut self, driver_id: DriverId) -> Self {
        self.driver_id = driver_id;
        self
    }
    #[inline]
    pub fn driver_name(mut self, driver_name: [c_char; MAX_DRIVER_NAME_SIZE]) -> Self {
        self.driver_name = driver_name;
        self
    }
    #[inline]
    pub fn driver_info(mut self, driver_info: [c_char; MAX_DRIVER_INFO_SIZE]) -> Self {
        self.driver_info = driver_info;
        self
    }
    #[inline]
    pub fn conformance_version(mut self, conformance_version: ConformanceVersion) -> Self {
        self.conformance_version = conformance_version;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPresentRegionsKHR.html>"]
pub struct PresentRegionsKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub swapchain_count: u32,
    pub p_regions: *const PresentRegionKHR<'a>,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PresentRegionsKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            swapchain_count: u32::default(),
            p_regions: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PresentRegionsKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PRESENT_REGIONS_KHR;
}
unsafe impl ExtendsPresentInfoKHR for PresentRegionsKHR<'_> {}
impl<'a> PresentRegionsKHR<'a> {
    #[inline]
    pub fn regions(mut self, regions: &'a [PresentRegionKHR]) -> Self {
        self.swapchain_count = regions.len() as _;
        self.p_regions = regions.as_ptr();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPresentRegionKHR.html>"]
pub struct PresentRegionKHR<'a> {
    pub rectangle_count: u32,
    pub p_rectangles: *const RectLayerKHR,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PresentRegionKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            rectangle_count: u32::default(),
            p_rectangles: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
impl<'a> PresentRegionKHR<'a> {
    #[inline]
    pub fn rectangles(mut self, rectangles: &'a [RectLayerKHR]) -> Self {
        self.rectangle_count = rectangles.len() as _;
        self.p_rectangles = rectangles.as_ptr();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRectLayerKHR.html>"]
pub struct RectLayerKHR {
    pub offset: Offset2D,
    pub extent: Extent2D,
    pub layer: u32,
}
impl RectLayerKHR {
    #[inline]
    pub fn offset(mut self, offset: Offset2D) -> Self {
        self.offset = offset;
        self
    }
    #[inline]
    pub fn extent(mut self, extent: Extent2D) -> Self {
        self.extent = extent;
        self
    }
    #[inline]
    pub fn layer(mut self, layer: u32) -> Self {
        self.layer = layer;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVariablePointersFeatures.html>"]
pub struct PhysicalDeviceVariablePointersFeatures<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub variable_pointers_storage_buffer: Bool32,
    pub variable_pointers: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceVariablePointersFeatures<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            variable_pointers_storage_buffer: Bool32::default(),
            variable_pointers: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceVariablePointersFeatures<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES;
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceVariablePointersFeatures<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceVariablePointersFeatures<'_> {}
impl<'a> PhysicalDeviceVariablePointersFeatures<'a> {
    #[inline]
    pub fn variable_pointers_storage_buffer(
        mut self,
        variable_pointers_storage_buffer: bool,
    ) -> Self {
        self.variable_pointers_storage_buffer = variable_pointers_storage_buffer.into();
        self
    }
    #[inline]
    pub fn variable_pointers(mut self, variable_pointers: bool) -> Self {
        self.variable_pointers = variable_pointers.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExternalMemoryProperties.html>"]
pub struct ExternalMemoryProperties {
    pub external_memory_features: ExternalMemoryFeatureFlags,
    pub export_from_imported_handle_types: ExternalMemoryHandleTypeFlags,
    pub compatible_handle_types: ExternalMemoryHandleTypeFlags,
}
impl ExternalMemoryProperties {
    #[inline]
    pub fn external_memory_features(
        mut self,
        external_memory_features: ExternalMemoryFeatureFlags,
    ) -> Self {
        self.external_memory_features = external_memory_features;
        self
    }
    #[inline]
    pub fn export_from_imported_handle_types(
        mut self,
        export_from_imported_handle_types: ExternalMemoryHandleTypeFlags,
    ) -> Self {
        self.export_from_imported_handle_types = export_from_imported_handle_types;
        self
    }
    #[inline]
    pub fn compatible_handle_types(
        mut self,
        compatible_handle_types: ExternalMemoryHandleTypeFlags,
    ) -> Self {
        self.compatible_handle_types = compatible_handle_types;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceExternalImageFormatInfo.html>"]
pub struct PhysicalDeviceExternalImageFormatInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub handle_type: ExternalMemoryHandleTypeFlags,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceExternalImageFormatInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            handle_type: ExternalMemoryHandleTypeFlags::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceExternalImageFormatInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO;
}
unsafe impl ExtendsPhysicalDeviceImageFormatInfo2 for PhysicalDeviceExternalImageFormatInfo<'_> {}
impl<'a> PhysicalDeviceExternalImageFormatInfo<'a> {
    #[inline]
    pub fn handle_type(mut self, handle_type: ExternalMemoryHandleTypeFlags) -> Self {
        self.handle_type = handle_type;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExternalImageFormatProperties.html>"]
pub struct ExternalImageFormatProperties<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub external_memory_properties: ExternalMemoryProperties,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for ExternalImageFormatProperties<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            external_memory_properties: ExternalMemoryProperties::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for ExternalImageFormatProperties<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::EXTERNAL_IMAGE_FORMAT_PROPERTIES;
}
unsafe impl ExtendsImageFormatProperties2 for ExternalImageFormatProperties<'_> {}
impl<'a> ExternalImageFormatProperties<'a> {
    #[inline]
    pub fn external_memory_properties(
        mut self,
        external_memory_properties: ExternalMemoryProperties,
    ) -> Self {
        self.external_memory_properties = external_memory_properties;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceExternalBufferInfo.html>"]
pub struct PhysicalDeviceExternalBufferInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: BufferCreateFlags,
    pub usage: BufferUsageFlags,
    pub handle_type: ExternalMemoryHandleTypeFlags,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceExternalBufferInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: BufferCreateFlags::default(),
            usage: BufferUsageFlags::default(),
            handle_type: ExternalMemoryHandleTypeFlags::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceExternalBufferInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO;
}
impl<'a> PhysicalDeviceExternalBufferInfo<'a> {
    #[inline]
    pub fn flags(mut self, flags: BufferCreateFlags) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn usage(mut self, usage: BufferUsageFlags) -> Self {
        self.usage = usage;
        self
    }
    #[inline]
    pub fn handle_type(mut self, handle_type: ExternalMemoryHandleTypeFlags) -> Self {
        self.handle_type = handle_type;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExternalBufferProperties.html>"]
pub struct ExternalBufferProperties<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub external_memory_properties: ExternalMemoryProperties,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for ExternalBufferProperties<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            external_memory_properties: ExternalMemoryProperties::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for ExternalBufferProperties<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::EXTERNAL_BUFFER_PROPERTIES;
}
impl<'a> ExternalBufferProperties<'a> {
    #[inline]
    pub fn external_memory_properties(
        mut self,
        external_memory_properties: ExternalMemoryProperties,
    ) -> Self {
        self.external_memory_properties = external_memory_properties;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceIDProperties.html>"]
pub struct PhysicalDeviceIDProperties<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub device_uuid: [u8; UUID_SIZE],
    pub driver_uuid: [u8; UUID_SIZE],
    pub device_luid: [u8; LUID_SIZE],
    pub device_node_mask: u32,
    pub device_luid_valid: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceIDProperties<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            device_uuid: unsafe { ::std::mem::zeroed() },
            driver_uuid: unsafe { ::std::mem::zeroed() },
            device_luid: unsafe { ::std::mem::zeroed() },
            device_node_mask: u32::default(),
            device_luid_valid: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceIDProperties<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_ID_PROPERTIES;
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceIDProperties<'_> {}
impl<'a> PhysicalDeviceIDProperties<'a> {
    #[inline]
    pub fn device_uuid(mut self, device_uuid: [u8; UUID_SIZE]) -> Self {
        self.device_uuid = device_uuid;
        self
    }
    #[inline]
    pub fn driver_uuid(mut self, driver_uuid: [u8; UUID_SIZE]) -> Self {
        self.driver_uuid = driver_uuid;
        self
    }
    #[inline]
    pub fn device_luid(mut self, device_luid: [u8; LUID_SIZE]) -> Self {
        self.device_luid = device_luid;
        self
    }
    #[inline]
    pub fn device_node_mask(mut self, device_node_mask: u32) -> Self {
        self.device_node_mask = device_node_mask;
        self
    }
    #[inline]
    pub fn device_luid_valid(mut self, device_luid_valid: bool) -> Self {
        self.device_luid_valid = device_luid_valid.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExternalMemoryImageCreateInfo.html>"]
pub struct ExternalMemoryImageCreateInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub handle_types: ExternalMemoryHandleTypeFlags,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for ExternalMemoryImageCreateInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            handle_types: ExternalMemoryHandleTypeFlags::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for ExternalMemoryImageCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::EXTERNAL_MEMORY_IMAGE_CREATE_INFO;
}
unsafe impl ExtendsImageCreateInfo for ExternalMemoryImageCreateInfo<'_> {}
impl<'a> ExternalMemoryImageCreateInfo<'a> {
    #[inline]
    pub fn handle_types(mut self, handle_types: ExternalMemoryHandleTypeFlags) -> Self {
        self.handle_types = handle_types;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExternalMemoryBufferCreateInfo.html>"]
pub struct ExternalMemoryBufferCreateInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub handle_types: ExternalMemoryHandleTypeFlags,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for ExternalMemoryBufferCreateInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            handle_types: ExternalMemoryHandleTypeFlags::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for ExternalMemoryBufferCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::EXTERNAL_MEMORY_BUFFER_CREATE_INFO;
}
unsafe impl ExtendsBufferCreateInfo for ExternalMemoryBufferCreateInfo<'_> {}
impl<'a> ExternalMemoryBufferCreateInfo<'a> {
    #[inline]
    pub fn handle_types(mut self, handle_types: ExternalMemoryHandleTypeFlags) -> Self {
        self.handle_types = handle_types;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExportMemoryAllocateInfo.html>"]
pub struct ExportMemoryAllocateInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub handle_types: ExternalMemoryHandleTypeFlags,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for ExportMemoryAllocateInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            handle_types: ExternalMemoryHandleTypeFlags::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for ExportMemoryAllocateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::EXPORT_MEMORY_ALLOCATE_INFO;
}
unsafe impl ExtendsMemoryAllocateInfo for ExportMemoryAllocateInfo<'_> {}
impl<'a> ExportMemoryAllocateInfo<'a> {
    #[inline]
    pub fn handle_types(mut self, handle_types: ExternalMemoryHandleTypeFlags) -> Self {
        self.handle_types = handle_types;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImportMemoryWin32HandleInfoKHR.html>"]
pub struct ImportMemoryWin32HandleInfoKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub handle_type: ExternalMemoryHandleTypeFlags,
    pub handle: HANDLE,
    pub name: LPCWSTR,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for ImportMemoryWin32HandleInfoKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            handle_type: ExternalMemoryHandleTypeFlags::default(),
            handle: unsafe { ::std::mem::zeroed() },
            name: unsafe { ::std::mem::zeroed() },
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for ImportMemoryWin32HandleInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR;
}
unsafe impl ExtendsMemoryAllocateInfo for ImportMemoryWin32HandleInfoKHR<'_> {}
impl<'a> ImportMemoryWin32HandleInfoKHR<'a> {
    #[inline]
    pub fn handle_type(mut self, handle_type: ExternalMemoryHandleTypeFlags) -> Self {
        self.handle_type = handle_type;
        self
    }
    #[inline]
    pub fn handle(mut self, handle: HANDLE) -> Self {
        self.handle = handle;
        self
    }
    #[inline]
    pub fn name(mut self, name: LPCWSTR) -> Self {
        self.name = name;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExportMemoryWin32HandleInfoKHR.html>"]
pub struct ExportMemoryWin32HandleInfoKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub p_attributes: *const SECURITY_ATTRIBUTES,
    pub dw_access: DWORD,
    pub name: LPCWSTR,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for ExportMemoryWin32HandleInfoKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            p_attributes: ::std::ptr::null(),
            dw_access: DWORD::default(),
            name: unsafe { ::std::mem::zeroed() },
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for ExportMemoryWin32HandleInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR;
}
unsafe impl ExtendsMemoryAllocateInfo for ExportMemoryWin32HandleInfoKHR<'_> {}
impl<'a> ExportMemoryWin32HandleInfoKHR<'a> {
    #[inline]
    pub fn attributes(mut self, attributes: &'a SECURITY_ATTRIBUTES) -> Self {
        self.p_attributes = attributes;
        self
    }
    #[inline]
    pub fn dw_access(mut self, dw_access: DWORD) -> Self {
        self.dw_access = dw_access;
        self
    }
    #[inline]
    pub fn name(mut self, name: LPCWSTR) -> Self {
        self.name = name;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImportMemoryZirconHandleInfoFUCHSIA.html>"]
pub struct ImportMemoryZirconHandleInfoFUCHSIA<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub handle_type: ExternalMemoryHandleTypeFlags,
    pub handle: zx_handle_t,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for ImportMemoryZirconHandleInfoFUCHSIA<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            handle_type: ExternalMemoryHandleTypeFlags::default(),
            handle: zx_handle_t::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for ImportMemoryZirconHandleInfoFUCHSIA<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::IMPORT_MEMORY_ZIRCON_HANDLE_INFO_FUCHSIA;
}
unsafe impl ExtendsMemoryAllocateInfo for ImportMemoryZirconHandleInfoFUCHSIA<'_> {}
impl<'a> ImportMemoryZirconHandleInfoFUCHSIA<'a> {
    #[inline]
    pub fn handle_type(mut self, handle_type: ExternalMemoryHandleTypeFlags) -> Self {
        self.handle_type = handle_type;
        self
    }
    #[inline]
    pub fn handle(mut self, handle: zx_handle_t) -> Self {
        self.handle = handle;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryZirconHandlePropertiesFUCHSIA.html>"]
pub struct MemoryZirconHandlePropertiesFUCHSIA<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub memory_type_bits: u32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for MemoryZirconHandlePropertiesFUCHSIA<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            memory_type_bits: u32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for MemoryZirconHandlePropertiesFUCHSIA<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::MEMORY_ZIRCON_HANDLE_PROPERTIES_FUCHSIA;
}
impl<'a> MemoryZirconHandlePropertiesFUCHSIA<'a> {
    #[inline]
    pub fn memory_type_bits(mut self, memory_type_bits: u32) -> Self {
        self.memory_type_bits = memory_type_bits;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryGetZirconHandleInfoFUCHSIA.html>"]
pub struct MemoryGetZirconHandleInfoFUCHSIA<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub memory: DeviceMemory,
    pub handle_type: ExternalMemoryHandleTypeFlags,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for MemoryGetZirconHandleInfoFUCHSIA<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            memory: DeviceMemory::default(),
            handle_type: ExternalMemoryHandleTypeFlags::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for MemoryGetZirconHandleInfoFUCHSIA<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::MEMORY_GET_ZIRCON_HANDLE_INFO_FUCHSIA;
}
impl<'a> MemoryGetZirconHandleInfoFUCHSIA<'a> {
    #[inline]
    pub fn memory(mut self, memory: DeviceMemory) -> Self {
        self.memory = memory;
        self
    }
    #[inline]
    pub fn handle_type(mut self, handle_type: ExternalMemoryHandleTypeFlags) -> Self {
        self.handle_type = handle_type;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryWin32HandlePropertiesKHR.html>"]
pub struct MemoryWin32HandlePropertiesKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub memory_type_bits: u32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for MemoryWin32HandlePropertiesKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            memory_type_bits: u32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for MemoryWin32HandlePropertiesKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::MEMORY_WIN32_HANDLE_PROPERTIES_KHR;
}
impl<'a> MemoryWin32HandlePropertiesKHR<'a> {
    #[inline]
    pub fn memory_type_bits(mut self, memory_type_bits: u32) -> Self {
        self.memory_type_bits = memory_type_bits;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryGetWin32HandleInfoKHR.html>"]
pub struct MemoryGetWin32HandleInfoKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub memory: DeviceMemory,
    pub handle_type: ExternalMemoryHandleTypeFlags,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for MemoryGetWin32HandleInfoKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            memory: DeviceMemory::default(),
            handle_type: ExternalMemoryHandleTypeFlags::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for MemoryGetWin32HandleInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::MEMORY_GET_WIN32_HANDLE_INFO_KHR;
}
impl<'a> MemoryGetWin32HandleInfoKHR<'a> {
    #[inline]
    pub fn memory(mut self, memory: DeviceMemory) -> Self {
        self.memory = memory;
        self
    }
    #[inline]
    pub fn handle_type(mut self, handle_type: ExternalMemoryHandleTypeFlags) -> Self {
        self.handle_type = handle_type;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImportMemoryFdInfoKHR.html>"]
pub struct ImportMemoryFdInfoKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub handle_type: ExternalMemoryHandleTypeFlags,
    pub fd: c_int,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for ImportMemoryFdInfoKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            handle_type: ExternalMemoryHandleTypeFlags::default(),
            fd: c_int::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for ImportMemoryFdInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::IMPORT_MEMORY_FD_INFO_KHR;
}
unsafe impl ExtendsMemoryAllocateInfo for ImportMemoryFdInfoKHR<'_> {}
impl<'a> ImportMemoryFdInfoKHR<'a> {
    #[inline]
    pub fn handle_type(mut self, handle_type: ExternalMemoryHandleTypeFlags) -> Self {
        self.handle_type = handle_type;
        self
    }
    #[inline]
    pub fn fd(mut self, fd: c_int) -> Self {
        self.fd = fd;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryFdPropertiesKHR.html>"]
pub struct MemoryFdPropertiesKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub memory_type_bits: u32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for MemoryFdPropertiesKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            memory_type_bits: u32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for MemoryFdPropertiesKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::MEMORY_FD_PROPERTIES_KHR;
}
impl<'a> MemoryFdPropertiesKHR<'a> {
    #[inline]
    pub fn memory_type_bits(mut self, memory_type_bits: u32) -> Self {
        self.memory_type_bits = memory_type_bits;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryGetFdInfoKHR.html>"]
pub struct MemoryGetFdInfoKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub memory: DeviceMemory,
    pub handle_type: ExternalMemoryHandleTypeFlags,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for MemoryGetFdInfoKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            memory: DeviceMemory::default(),
            handle_type: ExternalMemoryHandleTypeFlags::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for MemoryGetFdInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::MEMORY_GET_FD_INFO_KHR;
}
impl<'a> MemoryGetFdInfoKHR<'a> {
    #[inline]
    pub fn memory(mut self, memory: DeviceMemory) -> Self {
        self.memory = memory;
        self
    }
    #[inline]
    pub fn handle_type(mut self, handle_type: ExternalMemoryHandleTypeFlags) -> Self {
        self.handle_type = handle_type;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkWin32KeyedMutexAcquireReleaseInfoKHR.html>"]
pub struct Win32KeyedMutexAcquireReleaseInfoKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub acquire_count: u32,
    pub p_acquire_syncs: *const DeviceMemory,
    pub p_acquire_keys: *const u64,
    pub p_acquire_timeouts: *const u32,
    pub release_count: u32,
    pub p_release_syncs: *const DeviceMemory,
    pub p_release_keys: *const u64,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for Win32KeyedMutexAcquireReleaseInfoKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            acquire_count: u32::default(),
            p_acquire_syncs: ::std::ptr::null(),
            p_acquire_keys: ::std::ptr::null(),
            p_acquire_timeouts: ::std::ptr::null(),
            release_count: u32::default(),
            p_release_syncs: ::std::ptr::null(),
            p_release_keys: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for Win32KeyedMutexAcquireReleaseInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR;
}
unsafe impl ExtendsSubmitInfo for Win32KeyedMutexAcquireReleaseInfoKHR<'_> {}
unsafe impl ExtendsSubmitInfo2 for Win32KeyedMutexAcquireReleaseInfoKHR<'_> {}
impl<'a> Win32KeyedMutexAcquireReleaseInfoKHR<'a> {
    #[inline]
    pub fn acquire_syncs(mut self, acquire_syncs: &'a [DeviceMemory]) -> Self {
        self.acquire_count = acquire_syncs.len() as _;
        self.p_acquire_syncs = acquire_syncs.as_ptr();
        self
    }
    #[inline]
    pub fn acquire_keys(mut self, acquire_keys: &'a [u64]) -> Self {
        self.acquire_count = acquire_keys.len() as _;
        self.p_acquire_keys = acquire_keys.as_ptr();
        self
    }
    #[inline]
    pub fn acquire_timeouts(mut self, acquire_timeouts: &'a [u32]) -> Self {
        self.acquire_count = acquire_timeouts.len() as _;
        self.p_acquire_timeouts = acquire_timeouts.as_ptr();
        self
    }
    #[inline]
    pub fn release_syncs(mut self, release_syncs: &'a [DeviceMemory]) -> Self {
        self.release_count = release_syncs.len() as _;
        self.p_release_syncs = release_syncs.as_ptr();
        self
    }
    #[inline]
    pub fn release_keys(mut self, release_keys: &'a [u64]) -> Self {
        self.release_count = release_keys.len() as _;
        self.p_release_keys = release_keys.as_ptr();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceExternalSemaphoreInfo.html>"]
pub struct PhysicalDeviceExternalSemaphoreInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub handle_type: ExternalSemaphoreHandleTypeFlags,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceExternalSemaphoreInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            handle_type: ExternalSemaphoreHandleTypeFlags::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceExternalSemaphoreInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO;
}
pub unsafe trait ExtendsPhysicalDeviceExternalSemaphoreInfo {}
impl<'a> PhysicalDeviceExternalSemaphoreInfo<'a> {
    #[inline]
    pub fn handle_type(mut self, handle_type: ExternalSemaphoreHandleTypeFlags) -> Self {
        self.handle_type = handle_type;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `x.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsPhysicalDeviceExternalSemaphoreInfo>(
        mut self,
        next: &'a mut T,
    ) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.p_next as _;
            self.p_next = next_ptr;
        }
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExternalSemaphoreProperties.html>"]
pub struct ExternalSemaphoreProperties<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub export_from_imported_handle_types: ExternalSemaphoreHandleTypeFlags,
    pub compatible_handle_types: ExternalSemaphoreHandleTypeFlags,
    pub external_semaphore_features: ExternalSemaphoreFeatureFlags,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for ExternalSemaphoreProperties<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            export_from_imported_handle_types: ExternalSemaphoreHandleTypeFlags::default(),
            compatible_handle_types: ExternalSemaphoreHandleTypeFlags::default(),
            external_semaphore_features: ExternalSemaphoreFeatureFlags::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for ExternalSemaphoreProperties<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::EXTERNAL_SEMAPHORE_PROPERTIES;
}
impl<'a> ExternalSemaphoreProperties<'a> {
    #[inline]
    pub fn export_from_imported_handle_types(
        mut self,
        export_from_imported_handle_types: ExternalSemaphoreHandleTypeFlags,
    ) -> Self {
        self.export_from_imported_handle_types = export_from_imported_handle_types;
        self
    }
    #[inline]
    pub fn compatible_handle_types(
        mut self,
        compatible_handle_types: ExternalSemaphoreHandleTypeFlags,
    ) -> Self {
        self.compatible_handle_types = compatible_handle_types;
        self
    }
    #[inline]
    pub fn external_semaphore_features(
        mut self,
        external_semaphore_features: ExternalSemaphoreFeatureFlags,
    ) -> Self {
        self.external_semaphore_features = external_semaphore_features;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExportSemaphoreCreateInfo.html>"]
pub struct ExportSemaphoreCreateInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub handle_types: ExternalSemaphoreHandleTypeFlags,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for ExportSemaphoreCreateInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            handle_types: ExternalSemaphoreHandleTypeFlags::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for ExportSemaphoreCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::EXPORT_SEMAPHORE_CREATE_INFO;
}
unsafe impl ExtendsSemaphoreCreateInfo for ExportSemaphoreCreateInfo<'_> {}
impl<'a> ExportSemaphoreCreateInfo<'a> {
    #[inline]
    pub fn handle_types(mut self, handle_types: ExternalSemaphoreHandleTypeFlags) -> Self {
        self.handle_types = handle_types;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImportSemaphoreWin32HandleInfoKHR.html>"]
pub struct ImportSemaphoreWin32HandleInfoKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub semaphore: Semaphore,
    pub flags: SemaphoreImportFlags,
    pub handle_type: ExternalSemaphoreHandleTypeFlags,
    pub handle: HANDLE,
    pub name: LPCWSTR,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for ImportSemaphoreWin32HandleInfoKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            semaphore: Semaphore::default(),
            flags: SemaphoreImportFlags::default(),
            handle_type: ExternalSemaphoreHandleTypeFlags::default(),
            handle: unsafe { ::std::mem::zeroed() },
            name: unsafe { ::std::mem::zeroed() },
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for ImportSemaphoreWin32HandleInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR;
}
impl<'a> ImportSemaphoreWin32HandleInfoKHR<'a> {
    #[inline]
    pub fn semaphore(mut self, semaphore: Semaphore) -> Self {
        self.semaphore = semaphore;
        self
    }
    #[inline]
    pub fn flags(mut self, flags: SemaphoreImportFlags) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn handle_type(mut self, handle_type: ExternalSemaphoreHandleTypeFlags) -> Self {
        self.handle_type = handle_type;
        self
    }
    #[inline]
    pub fn handle(mut self, handle: HANDLE) -> Self {
        self.handle = handle;
        self
    }
    #[inline]
    pub fn name(mut self, name: LPCWSTR) -> Self {
        self.name = name;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExportSemaphoreWin32HandleInfoKHR.html>"]
pub struct ExportSemaphoreWin32HandleInfoKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub p_attributes: *const SECURITY_ATTRIBUTES,
    pub dw_access: DWORD,
    pub name: LPCWSTR,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for ExportSemaphoreWin32HandleInfoKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            p_attributes: ::std::ptr::null(),
            dw_access: DWORD::default(),
            name: unsafe { ::std::mem::zeroed() },
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for ExportSemaphoreWin32HandleInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR;
}
unsafe impl ExtendsSemaphoreCreateInfo for ExportSemaphoreWin32HandleInfoKHR<'_> {}
impl<'a> ExportSemaphoreWin32HandleInfoKHR<'a> {
    #[inline]
    pub fn attributes(mut self, attributes: &'a SECURITY_ATTRIBUTES) -> Self {
        self.p_attributes = attributes;
        self
    }
    #[inline]
    pub fn dw_access(mut self, dw_access: DWORD) -> Self {
        self.dw_access = dw_access;
        self
    }
    #[inline]
    pub fn name(mut self, name: LPCWSTR) -> Self {
        self.name = name;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkD3D12FenceSubmitInfoKHR.html>"]
pub struct D3D12FenceSubmitInfoKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub wait_semaphore_values_count: u32,
    pub p_wait_semaphore_values: *const u64,
    pub signal_semaphore_values_count: u32,
    pub p_signal_semaphore_values: *const u64,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for D3D12FenceSubmitInfoKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            wait_semaphore_values_count: u32::default(),
            p_wait_semaphore_values: ::std::ptr::null(),
            signal_semaphore_values_count: u32::default(),
            p_signal_semaphore_values: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for D3D12FenceSubmitInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::D3D12_FENCE_SUBMIT_INFO_KHR;
}
unsafe impl ExtendsSubmitInfo for D3D12FenceSubmitInfoKHR<'_> {}
impl<'a> D3D12FenceSubmitInfoKHR<'a> {
    #[inline]
    pub fn wait_semaphore_values(mut self, wait_semaphore_values: &'a [u64]) -> Self {
        self.wait_semaphore_values_count = wait_semaphore_values.len() as _;
        self.p_wait_semaphore_values = wait_semaphore_values.as_ptr();
        self
    }
    #[inline]
    pub fn signal_semaphore_values(mut self, signal_semaphore_values: &'a [u64]) -> Self {
        self.signal_semaphore_values_count = signal_semaphore_values.len() as _;
        self.p_signal_semaphore_values = signal_semaphore_values.as_ptr();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSemaphoreGetWin32HandleInfoKHR.html>"]
pub struct SemaphoreGetWin32HandleInfoKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub semaphore: Semaphore,
    pub handle_type: ExternalSemaphoreHandleTypeFlags,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for SemaphoreGetWin32HandleInfoKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            semaphore: Semaphore::default(),
            handle_type: ExternalSemaphoreHandleTypeFlags::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for SemaphoreGetWin32HandleInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR;
}
impl<'a> SemaphoreGetWin32HandleInfoKHR<'a> {
    #[inline]
    pub fn semaphore(mut self, semaphore: Semaphore) -> Self {
        self.semaphore = semaphore;
        self
    }
    #[inline]
    pub fn handle_type(mut self, handle_type: ExternalSemaphoreHandleTypeFlags) -> Self {
        self.handle_type = handle_type;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImportSemaphoreFdInfoKHR.html>"]
pub struct ImportSemaphoreFdInfoKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub semaphore: Semaphore,
    pub flags: SemaphoreImportFlags,
    pub handle_type: ExternalSemaphoreHandleTypeFlags,
    pub fd: c_int,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for ImportSemaphoreFdInfoKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            semaphore: Semaphore::default(),
            flags: SemaphoreImportFlags::default(),
            handle_type: ExternalSemaphoreHandleTypeFlags::default(),
            fd: c_int::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for ImportSemaphoreFdInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::IMPORT_SEMAPHORE_FD_INFO_KHR;
}
impl<'a> ImportSemaphoreFdInfoKHR<'a> {
    #[inline]
    pub fn semaphore(mut self, semaphore: Semaphore) -> Self {
        self.semaphore = semaphore;
        self
    }
    #[inline]
    pub fn flags(mut self, flags: SemaphoreImportFlags) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn handle_type(mut self, handle_type: ExternalSemaphoreHandleTypeFlags) -> Self {
        self.handle_type = handle_type;
        self
    }
    #[inline]
    pub fn fd(mut self, fd: c_int) -> Self {
        self.fd = fd;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSemaphoreGetFdInfoKHR.html>"]
pub struct SemaphoreGetFdInfoKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub semaphore: Semaphore,
    pub handle_type: ExternalSemaphoreHandleTypeFlags,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for SemaphoreGetFdInfoKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            semaphore: Semaphore::default(),
            handle_type: ExternalSemaphoreHandleTypeFlags::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for SemaphoreGetFdInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::SEMAPHORE_GET_FD_INFO_KHR;
}
impl<'a> SemaphoreGetFdInfoKHR<'a> {
    #[inline]
    pub fn semaphore(mut self, semaphore: Semaphore) -> Self {
        self.semaphore = semaphore;
        self
    }
    #[inline]
    pub fn handle_type(mut self, handle_type: ExternalSemaphoreHandleTypeFlags) -> Self {
        self.handle_type = handle_type;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImportSemaphoreZirconHandleInfoFUCHSIA.html>"]
pub struct ImportSemaphoreZirconHandleInfoFUCHSIA<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub semaphore: Semaphore,
    pub flags: SemaphoreImportFlags,
    pub handle_type: ExternalSemaphoreHandleTypeFlags,
    pub zircon_handle: zx_handle_t,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for ImportSemaphoreZirconHandleInfoFUCHSIA<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            semaphore: Semaphore::default(),
            flags: SemaphoreImportFlags::default(),
            handle_type: ExternalSemaphoreHandleTypeFlags::default(),
            zircon_handle: zx_handle_t::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for ImportSemaphoreZirconHandleInfoFUCHSIA<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::IMPORT_SEMAPHORE_ZIRCON_HANDLE_INFO_FUCHSIA;
}
impl<'a> ImportSemaphoreZirconHandleInfoFUCHSIA<'a> {
    #[inline]
    pub fn semaphore(mut self, semaphore: Semaphore) -> Self {
        self.semaphore = semaphore;
        self
    }
    #[inline]
    pub fn flags(mut self, flags: SemaphoreImportFlags) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn handle_type(mut self, handle_type: ExternalSemaphoreHandleTypeFlags) -> Self {
        self.handle_type = handle_type;
        self
    }
    #[inline]
    pub fn zircon_handle(mut self, zircon_handle: zx_handle_t) -> Self {
        self.zircon_handle = zircon_handle;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSemaphoreGetZirconHandleInfoFUCHSIA.html>"]
pub struct SemaphoreGetZirconHandleInfoFUCHSIA<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub semaphore: Semaphore,
    pub handle_type: ExternalSemaphoreHandleTypeFlags,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for SemaphoreGetZirconHandleInfoFUCHSIA<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            semaphore: Semaphore::default(),
            handle_type: ExternalSemaphoreHandleTypeFlags::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for SemaphoreGetZirconHandleInfoFUCHSIA<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::SEMAPHORE_GET_ZIRCON_HANDLE_INFO_FUCHSIA;
}
impl<'a> SemaphoreGetZirconHandleInfoFUCHSIA<'a> {
    #[inline]
    pub fn semaphore(mut self, semaphore: Semaphore) -> Self {
        self.semaphore = semaphore;
        self
    }
    #[inline]
    pub fn handle_type(mut self, handle_type: ExternalSemaphoreHandleTypeFlags) -> Self {
        self.handle_type = handle_type;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceExternalFenceInfo.html>"]
pub struct PhysicalDeviceExternalFenceInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub handle_type: ExternalFenceHandleTypeFlags,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceExternalFenceInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            handle_type: ExternalFenceHandleTypeFlags::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceExternalFenceInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO;
}
impl<'a> PhysicalDeviceExternalFenceInfo<'a> {
    #[inline]
    pub fn handle_type(mut self, handle_type: ExternalFenceHandleTypeFlags) -> Self {
        self.handle_type = handle_type;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExternalFenceProperties.html>"]
pub struct ExternalFenceProperties<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub export_from_imported_handle_types: ExternalFenceHandleTypeFlags,
    pub compatible_handle_types: ExternalFenceHandleTypeFlags,
    pub external_fence_features: ExternalFenceFeatureFlags,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for ExternalFenceProperties<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            export_from_imported_handle_types: ExternalFenceHandleTypeFlags::default(),
            compatible_handle_types: ExternalFenceHandleTypeFlags::default(),
            external_fence_features: ExternalFenceFeatureFlags::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for ExternalFenceProperties<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::EXTERNAL_FENCE_PROPERTIES;
}
impl<'a> ExternalFenceProperties<'a> {
    #[inline]
    pub fn export_from_imported_handle_types(
        mut self,
        export_from_imported_handle_types: ExternalFenceHandleTypeFlags,
    ) -> Self {
        self.export_from_imported_handle_types = export_from_imported_handle_types;
        self
    }
    #[inline]
    pub fn compatible_handle_types(
        mut self,
        compatible_handle_types: ExternalFenceHandleTypeFlags,
    ) -> Self {
        self.compatible_handle_types = compatible_handle_types;
        self
    }
    #[inline]
    pub fn external_fence_features(
        mut self,
        external_fence_features: ExternalFenceFeatureFlags,
    ) -> Self {
        self.external_fence_features = external_fence_features;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExportFenceCreateInfo.html>"]
pub struct ExportFenceCreateInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub handle_types: ExternalFenceHandleTypeFlags,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for ExportFenceCreateInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            handle_types: ExternalFenceHandleTypeFlags::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for ExportFenceCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::EXPORT_FENCE_CREATE_INFO;
}
unsafe impl ExtendsFenceCreateInfo for ExportFenceCreateInfo<'_> {}
impl<'a> ExportFenceCreateInfo<'a> {
    #[inline]
    pub fn handle_types(mut self, handle_types: ExternalFenceHandleTypeFlags) -> Self {
        self.handle_types = handle_types;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImportFenceWin32HandleInfoKHR.html>"]
pub struct ImportFenceWin32HandleInfoKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub fence: Fence,
    pub flags: FenceImportFlags,
    pub handle_type: ExternalFenceHandleTypeFlags,
    pub handle: HANDLE,
    pub name: LPCWSTR,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for ImportFenceWin32HandleInfoKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            fence: Fence::default(),
            flags: FenceImportFlags::default(),
            handle_type: ExternalFenceHandleTypeFlags::default(),
            handle: unsafe { ::std::mem::zeroed() },
            name: unsafe { ::std::mem::zeroed() },
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for ImportFenceWin32HandleInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::IMPORT_FENCE_WIN32_HANDLE_INFO_KHR;
}
impl<'a> ImportFenceWin32HandleInfoKHR<'a> {
    #[inline]
    pub fn fence(mut self, fence: Fence) -> Self {
        self.fence = fence;
        self
    }
    #[inline]
    pub fn flags(mut self, flags: FenceImportFlags) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn handle_type(mut self, handle_type: ExternalFenceHandleTypeFlags) -> Self {
        self.handle_type = handle_type;
        self
    }
    #[inline]
    pub fn handle(mut self, handle: HANDLE) -> Self {
        self.handle = handle;
        self
    }
    #[inline]
    pub fn name(mut self, name: LPCWSTR) -> Self {
        self.name = name;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExportFenceWin32HandleInfoKHR.html>"]
pub struct ExportFenceWin32HandleInfoKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub p_attributes: *const SECURITY_ATTRIBUTES,
    pub dw_access: DWORD,
    pub name: LPCWSTR,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for ExportFenceWin32HandleInfoKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            p_attributes: ::std::ptr::null(),
            dw_access: DWORD::default(),
            name: unsafe { ::std::mem::zeroed() },
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for ExportFenceWin32HandleInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::EXPORT_FENCE_WIN32_HANDLE_INFO_KHR;
}
unsafe impl ExtendsFenceCreateInfo for ExportFenceWin32HandleInfoKHR<'_> {}
impl<'a> ExportFenceWin32HandleInfoKHR<'a> {
    #[inline]
    pub fn attributes(mut self, attributes: &'a SECURITY_ATTRIBUTES) -> Self {
        self.p_attributes = attributes;
        self
    }
    #[inline]
    pub fn dw_access(mut self, dw_access: DWORD) -> Self {
        self.dw_access = dw_access;
        self
    }
    #[inline]
    pub fn name(mut self, name: LPCWSTR) -> Self {
        self.name = name;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFenceGetWin32HandleInfoKHR.html>"]
pub struct FenceGetWin32HandleInfoKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub fence: Fence,
    pub handle_type: ExternalFenceHandleTypeFlags,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for FenceGetWin32HandleInfoKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            fence: Fence::default(),
            handle_type: ExternalFenceHandleTypeFlags::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for FenceGetWin32HandleInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::FENCE_GET_WIN32_HANDLE_INFO_KHR;
}
impl<'a> FenceGetWin32HandleInfoKHR<'a> {
    #[inline]
    pub fn fence(mut self, fence: Fence) -> Self {
        self.fence = fence;
        self
    }
    #[inline]
    pub fn handle_type(mut self, handle_type: ExternalFenceHandleTypeFlags) -> Self {
        self.handle_type = handle_type;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImportFenceFdInfoKHR.html>"]
pub struct ImportFenceFdInfoKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub fence: Fence,
    pub flags: FenceImportFlags,
    pub handle_type: ExternalFenceHandleTypeFlags,
    pub fd: c_int,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for ImportFenceFdInfoKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            fence: Fence::default(),
            flags: FenceImportFlags::default(),
            handle_type: ExternalFenceHandleTypeFlags::default(),
            fd: c_int::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for ImportFenceFdInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::IMPORT_FENCE_FD_INFO_KHR;
}
impl<'a> ImportFenceFdInfoKHR<'a> {
    #[inline]
    pub fn fence(mut self, fence: Fence) -> Self {
        self.fence = fence;
        self
    }
    #[inline]
    pub fn flags(mut self, flags: FenceImportFlags) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn handle_type(mut self, handle_type: ExternalFenceHandleTypeFlags) -> Self {
        self.handle_type = handle_type;
        self
    }
    #[inline]
    pub fn fd(mut self, fd: c_int) -> Self {
        self.fd = fd;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFenceGetFdInfoKHR.html>"]
pub struct FenceGetFdInfoKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub fence: Fence,
    pub handle_type: ExternalFenceHandleTypeFlags,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for FenceGetFdInfoKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            fence: Fence::default(),
            handle_type: ExternalFenceHandleTypeFlags::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for FenceGetFdInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::FENCE_GET_FD_INFO_KHR;
}
impl<'a> FenceGetFdInfoKHR<'a> {
    #[inline]
    pub fn fence(mut self, fence: Fence) -> Self {
        self.fence = fence;
        self
    }
    #[inline]
    pub fn handle_type(mut self, handle_type: ExternalFenceHandleTypeFlags) -> Self {
        self.handle_type = handle_type;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMultiviewFeatures.html>"]
pub struct PhysicalDeviceMultiviewFeatures<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub multiview: Bool32,
    pub multiview_geometry_shader: Bool32,
    pub multiview_tessellation_shader: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceMultiviewFeatures<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            multiview: Bool32::default(),
            multiview_geometry_shader: Bool32::default(),
            multiview_tessellation_shader: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceMultiviewFeatures<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_MULTIVIEW_FEATURES;
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceMultiviewFeatures<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceMultiviewFeatures<'_> {}
impl<'a> PhysicalDeviceMultiviewFeatures<'a> {
    #[inline]
    pub fn multiview(mut self, multiview: bool) -> Self {
        self.multiview = multiview.into();
        self
    }
    #[inline]
    pub fn multiview_geometry_shader(mut self, multiview_geometry_shader: bool) -> Self {
        self.multiview_geometry_shader = multiview_geometry_shader.into();
        self
    }
    #[inline]
    pub fn multiview_tessellation_shader(mut self, multiview_tessellation_shader: bool) -> Self {
        self.multiview_tessellation_shader = multiview_tessellation_shader.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMultiviewProperties.html>"]
pub struct PhysicalDeviceMultiviewProperties<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub max_multiview_view_count: u32,
    pub max_multiview_instance_index: u32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceMultiviewProperties<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            max_multiview_view_count: u32::default(),
            max_multiview_instance_index: u32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceMultiviewProperties<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES;
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceMultiviewProperties<'_> {}
impl<'a> PhysicalDeviceMultiviewProperties<'a> {
    #[inline]
    pub fn max_multiview_view_count(mut self, max_multiview_view_count: u32) -> Self {
        self.max_multiview_view_count = max_multiview_view_count;
        self
    }
    #[inline]
    pub fn max_multiview_instance_index(mut self, max_multiview_instance_index: u32) -> Self {
        self.max_multiview_instance_index = max_multiview_instance_index;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderPassMultiviewCreateInfo.html>"]
pub struct RenderPassMultiviewCreateInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub subpass_count: u32,
    pub p_view_masks: *const u32,
    pub dependency_count: u32,
    pub p_view_offsets: *const i32,
    pub correlation_mask_count: u32,
    pub p_correlation_masks: *const u32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for RenderPassMultiviewCreateInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            subpass_count: u32::default(),
            p_view_masks: ::std::ptr::null(),
            dependency_count: u32::default(),
            p_view_offsets: ::std::ptr::null(),
            correlation_mask_count: u32::default(),
            p_correlation_masks: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for RenderPassMultiviewCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::RENDER_PASS_MULTIVIEW_CREATE_INFO;
}
unsafe impl ExtendsRenderPassCreateInfo for RenderPassMultiviewCreateInfo<'_> {}
impl<'a> RenderPassMultiviewCreateInfo<'a> {
    #[inline]
    pub fn view_masks(mut self, view_masks: &'a [u32]) -> Self {
        self.subpass_count = view_masks.len() as _;
        self.p_view_masks = view_masks.as_ptr();
        self
    }
    #[inline]
    pub fn view_offsets(mut self, view_offsets: &'a [i32]) -> Self {
        self.dependency_count = view_offsets.len() as _;
        self.p_view_offsets = view_offsets.as_ptr();
        self
    }
    #[inline]
    pub fn correlation_masks(mut self, correlation_masks: &'a [u32]) -> Self {
        self.correlation_mask_count = correlation_masks.len() as _;
        self.p_correlation_masks = correlation_masks.as_ptr();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSurfaceCapabilities2EXT.html>"]
pub struct SurfaceCapabilities2EXT<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub min_image_count: u32,
    pub max_image_count: u32,
    pub current_extent: Extent2D,
    pub min_image_extent: Extent2D,
    pub max_image_extent: Extent2D,
    pub max_image_array_layers: u32,
    pub supported_transforms: SurfaceTransformFlagsKHR,
    pub current_transform: SurfaceTransformFlagsKHR,
    pub supported_composite_alpha: CompositeAlphaFlagsKHR,
    pub supported_usage_flags: ImageUsageFlags,
    pub supported_surface_counters: SurfaceCounterFlagsEXT,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for SurfaceCapabilities2EXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            min_image_count: u32::default(),
            max_image_count: u32::default(),
            current_extent: Extent2D::default(),
            min_image_extent: Extent2D::default(),
            max_image_extent: Extent2D::default(),
            max_image_array_layers: u32::default(),
            supported_transforms: SurfaceTransformFlagsKHR::default(),
            current_transform: SurfaceTransformFlagsKHR::default(),
            supported_composite_alpha: CompositeAlphaFlagsKHR::default(),
            supported_usage_flags: ImageUsageFlags::default(),
            supported_surface_counters: SurfaceCounterFlagsEXT::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for SurfaceCapabilities2EXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::SURFACE_CAPABILITIES_2_EXT;
}
impl<'a> SurfaceCapabilities2EXT<'a> {
    #[inline]
    pub fn min_image_count(mut self, min_image_count: u32) -> Self {
        self.min_image_count = min_image_count;
        self
    }
    #[inline]
    pub fn max_image_count(mut self, max_image_count: u32) -> Self {
        self.max_image_count = max_image_count;
        self
    }
    #[inline]
    pub fn current_extent(mut self, current_extent: Extent2D) -> Self {
        self.current_extent = current_extent;
        self
    }
    #[inline]
    pub fn min_image_extent(mut self, min_image_extent: Extent2D) -> Self {
        self.min_image_extent = min_image_extent;
        self
    }
    #[inline]
    pub fn max_image_extent(mut self, max_image_extent: Extent2D) -> Self {
        self.max_image_extent = max_image_extent;
        self
    }
    #[inline]
    pub fn max_image_array_layers(mut self, max_image_array_layers: u32) -> Self {
        self.max_image_array_layers = max_image_array_layers;
        self
    }
    #[inline]
    pub fn supported_transforms(mut self, supported_transforms: SurfaceTransformFlagsKHR) -> Self {
        self.supported_transforms = supported_transforms;
        self
    }
    #[inline]
    pub fn current_transform(mut self, current_transform: SurfaceTransformFlagsKHR) -> Self {
        self.current_transform = current_transform;
        self
    }
    #[inline]
    pub fn supported_composite_alpha(
        mut self,
        supported_composite_alpha: CompositeAlphaFlagsKHR,
    ) -> Self {
        self.supported_composite_alpha = supported_composite_alpha;
        self
    }
    #[inline]
    pub fn supported_usage_flags(mut self, supported_usage_flags: ImageUsageFlags) -> Self {
        self.supported_usage_flags = supported_usage_flags;
        self
    }
    #[inline]
    pub fn supported_surface_counters(
        mut self,
        supported_surface_counters: SurfaceCounterFlagsEXT,
    ) -> Self {
        self.supported_surface_counters = supported_surface_counters;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplayPowerInfoEXT.html>"]
pub struct DisplayPowerInfoEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub power_state: DisplayPowerStateEXT,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for DisplayPowerInfoEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            power_state: DisplayPowerStateEXT::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for DisplayPowerInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DISPLAY_POWER_INFO_EXT;
}
impl<'a> DisplayPowerInfoEXT<'a> {
    #[inline]
    pub fn power_state(mut self, power_state: DisplayPowerStateEXT) -> Self {
        self.power_state = power_state;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceEventInfoEXT.html>"]
pub struct DeviceEventInfoEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub device_event: DeviceEventTypeEXT,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for DeviceEventInfoEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            device_event: DeviceEventTypeEXT::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for DeviceEventInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DEVICE_EVENT_INFO_EXT;
}
impl<'a> DeviceEventInfoEXT<'a> {
    #[inline]
    pub fn device_event(mut self, device_event: DeviceEventTypeEXT) -> Self {
        self.device_event = device_event;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplayEventInfoEXT.html>"]
pub struct DisplayEventInfoEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub display_event: DisplayEventTypeEXT,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for DisplayEventInfoEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            display_event: DisplayEventTypeEXT::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for DisplayEventInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DISPLAY_EVENT_INFO_EXT;
}
impl<'a> DisplayEventInfoEXT<'a> {
    #[inline]
    pub fn display_event(mut self, display_event: DisplayEventTypeEXT) -> Self {
        self.display_event = display_event;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSwapchainCounterCreateInfoEXT.html>"]
pub struct SwapchainCounterCreateInfoEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub surface_counters: SurfaceCounterFlagsEXT,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for SwapchainCounterCreateInfoEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            surface_counters: SurfaceCounterFlagsEXT::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for SwapchainCounterCreateInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::SWAPCHAIN_COUNTER_CREATE_INFO_EXT;
}
unsafe impl ExtendsSwapchainCreateInfoKHR for SwapchainCounterCreateInfoEXT<'_> {}
impl<'a> SwapchainCounterCreateInfoEXT<'a> {
    #[inline]
    pub fn surface_counters(mut self, surface_counters: SurfaceCounterFlagsEXT) -> Self {
        self.surface_counters = surface_counters;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceGroupProperties.html>"]
pub struct PhysicalDeviceGroupProperties<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub physical_device_count: u32,
    pub physical_devices: [PhysicalDevice; MAX_DEVICE_GROUP_SIZE],
    pub subset_allocation: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceGroupProperties<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            physical_device_count: u32::default(),
            physical_devices: unsafe { ::std::mem::zeroed() },
            subset_allocation: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceGroupProperties<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_GROUP_PROPERTIES;
}
impl<'a> PhysicalDeviceGroupProperties<'a> {
    #[inline]
    pub fn physical_device_count(mut self, physical_device_count: u32) -> Self {
        self.physical_device_count = physical_device_count;
        self
    }
    #[inline]
    pub fn physical_devices(
        mut self,
        physical_devices: [PhysicalDevice; MAX_DEVICE_GROUP_SIZE],
    ) -> Self {
        self.physical_devices = physical_devices;
        self
    }
    #[inline]
    pub fn subset_allocation(mut self, subset_allocation: bool) -> Self {
        self.subset_allocation = subset_allocation.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryAllocateFlagsInfo.html>"]
pub struct MemoryAllocateFlagsInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: MemoryAllocateFlags,
    pub device_mask: u32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for MemoryAllocateFlagsInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: MemoryAllocateFlags::default(),
            device_mask: u32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for MemoryAllocateFlagsInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::MEMORY_ALLOCATE_FLAGS_INFO;
}
unsafe impl ExtendsMemoryAllocateInfo for MemoryAllocateFlagsInfo<'_> {}
impl<'a> MemoryAllocateFlagsInfo<'a> {
    #[inline]
    pub fn flags(mut self, flags: MemoryAllocateFlags) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn device_mask(mut self, device_mask: u32) -> Self {
        self.device_mask = device_mask;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBindBufferMemoryInfo.html>"]
pub struct BindBufferMemoryInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub buffer: Buffer,
    pub memory: DeviceMemory,
    pub memory_offset: DeviceSize,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for BindBufferMemoryInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            buffer: Buffer::default(),
            memory: DeviceMemory::default(),
            memory_offset: DeviceSize::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for BindBufferMemoryInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::BIND_BUFFER_MEMORY_INFO;
}
pub unsafe trait ExtendsBindBufferMemoryInfo {}
impl<'a> BindBufferMemoryInfo<'a> {
    #[inline]
    pub fn buffer(mut self, buffer: Buffer) -> Self {
        self.buffer = buffer;
        self
    }
    #[inline]
    pub fn memory(mut self, memory: DeviceMemory) -> Self {
        self.memory = memory;
        self
    }
    #[inline]
    pub fn memory_offset(mut self, memory_offset: DeviceSize) -> Self {
        self.memory_offset = memory_offset;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `x.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsBindBufferMemoryInfo>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.p_next as _;
            self.p_next = next_ptr;
        }
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBindBufferMemoryDeviceGroupInfo.html>"]
pub struct BindBufferMemoryDeviceGroupInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub device_index_count: u32,
    pub p_device_indices: *const u32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for BindBufferMemoryDeviceGroupInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            device_index_count: u32::default(),
            p_device_indices: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for BindBufferMemoryDeviceGroupInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO;
}
unsafe impl ExtendsBindBufferMemoryInfo for BindBufferMemoryDeviceGroupInfo<'_> {}
impl<'a> BindBufferMemoryDeviceGroupInfo<'a> {
    #[inline]
    pub fn device_indices(mut self, device_indices: &'a [u32]) -> Self {
        self.device_index_count = device_indices.len() as _;
        self.p_device_indices = device_indices.as_ptr();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBindImageMemoryInfo.html>"]
pub struct BindImageMemoryInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub image: Image,
    pub memory: DeviceMemory,
    pub memory_offset: DeviceSize,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for BindImageMemoryInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            image: Image::default(),
            memory: DeviceMemory::default(),
            memory_offset: DeviceSize::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for BindImageMemoryInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::BIND_IMAGE_MEMORY_INFO;
}
pub unsafe trait ExtendsBindImageMemoryInfo {}
impl<'a> BindImageMemoryInfo<'a> {
    #[inline]
    pub fn image(mut self, image: Image) -> Self {
        self.image = image;
        self
    }
    #[inline]
    pub fn memory(mut self, memory: DeviceMemory) -> Self {
        self.memory = memory;
        self
    }
    #[inline]
    pub fn memory_offset(mut self, memory_offset: DeviceSize) -> Self {
        self.memory_offset = memory_offset;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `x.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsBindImageMemoryInfo>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.p_next as _;
            self.p_next = next_ptr;
        }
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBindImageMemoryDeviceGroupInfo.html>"]
pub struct BindImageMemoryDeviceGroupInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub device_index_count: u32,
    pub p_device_indices: *const u32,
    pub split_instance_bind_region_count: u32,
    pub p_split_instance_bind_regions: *const Rect2D,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for BindImageMemoryDeviceGroupInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            device_index_count: u32::default(),
            p_device_indices: ::std::ptr::null(),
            split_instance_bind_region_count: u32::default(),
            p_split_instance_bind_regions: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for BindImageMemoryDeviceGroupInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO;
}
unsafe impl ExtendsBindImageMemoryInfo for BindImageMemoryDeviceGroupInfo<'_> {}
impl<'a> BindImageMemoryDeviceGroupInfo<'a> {
    #[inline]
    pub fn device_indices(mut self, device_indices: &'a [u32]) -> Self {
        self.device_index_count = device_indices.len() as _;
        self.p_device_indices = device_indices.as_ptr();
        self
    }
    #[inline]
    pub fn split_instance_bind_regions(
        mut self,
        split_instance_bind_regions: &'a [Rect2D],
    ) -> Self {
        self.split_instance_bind_region_count = split_instance_bind_regions.len() as _;
        self.p_split_instance_bind_regions = split_instance_bind_regions.as_ptr();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceGroupRenderPassBeginInfo.html>"]
pub struct DeviceGroupRenderPassBeginInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub device_mask: u32,
    pub device_render_area_count: u32,
    pub p_device_render_areas: *const Rect2D,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for DeviceGroupRenderPassBeginInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            device_mask: u32::default(),
            device_render_area_count: u32::default(),
            p_device_render_areas: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for DeviceGroupRenderPassBeginInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DEVICE_GROUP_RENDER_PASS_BEGIN_INFO;
}
unsafe impl ExtendsRenderPassBeginInfo for DeviceGroupRenderPassBeginInfo<'_> {}
unsafe impl ExtendsRenderingInfo for DeviceGroupRenderPassBeginInfo<'_> {}
impl<'a> DeviceGroupRenderPassBeginInfo<'a> {
    #[inline]
    pub fn device_mask(mut self, device_mask: u32) -> Self {
        self.device_mask = device_mask;
        self
    }
    #[inline]
    pub fn device_render_areas(mut self, device_render_areas: &'a [Rect2D]) -> Self {
        self.device_render_area_count = device_render_areas.len() as _;
        self.p_device_render_areas = device_render_areas.as_ptr();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceGroupCommandBufferBeginInfo.html>"]
pub struct DeviceGroupCommandBufferBeginInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub device_mask: u32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for DeviceGroupCommandBufferBeginInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            device_mask: u32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for DeviceGroupCommandBufferBeginInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO;
}
unsafe impl ExtendsCommandBufferBeginInfo for DeviceGroupCommandBufferBeginInfo<'_> {}
impl<'a> DeviceGroupCommandBufferBeginInfo<'a> {
    #[inline]
    pub fn device_mask(mut self, device_mask: u32) -> Self {
        self.device_mask = device_mask;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceGroupSubmitInfo.html>"]
pub struct DeviceGroupSubmitInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub wait_semaphore_count: u32,
    pub p_wait_semaphore_device_indices: *const u32,
    pub command_buffer_count: u32,
    pub p_command_buffer_device_masks: *const u32,
    pub signal_semaphore_count: u32,
    pub p_signal_semaphore_device_indices: *const u32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for DeviceGroupSubmitInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            wait_semaphore_count: u32::default(),
            p_wait_semaphore_device_indices: ::std::ptr::null(),
            command_buffer_count: u32::default(),
            p_command_buffer_device_masks: ::std::ptr::null(),
            signal_semaphore_count: u32::default(),
            p_signal_semaphore_device_indices: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for DeviceGroupSubmitInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DEVICE_GROUP_SUBMIT_INFO;
}
unsafe impl ExtendsSubmitInfo for DeviceGroupSubmitInfo<'_> {}
impl<'a> DeviceGroupSubmitInfo<'a> {
    #[inline]
    pub fn wait_semaphore_device_indices(
        mut self,
        wait_semaphore_device_indices: &'a [u32],
    ) -> Self {
        self.wait_semaphore_count = wait_semaphore_device_indices.len() as _;
        self.p_wait_semaphore_device_indices = wait_semaphore_device_indices.as_ptr();
        self
    }
    #[inline]
    pub fn command_buffer_device_masks(mut self, command_buffer_device_masks: &'a [u32]) -> Self {
        self.command_buffer_count = command_buffer_device_masks.len() as _;
        self.p_command_buffer_device_masks = command_buffer_device_masks.as_ptr();
        self
    }
    #[inline]
    pub fn signal_semaphore_device_indices(
        mut self,
        signal_semaphore_device_indices: &'a [u32],
    ) -> Self {
        self.signal_semaphore_count = signal_semaphore_device_indices.len() as _;
        self.p_signal_semaphore_device_indices = signal_semaphore_device_indices.as_ptr();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceGroupBindSparseInfo.html>"]
pub struct DeviceGroupBindSparseInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub resource_device_index: u32,
    pub memory_device_index: u32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for DeviceGroupBindSparseInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            resource_device_index: u32::default(),
            memory_device_index: u32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for DeviceGroupBindSparseInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DEVICE_GROUP_BIND_SPARSE_INFO;
}
unsafe impl ExtendsBindSparseInfo for DeviceGroupBindSparseInfo<'_> {}
impl<'a> DeviceGroupBindSparseInfo<'a> {
    #[inline]
    pub fn resource_device_index(mut self, resource_device_index: u32) -> Self {
        self.resource_device_index = resource_device_index;
        self
    }
    #[inline]
    pub fn memory_device_index(mut self, memory_device_index: u32) -> Self {
        self.memory_device_index = memory_device_index;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceGroupPresentCapabilitiesKHR.html>"]
pub struct DeviceGroupPresentCapabilitiesKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub present_mask: [u32; MAX_DEVICE_GROUP_SIZE],
    pub modes: DeviceGroupPresentModeFlagsKHR,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for DeviceGroupPresentCapabilitiesKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            present_mask: unsafe { ::std::mem::zeroed() },
            modes: DeviceGroupPresentModeFlagsKHR::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for DeviceGroupPresentCapabilitiesKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DEVICE_GROUP_PRESENT_CAPABILITIES_KHR;
}
impl<'a> DeviceGroupPresentCapabilitiesKHR<'a> {
    #[inline]
    pub fn present_mask(mut self, present_mask: [u32; MAX_DEVICE_GROUP_SIZE]) -> Self {
        self.present_mask = present_mask;
        self
    }
    #[inline]
    pub fn modes(mut self, modes: DeviceGroupPresentModeFlagsKHR) -> Self {
        self.modes = modes;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageSwapchainCreateInfoKHR.html>"]
pub struct ImageSwapchainCreateInfoKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub swapchain: SwapchainKHR,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for ImageSwapchainCreateInfoKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            swapchain: SwapchainKHR::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for ImageSwapchainCreateInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::IMAGE_SWAPCHAIN_CREATE_INFO_KHR;
}
unsafe impl ExtendsImageCreateInfo for ImageSwapchainCreateInfoKHR<'_> {}
impl<'a> ImageSwapchainCreateInfoKHR<'a> {
    #[inline]
    pub fn swapchain(mut self, swapchain: SwapchainKHR) -> Self {
        self.swapchain = swapchain;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBindImageMemorySwapchainInfoKHR.html>"]
pub struct BindImageMemorySwapchainInfoKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub swapchain: SwapchainKHR,
    pub image_index: u32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for BindImageMemorySwapchainInfoKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            swapchain: SwapchainKHR::default(),
            image_index: u32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for BindImageMemorySwapchainInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR;
}
unsafe impl ExtendsBindImageMemoryInfo for BindImageMemorySwapchainInfoKHR<'_> {}
impl<'a> BindImageMemorySwapchainInfoKHR<'a> {
    #[inline]
    pub fn swapchain(mut self, swapchain: SwapchainKHR) -> Self {
        self.swapchain = swapchain;
        self
    }
    #[inline]
    pub fn image_index(mut self, image_index: u32) -> Self {
        self.image_index = image_index;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAcquireNextImageInfoKHR.html>"]
pub struct AcquireNextImageInfoKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub swapchain: SwapchainKHR,
    pub timeout: u64,
    pub semaphore: Semaphore,
    pub fence: Fence,
    pub device_mask: u32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for AcquireNextImageInfoKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            swapchain: SwapchainKHR::default(),
            timeout: u64::default(),
            semaphore: Semaphore::default(),
            fence: Fence::default(),
            device_mask: u32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for AcquireNextImageInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ACQUIRE_NEXT_IMAGE_INFO_KHR;
}
impl<'a> AcquireNextImageInfoKHR<'a> {
    #[inline]
    pub fn swapchain(mut self, swapchain: SwapchainKHR) -> Self {
        self.swapchain = swapchain;
        self
    }
    #[inline]
    pub fn timeout(mut self, timeout: u64) -> Self {
        self.timeout = timeout;
        self
    }
    #[inline]
    pub fn semaphore(mut self, semaphore: Semaphore) -> Self {
        self.semaphore = semaphore;
        self
    }
    #[inline]
    pub fn fence(mut self, fence: Fence) -> Self {
        self.fence = fence;
        self
    }
    #[inline]
    pub fn device_mask(mut self, device_mask: u32) -> Self {
        self.device_mask = device_mask;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceGroupPresentInfoKHR.html>"]
pub struct DeviceGroupPresentInfoKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub swapchain_count: u32,
    pub p_device_masks: *const u32,
    pub mode: DeviceGroupPresentModeFlagsKHR,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for DeviceGroupPresentInfoKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            swapchain_count: u32::default(),
            p_device_masks: ::std::ptr::null(),
            mode: DeviceGroupPresentModeFlagsKHR::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for DeviceGroupPresentInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DEVICE_GROUP_PRESENT_INFO_KHR;
}
unsafe impl ExtendsPresentInfoKHR for DeviceGroupPresentInfoKHR<'_> {}
impl<'a> DeviceGroupPresentInfoKHR<'a> {
    #[inline]
    pub fn device_masks(mut self, device_masks: &'a [u32]) -> Self {
        self.swapchain_count = device_masks.len() as _;
        self.p_device_masks = device_masks.as_ptr();
        self
    }
    #[inline]
    pub fn mode(mut self, mode: DeviceGroupPresentModeFlagsKHR) -> Self {
        self.mode = mode;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceGroupDeviceCreateInfo.html>"]
pub struct DeviceGroupDeviceCreateInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub physical_device_count: u32,
    pub p_physical_devices: *const PhysicalDevice,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for DeviceGroupDeviceCreateInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            physical_device_count: u32::default(),
            p_physical_devices: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for DeviceGroupDeviceCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DEVICE_GROUP_DEVICE_CREATE_INFO;
}
unsafe impl ExtendsDeviceCreateInfo for DeviceGroupDeviceCreateInfo<'_> {}
impl<'a> DeviceGroupDeviceCreateInfo<'a> {
    #[inline]
    pub fn physical_devices(mut self, physical_devices: &'a [PhysicalDevice]) -> Self {
        self.physical_device_count = physical_devices.len() as _;
        self.p_physical_devices = physical_devices.as_ptr();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceGroupSwapchainCreateInfoKHR.html>"]
pub struct DeviceGroupSwapchainCreateInfoKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub modes: DeviceGroupPresentModeFlagsKHR,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for DeviceGroupSwapchainCreateInfoKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            modes: DeviceGroupPresentModeFlagsKHR::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for DeviceGroupSwapchainCreateInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR;
}
unsafe impl ExtendsSwapchainCreateInfoKHR for DeviceGroupSwapchainCreateInfoKHR<'_> {}
impl<'a> DeviceGroupSwapchainCreateInfoKHR<'a> {
    #[inline]
    pub fn modes(mut self, modes: DeviceGroupPresentModeFlagsKHR) -> Self {
        self.modes = modes;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorUpdateTemplateEntry.html>"]
pub struct DescriptorUpdateTemplateEntry {
    pub dst_binding: u32,
    pub dst_array_element: u32,
    pub descriptor_count: u32,
    pub descriptor_type: DescriptorType,
    pub offset: usize,
    pub stride: usize,
}
impl DescriptorUpdateTemplateEntry {
    #[inline]
    pub fn dst_binding(mut self, dst_binding: u32) -> Self {
        self.dst_binding = dst_binding;
        self
    }
    #[inline]
    pub fn dst_array_element(mut self, dst_array_element: u32) -> Self {
        self.dst_array_element = dst_array_element;
        self
    }
    #[inline]
    pub fn descriptor_count(mut self, descriptor_count: u32) -> Self {
        self.descriptor_count = descriptor_count;
        self
    }
    #[inline]
    pub fn descriptor_type(mut self, descriptor_type: DescriptorType) -> Self {
        self.descriptor_type = descriptor_type;
        self
    }
    #[inline]
    pub fn offset(mut self, offset: usize) -> Self {
        self.offset = offset;
        self
    }
    #[inline]
    pub fn stride(mut self, stride: usize) -> Self {
        self.stride = stride;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorUpdateTemplateCreateInfo.html>"]
pub struct DescriptorUpdateTemplateCreateInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: DescriptorUpdateTemplateCreateFlags,
    pub descriptor_update_entry_count: u32,
    pub p_descriptor_update_entries: *const DescriptorUpdateTemplateEntry,
    pub template_type: DescriptorUpdateTemplateType,
    pub descriptor_set_layout: DescriptorSetLayout,
    pub pipeline_bind_point: PipelineBindPoint,
    pub pipeline_layout: PipelineLayout,
    pub set: u32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for DescriptorUpdateTemplateCreateInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: DescriptorUpdateTemplateCreateFlags::default(),
            descriptor_update_entry_count: u32::default(),
            p_descriptor_update_entries: ::std::ptr::null(),
            template_type: DescriptorUpdateTemplateType::default(),
            descriptor_set_layout: DescriptorSetLayout::default(),
            pipeline_bind_point: PipelineBindPoint::default(),
            pipeline_layout: PipelineLayout::default(),
            set: u32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for DescriptorUpdateTemplateCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO;
}
impl<'a> DescriptorUpdateTemplateCreateInfo<'a> {
    #[inline]
    pub fn flags(mut self, flags: DescriptorUpdateTemplateCreateFlags) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn descriptor_update_entries(
        mut self,
        descriptor_update_entries: &'a [DescriptorUpdateTemplateEntry],
    ) -> Self {
        self.descriptor_update_entry_count = descriptor_update_entries.len() as _;
        self.p_descriptor_update_entries = descriptor_update_entries.as_ptr();
        self
    }
    #[inline]
    pub fn template_type(mut self, template_type: DescriptorUpdateTemplateType) -> Self {
        self.template_type = template_type;
        self
    }
    #[inline]
    pub fn descriptor_set_layout(mut self, descriptor_set_layout: DescriptorSetLayout) -> Self {
        self.descriptor_set_layout = descriptor_set_layout;
        self
    }
    #[inline]
    pub fn pipeline_bind_point(mut self, pipeline_bind_point: PipelineBindPoint) -> Self {
        self.pipeline_bind_point = pipeline_bind_point;
        self
    }
    #[inline]
    pub fn pipeline_layout(mut self, pipeline_layout: PipelineLayout) -> Self {
        self.pipeline_layout = pipeline_layout;
        self
    }
    #[inline]
    pub fn set(mut self, set: u32) -> Self {
        self.set = set;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkXYColorEXT.html>"]
pub struct XYColorEXT {
    pub x: f32,
    pub y: f32,
}
impl XYColorEXT {
    #[inline]
    pub fn x(mut self, x: f32) -> Self {
        self.x = x;
        self
    }
    #[inline]
    pub fn y(mut self, y: f32) -> Self {
        self.y = y;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePresentIdFeaturesKHR.html>"]
pub struct PhysicalDevicePresentIdFeaturesKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub present_id: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDevicePresentIdFeaturesKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            present_id: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDevicePresentIdFeaturesKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR;
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDevicePresentIdFeaturesKHR<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDevicePresentIdFeaturesKHR<'_> {}
impl<'a> PhysicalDevicePresentIdFeaturesKHR<'a> {
    #[inline]
    pub fn present_id(mut self, present_id: bool) -> Self {
        self.present_id = present_id.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPresentIdKHR.html>"]
pub struct PresentIdKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub swapchain_count: u32,
    pub p_present_ids: *const u64,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PresentIdKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            swapchain_count: u32::default(),
            p_present_ids: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PresentIdKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PRESENT_ID_KHR;
}
unsafe impl ExtendsPresentInfoKHR for PresentIdKHR<'_> {}
impl<'a> PresentIdKHR<'a> {
    #[inline]
    pub fn present_ids(mut self, present_ids: &'a [u64]) -> Self {
        self.swapchain_count = present_ids.len() as _;
        self.p_present_ids = present_ids.as_ptr();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePresentWaitFeaturesKHR.html>"]
pub struct PhysicalDevicePresentWaitFeaturesKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub present_wait: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDevicePresentWaitFeaturesKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            present_wait: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDevicePresentWaitFeaturesKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR;
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDevicePresentWaitFeaturesKHR<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDevicePresentWaitFeaturesKHR<'_> {}
impl<'a> PhysicalDevicePresentWaitFeaturesKHR<'a> {
    #[inline]
    pub fn present_wait(mut self, present_wait: bool) -> Self {
        self.present_wait = present_wait.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkHdrMetadataEXT.html>"]
pub struct HdrMetadataEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub display_primary_red: XYColorEXT,
    pub display_primary_green: XYColorEXT,
    pub display_primary_blue: XYColorEXT,
    pub white_point: XYColorEXT,
    pub max_luminance: f32,
    pub min_luminance: f32,
    pub max_content_light_level: f32,
    pub max_frame_average_light_level: f32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for HdrMetadataEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            display_primary_red: XYColorEXT::default(),
            display_primary_green: XYColorEXT::default(),
            display_primary_blue: XYColorEXT::default(),
            white_point: XYColorEXT::default(),
            max_luminance: f32::default(),
            min_luminance: f32::default(),
            max_content_light_level: f32::default(),
            max_frame_average_light_level: f32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for HdrMetadataEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::HDR_METADATA_EXT;
}
impl<'a> HdrMetadataEXT<'a> {
    #[inline]
    pub fn display_primary_red(mut self, display_primary_red: XYColorEXT) -> Self {
        self.display_primary_red = display_primary_red;
        self
    }
    #[inline]
    pub fn display_primary_green(mut self, display_primary_green: XYColorEXT) -> Self {
        self.display_primary_green = display_primary_green;
        self
    }
    #[inline]
    pub fn display_primary_blue(mut self, display_primary_blue: XYColorEXT) -> Self {
        self.display_primary_blue = display_primary_blue;
        self
    }
    #[inline]
    pub fn white_point(mut self, white_point: XYColorEXT) -> Self {
        self.white_point = white_point;
        self
    }
    #[inline]
    pub fn max_luminance(mut self, max_luminance: f32) -> Self {
        self.max_luminance = max_luminance;
        self
    }
    #[inline]
    pub fn min_luminance(mut self, min_luminance: f32) -> Self {
        self.min_luminance = min_luminance;
        self
    }
    #[inline]
    pub fn max_content_light_level(mut self, max_content_light_level: f32) -> Self {
        self.max_content_light_level = max_content_light_level;
        self
    }
    #[inline]
    pub fn max_frame_average_light_level(mut self, max_frame_average_light_level: f32) -> Self {
        self.max_frame_average_light_level = max_frame_average_light_level;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplayNativeHdrSurfaceCapabilitiesAMD.html>"]
pub struct DisplayNativeHdrSurfaceCapabilitiesAMD<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub local_dimming_support: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for DisplayNativeHdrSurfaceCapabilitiesAMD<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            local_dimming_support: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for DisplayNativeHdrSurfaceCapabilitiesAMD<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD;
}
unsafe impl ExtendsSurfaceCapabilities2KHR for DisplayNativeHdrSurfaceCapabilitiesAMD<'_> {}
impl<'a> DisplayNativeHdrSurfaceCapabilitiesAMD<'a> {
    #[inline]
    pub fn local_dimming_support(mut self, local_dimming_support: bool) -> Self {
        self.local_dimming_support = local_dimming_support.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSwapchainDisplayNativeHdrCreateInfoAMD.html>"]
pub struct SwapchainDisplayNativeHdrCreateInfoAMD<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub local_dimming_enable: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for SwapchainDisplayNativeHdrCreateInfoAMD<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            local_dimming_enable: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for SwapchainDisplayNativeHdrCreateInfoAMD<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD;
}
unsafe impl ExtendsSwapchainCreateInfoKHR for SwapchainDisplayNativeHdrCreateInfoAMD<'_> {}
impl<'a> SwapchainDisplayNativeHdrCreateInfoAMD<'a> {
    #[inline]
    pub fn local_dimming_enable(mut self, local_dimming_enable: bool) -> Self {
        self.local_dimming_enable = local_dimming_enable.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRefreshCycleDurationGOOGLE.html>"]
pub struct RefreshCycleDurationGOOGLE {
    pub refresh_duration: u64,
}
impl RefreshCycleDurationGOOGLE {
    #[inline]
    pub fn refresh_duration(mut self, refresh_duration: u64) -> Self {
        self.refresh_duration = refresh_duration;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPastPresentationTimingGOOGLE.html>"]
pub struct PastPresentationTimingGOOGLE {
    pub present_id: u32,
    pub desired_present_time: u64,
    pub actual_present_time: u64,
    pub earliest_present_time: u64,
    pub present_margin: u64,
}
impl PastPresentationTimingGOOGLE {
    #[inline]
    pub fn present_id(mut self, present_id: u32) -> Self {
        self.present_id = present_id;
        self
    }
    #[inline]
    pub fn desired_present_time(mut self, desired_present_time: u64) -> Self {
        self.desired_present_time = desired_present_time;
        self
    }
    #[inline]
    pub fn actual_present_time(mut self, actual_present_time: u64) -> Self {
        self.actual_present_time = actual_present_time;
        self
    }
    #[inline]
    pub fn earliest_present_time(mut self, earliest_present_time: u64) -> Self {
        self.earliest_present_time = earliest_present_time;
        self
    }
    #[inline]
    pub fn present_margin(mut self, present_margin: u64) -> Self {
        self.present_margin = present_margin;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPresentTimesInfoGOOGLE.html>"]
pub struct PresentTimesInfoGOOGLE<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub swapchain_count: u32,
    pub p_times: *const PresentTimeGOOGLE,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PresentTimesInfoGOOGLE<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            swapchain_count: u32::default(),
            p_times: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PresentTimesInfoGOOGLE<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PRESENT_TIMES_INFO_GOOGLE;
}
unsafe impl ExtendsPresentInfoKHR for PresentTimesInfoGOOGLE<'_> {}
impl<'a> PresentTimesInfoGOOGLE<'a> {
    #[inline]
    pub fn times(mut self, times: &'a [PresentTimeGOOGLE]) -> Self {
        self.swapchain_count = times.len() as _;
        self.p_times = times.as_ptr();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPresentTimeGOOGLE.html>"]
pub struct PresentTimeGOOGLE {
    pub present_id: u32,
    pub desired_present_time: u64,
}
impl PresentTimeGOOGLE {
    #[inline]
    pub fn present_id(mut self, present_id: u32) -> Self {
        self.present_id = present_id;
        self
    }
    #[inline]
    pub fn desired_present_time(mut self, desired_present_time: u64) -> Self {
        self.desired_present_time = desired_present_time;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkIOSSurfaceCreateInfoMVK.html>"]
pub struct IOSSurfaceCreateInfoMVK<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: IOSSurfaceCreateFlagsMVK,
    pub p_view: *const c_void,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for IOSSurfaceCreateInfoMVK<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: IOSSurfaceCreateFlagsMVK::default(),
            p_view: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for IOSSurfaceCreateInfoMVK<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::IOS_SURFACE_CREATE_INFO_MVK;
}
impl<'a> IOSSurfaceCreateInfoMVK<'a> {
    #[inline]
    pub fn flags(mut self, flags: IOSSurfaceCreateFlagsMVK) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn view(mut self, view: *const c_void) -> Self {
        self.p_view = view;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMacOSSurfaceCreateInfoMVK.html>"]
pub struct MacOSSurfaceCreateInfoMVK<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: MacOSSurfaceCreateFlagsMVK,
    pub p_view: *const c_void,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for MacOSSurfaceCreateInfoMVK<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: MacOSSurfaceCreateFlagsMVK::default(),
            p_view: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for MacOSSurfaceCreateInfoMVK<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::MACOS_SURFACE_CREATE_INFO_MVK;
}
impl<'a> MacOSSurfaceCreateInfoMVK<'a> {
    #[inline]
    pub fn flags(mut self, flags: MacOSSurfaceCreateFlagsMVK) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn view(mut self, view: *const c_void) -> Self {
        self.p_view = view;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMetalSurfaceCreateInfoEXT.html>"]
pub struct MetalSurfaceCreateInfoEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: MetalSurfaceCreateFlagsEXT,
    pub p_layer: *const CAMetalLayer,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for MetalSurfaceCreateInfoEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: MetalSurfaceCreateFlagsEXT::default(),
            p_layer: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for MetalSurfaceCreateInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::METAL_SURFACE_CREATE_INFO_EXT;
}
impl<'a> MetalSurfaceCreateInfoEXT<'a> {
    #[inline]
    pub fn flags(mut self, flags: MetalSurfaceCreateFlagsEXT) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn layer(mut self, layer: *const CAMetalLayer) -> Self {
        self.p_layer = layer;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkViewportWScalingNV.html>"]
pub struct ViewportWScalingNV {
    pub xcoeff: f32,
    pub ycoeff: f32,
}
impl ViewportWScalingNV {
    #[inline]
    pub fn xcoeff(mut self, xcoeff: f32) -> Self {
        self.xcoeff = xcoeff;
        self
    }
    #[inline]
    pub fn ycoeff(mut self, ycoeff: f32) -> Self {
        self.ycoeff = ycoeff;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineViewportWScalingStateCreateInfoNV.html>"]
pub struct PipelineViewportWScalingStateCreateInfoNV<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub viewport_w_scaling_enable: Bool32,
    pub viewport_count: u32,
    pub p_viewport_w_scalings: *const ViewportWScalingNV,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PipelineViewportWScalingStateCreateInfoNV<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            viewport_w_scaling_enable: Bool32::default(),
            viewport_count: u32::default(),
            p_viewport_w_scalings: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PipelineViewportWScalingStateCreateInfoNV<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV;
}
unsafe impl ExtendsPipelineViewportStateCreateInfo
    for PipelineViewportWScalingStateCreateInfoNV<'_>
{
}
impl<'a> PipelineViewportWScalingStateCreateInfoNV<'a> {
    #[inline]
    pub fn viewport_w_scaling_enable(mut self, viewport_w_scaling_enable: bool) -> Self {
        self.viewport_w_scaling_enable = viewport_w_scaling_enable.into();
        self
    }
    #[inline]
    pub fn viewport_w_scalings(mut self, viewport_w_scalings: &'a [ViewportWScalingNV]) -> Self {
        self.viewport_count = viewport_w_scalings.len() as _;
        self.p_viewport_w_scalings = viewport_w_scalings.as_ptr();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkViewportSwizzleNV.html>"]
pub struct ViewportSwizzleNV {
    pub x: ViewportCoordinateSwizzleNV,
    pub y: ViewportCoordinateSwizzleNV,
    pub z: ViewportCoordinateSwizzleNV,
    pub w: ViewportCoordinateSwizzleNV,
}
impl ViewportSwizzleNV {
    #[inline]
    pub fn x(mut self, x: ViewportCoordinateSwizzleNV) -> Self {
        self.x = x;
        self
    }
    #[inline]
    pub fn y(mut self, y: ViewportCoordinateSwizzleNV) -> Self {
        self.y = y;
        self
    }
    #[inline]
    pub fn z(mut self, z: ViewportCoordinateSwizzleNV) -> Self {
        self.z = z;
        self
    }
    #[inline]
    pub fn w(mut self, w: ViewportCoordinateSwizzleNV) -> Self {
        self.w = w;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineViewportSwizzleStateCreateInfoNV.html>"]
pub struct PipelineViewportSwizzleStateCreateInfoNV<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: PipelineViewportSwizzleStateCreateFlagsNV,
    pub viewport_count: u32,
    pub p_viewport_swizzles: *const ViewportSwizzleNV,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PipelineViewportSwizzleStateCreateInfoNV<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: PipelineViewportSwizzleStateCreateFlagsNV::default(),
            viewport_count: u32::default(),
            p_viewport_swizzles: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PipelineViewportSwizzleStateCreateInfoNV<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV;
}
unsafe impl ExtendsPipelineViewportStateCreateInfo
    for PipelineViewportSwizzleStateCreateInfoNV<'_>
{
}
impl<'a> PipelineViewportSwizzleStateCreateInfoNV<'a> {
    #[inline]
    pub fn flags(mut self, flags: PipelineViewportSwizzleStateCreateFlagsNV) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn viewport_swizzles(mut self, viewport_swizzles: &'a [ViewportSwizzleNV]) -> Self {
        self.viewport_count = viewport_swizzles.len() as _;
        self.p_viewport_swizzles = viewport_swizzles.as_ptr();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDiscardRectanglePropertiesEXT.html>"]
pub struct PhysicalDeviceDiscardRectanglePropertiesEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub max_discard_rectangles: u32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceDiscardRectanglePropertiesEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            max_discard_rectangles: u32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceDiscardRectanglePropertiesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT;
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceDiscardRectanglePropertiesEXT<'_> {}
impl<'a> PhysicalDeviceDiscardRectanglePropertiesEXT<'a> {
    #[inline]
    pub fn max_discard_rectangles(mut self, max_discard_rectangles: u32) -> Self {
        self.max_discard_rectangles = max_discard_rectangles;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineDiscardRectangleStateCreateInfoEXT.html>"]
pub struct PipelineDiscardRectangleStateCreateInfoEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: PipelineDiscardRectangleStateCreateFlagsEXT,
    pub discard_rectangle_mode: DiscardRectangleModeEXT,
    pub discard_rectangle_count: u32,
    pub p_discard_rectangles: *const Rect2D,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PipelineDiscardRectangleStateCreateInfoEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: PipelineDiscardRectangleStateCreateFlagsEXT::default(),
            discard_rectangle_mode: DiscardRectangleModeEXT::default(),
            discard_rectangle_count: u32::default(),
            p_discard_rectangles: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PipelineDiscardRectangleStateCreateInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT;
}
unsafe impl ExtendsGraphicsPipelineCreateInfo for PipelineDiscardRectangleStateCreateInfoEXT<'_> {}
impl<'a> PipelineDiscardRectangleStateCreateInfoEXT<'a> {
    #[inline]
    pub fn flags(mut self, flags: PipelineDiscardRectangleStateCreateFlagsEXT) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn discard_rectangle_mode(
        mut self,
        discard_rectangle_mode: DiscardRectangleModeEXT,
    ) -> Self {
        self.discard_rectangle_mode = discard_rectangle_mode;
        self
    }
    #[inline]
    pub fn discard_rectangles(mut self, discard_rectangles: &'a [Rect2D]) -> Self {
        self.discard_rectangle_count = discard_rectangles.len() as _;
        self.p_discard_rectangles = discard_rectangles.as_ptr();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX.html>"]
pub struct PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub per_view_position_all_components: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            per_view_position_all_components: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX;
}
unsafe impl ExtendsPhysicalDeviceProperties2
    for PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX<'_>
{
}
impl<'a> PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX<'a> {
    #[inline]
    pub fn per_view_position_all_components(
        mut self,
        per_view_position_all_components: bool,
    ) -> Self {
        self.per_view_position_all_components = per_view_position_all_components.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkInputAttachmentAspectReference.html>"]
pub struct InputAttachmentAspectReference {
    pub subpass: u32,
    pub input_attachment_index: u32,
    pub aspect_mask: ImageAspectFlags,
}
impl InputAttachmentAspectReference {
    #[inline]
    pub fn subpass(mut self, subpass: u32) -> Self {
        self.subpass = subpass;
        self
    }
    #[inline]
    pub fn input_attachment_index(mut self, input_attachment_index: u32) -> Self {
        self.input_attachment_index = input_attachment_index;
        self
    }
    #[inline]
    pub fn aspect_mask(mut self, aspect_mask: ImageAspectFlags) -> Self {
        self.aspect_mask = aspect_mask;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderPassInputAttachmentAspectCreateInfo.html>"]
pub struct RenderPassInputAttachmentAspectCreateInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub aspect_reference_count: u32,
    pub p_aspect_references: *const InputAttachmentAspectReference,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for RenderPassInputAttachmentAspectCreateInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            aspect_reference_count: u32::default(),
            p_aspect_references: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for RenderPassInputAttachmentAspectCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO;
}
unsafe impl ExtendsRenderPassCreateInfo for RenderPassInputAttachmentAspectCreateInfo<'_> {}
impl<'a> RenderPassInputAttachmentAspectCreateInfo<'a> {
    #[inline]
    pub fn aspect_references(
        mut self,
        aspect_references: &'a [InputAttachmentAspectReference],
    ) -> Self {
        self.aspect_reference_count = aspect_references.len() as _;
        self.p_aspect_references = aspect_references.as_ptr();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceSurfaceInfo2KHR.html>"]
pub struct PhysicalDeviceSurfaceInfo2KHR<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub surface: SurfaceKHR,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceSurfaceInfo2KHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            surface: SurfaceKHR::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceSurfaceInfo2KHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_SURFACE_INFO_2_KHR;
}
pub unsafe trait ExtendsPhysicalDeviceSurfaceInfo2KHR {}
impl<'a> PhysicalDeviceSurfaceInfo2KHR<'a> {
    #[inline]
    pub fn surface(mut self, surface: SurfaceKHR) -> Self {
        self.surface = surface;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `x.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsPhysicalDeviceSurfaceInfo2KHR>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.p_next as _;
            self.p_next = next_ptr;
        }
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSurfaceCapabilities2KHR.html>"]
pub struct SurfaceCapabilities2KHR<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub surface_capabilities: SurfaceCapabilitiesKHR,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for SurfaceCapabilities2KHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            surface_capabilities: SurfaceCapabilitiesKHR::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for SurfaceCapabilities2KHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::SURFACE_CAPABILITIES_2_KHR;
}
pub unsafe trait ExtendsSurfaceCapabilities2KHR {}
impl<'a> SurfaceCapabilities2KHR<'a> {
    #[inline]
    pub fn surface_capabilities(mut self, surface_capabilities: SurfaceCapabilitiesKHR) -> Self {
        self.surface_capabilities = surface_capabilities;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `x.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsSurfaceCapabilities2KHR>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*mut T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.p_next as _;
            self.p_next = next_ptr;
        }
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSurfaceFormat2KHR.html>"]
pub struct SurfaceFormat2KHR<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub surface_format: SurfaceFormatKHR,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for SurfaceFormat2KHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            surface_format: SurfaceFormatKHR::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for SurfaceFormat2KHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::SURFACE_FORMAT_2_KHR;
}
pub unsafe trait ExtendsSurfaceFormat2KHR {}
impl<'a> SurfaceFormat2KHR<'a> {
    #[inline]
    pub fn surface_format(mut self, surface_format: SurfaceFormatKHR) -> Self {
        self.surface_format = surface_format;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `x.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsSurfaceFormat2KHR>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*mut T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.p_next as _;
            self.p_next = next_ptr;
        }
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplayProperties2KHR.html>"]
pub struct DisplayProperties2KHR<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub display_properties: DisplayPropertiesKHR<'a>,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for DisplayProperties2KHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            display_properties: DisplayPropertiesKHR::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for DisplayProperties2KHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DISPLAY_PROPERTIES_2_KHR;
}
impl<'a> DisplayProperties2KHR<'a> {
    #[inline]
    pub fn display_properties(mut self, display_properties: DisplayPropertiesKHR<'a>) -> Self {
        self.display_properties = display_properties;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplayPlaneProperties2KHR.html>"]
pub struct DisplayPlaneProperties2KHR<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub display_plane_properties: DisplayPlanePropertiesKHR,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for DisplayPlaneProperties2KHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            display_plane_properties: DisplayPlanePropertiesKHR::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for DisplayPlaneProperties2KHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DISPLAY_PLANE_PROPERTIES_2_KHR;
}
impl<'a> DisplayPlaneProperties2KHR<'a> {
    #[inline]
    pub fn display_plane_properties(
        mut self,
        display_plane_properties: DisplayPlanePropertiesKHR,
    ) -> Self {
        self.display_plane_properties = display_plane_properties;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplayModeProperties2KHR.html>"]
pub struct DisplayModeProperties2KHR<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub display_mode_properties: DisplayModePropertiesKHR,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for DisplayModeProperties2KHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            display_mode_properties: DisplayModePropertiesKHR::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for DisplayModeProperties2KHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DISPLAY_MODE_PROPERTIES_2_KHR;
}
impl<'a> DisplayModeProperties2KHR<'a> {
    #[inline]
    pub fn display_mode_properties(
        mut self,
        display_mode_properties: DisplayModePropertiesKHR,
    ) -> Self {
        self.display_mode_properties = display_mode_properties;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplayPlaneInfo2KHR.html>"]
pub struct DisplayPlaneInfo2KHR<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub mode: DisplayModeKHR,
    pub plane_index: u32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for DisplayPlaneInfo2KHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            mode: DisplayModeKHR::default(),
            plane_index: u32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for DisplayPlaneInfo2KHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DISPLAY_PLANE_INFO_2_KHR;
}
impl<'a> DisplayPlaneInfo2KHR<'a> {
    #[inline]
    pub fn mode(mut self, mode: DisplayModeKHR) -> Self {
        self.mode = mode;
        self
    }
    #[inline]
    pub fn plane_index(mut self, plane_index: u32) -> Self {
        self.plane_index = plane_index;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplayPlaneCapabilities2KHR.html>"]
pub struct DisplayPlaneCapabilities2KHR<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub capabilities: DisplayPlaneCapabilitiesKHR,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for DisplayPlaneCapabilities2KHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            capabilities: DisplayPlaneCapabilitiesKHR::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for DisplayPlaneCapabilities2KHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DISPLAY_PLANE_CAPABILITIES_2_KHR;
}
impl<'a> DisplayPlaneCapabilities2KHR<'a> {
    #[inline]
    pub fn capabilities(mut self, capabilities: DisplayPlaneCapabilitiesKHR) -> Self {
        self.capabilities = capabilities;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSharedPresentSurfaceCapabilitiesKHR.html>"]
pub struct SharedPresentSurfaceCapabilitiesKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shared_present_supported_usage_flags: ImageUsageFlags,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for SharedPresentSurfaceCapabilitiesKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            shared_present_supported_usage_flags: ImageUsageFlags::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for SharedPresentSurfaceCapabilitiesKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::SHARED_PRESENT_SURFACE_CAPABILITIES_KHR;
}
unsafe impl ExtendsSurfaceCapabilities2KHR for SharedPresentSurfaceCapabilitiesKHR<'_> {}
impl<'a> SharedPresentSurfaceCapabilitiesKHR<'a> {
    #[inline]
    pub fn shared_present_supported_usage_flags(
        mut self,
        shared_present_supported_usage_flags: ImageUsageFlags,
    ) -> Self {
        self.shared_present_supported_usage_flags = shared_present_supported_usage_flags;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevice16BitStorageFeatures.html>"]
pub struct PhysicalDevice16BitStorageFeatures<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub storage_buffer16_bit_access: Bool32,
    pub uniform_and_storage_buffer16_bit_access: Bool32,
    pub storage_push_constant16: Bool32,
    pub storage_input_output16: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDevice16BitStorageFeatures<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            storage_buffer16_bit_access: Bool32::default(),
            uniform_and_storage_buffer16_bit_access: Bool32::default(),
            storage_push_constant16: Bool32::default(),
            storage_input_output16: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDevice16BitStorageFeatures<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES;
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDevice16BitStorageFeatures<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDevice16BitStorageFeatures<'_> {}
impl<'a> PhysicalDevice16BitStorageFeatures<'a> {
    #[inline]
    pub fn storage_buffer16_bit_access(mut self, storage_buffer16_bit_access: bool) -> Self {
        self.storage_buffer16_bit_access = storage_buffer16_bit_access.into();
        self
    }
    #[inline]
    pub fn uniform_and_storage_buffer16_bit_access(
        mut self,
        uniform_and_storage_buffer16_bit_access: bool,
    ) -> Self {
        self.uniform_and_storage_buffer16_bit_access =
            uniform_and_storage_buffer16_bit_access.into();
        self
    }
    #[inline]
    pub fn storage_push_constant16(mut self, storage_push_constant16: bool) -> Self {
        self.storage_push_constant16 = storage_push_constant16.into();
        self
    }
    #[inline]
    pub fn storage_input_output16(mut self, storage_input_output16: bool) -> Self {
        self.storage_input_output16 = storage_input_output16.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceSubgroupProperties.html>"]
pub struct PhysicalDeviceSubgroupProperties<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub subgroup_size: u32,
    pub supported_stages: ShaderStageFlags,
    pub supported_operations: SubgroupFeatureFlags,
    pub quad_operations_in_all_stages: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceSubgroupProperties<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            subgroup_size: u32::default(),
            supported_stages: ShaderStageFlags::default(),
            supported_operations: SubgroupFeatureFlags::default(),
            quad_operations_in_all_stages: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceSubgroupProperties<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_SUBGROUP_PROPERTIES;
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceSubgroupProperties<'_> {}
impl<'a> PhysicalDeviceSubgroupProperties<'a> {
    #[inline]
    pub fn subgroup_size(mut self, subgroup_size: u32) -> Self {
        self.subgroup_size = subgroup_size;
        self
    }
    #[inline]
    pub fn supported_stages(mut self, supported_stages: ShaderStageFlags) -> Self {
        self.supported_stages = supported_stages;
        self
    }
    #[inline]
    pub fn supported_operations(mut self, supported_operations: SubgroupFeatureFlags) -> Self {
        self.supported_operations = supported_operations;
        self
    }
    #[inline]
    pub fn quad_operations_in_all_stages(mut self, quad_operations_in_all_stages: bool) -> Self {
        self.quad_operations_in_all_stages = quad_operations_in_all_stages.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures.html>"]
pub struct PhysicalDeviceShaderSubgroupExtendedTypesFeatures<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shader_subgroup_extended_types: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceShaderSubgroupExtendedTypesFeatures<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            shader_subgroup_extended_types: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceShaderSubgroupExtendedTypesFeatures<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES;
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceShaderSubgroupExtendedTypesFeatures<'_>
{
}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceShaderSubgroupExtendedTypesFeatures<'_> {}
impl<'a> PhysicalDeviceShaderSubgroupExtendedTypesFeatures<'a> {
    #[inline]
    pub fn shader_subgroup_extended_types(mut self, shader_subgroup_extended_types: bool) -> Self {
        self.shader_subgroup_extended_types = shader_subgroup_extended_types.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferMemoryRequirementsInfo2.html>"]
pub struct BufferMemoryRequirementsInfo2<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub buffer: Buffer,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for BufferMemoryRequirementsInfo2<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            buffer: Buffer::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for BufferMemoryRequirementsInfo2<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::BUFFER_MEMORY_REQUIREMENTS_INFO_2;
}
impl<'a> BufferMemoryRequirementsInfo2<'a> {
    #[inline]
    pub fn buffer(mut self, buffer: Buffer) -> Self {
        self.buffer = buffer;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceBufferMemoryRequirements.html>"]
pub struct DeviceBufferMemoryRequirements<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub p_create_info: *const BufferCreateInfo<'a>,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for DeviceBufferMemoryRequirements<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            p_create_info: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for DeviceBufferMemoryRequirements<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DEVICE_BUFFER_MEMORY_REQUIREMENTS;
}
impl<'a> DeviceBufferMemoryRequirements<'a> {
    #[inline]
    pub fn create_info(mut self, create_info: &'a BufferCreateInfo<'a>) -> Self {
        self.p_create_info = create_info;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageMemoryRequirementsInfo2.html>"]
pub struct ImageMemoryRequirementsInfo2<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub image: Image,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for ImageMemoryRequirementsInfo2<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            image: Image::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for ImageMemoryRequirementsInfo2<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::IMAGE_MEMORY_REQUIREMENTS_INFO_2;
}
pub unsafe trait ExtendsImageMemoryRequirementsInfo2 {}
impl<'a> ImageMemoryRequirementsInfo2<'a> {
    #[inline]
    pub fn image(mut self, image: Image) -> Self {
        self.image = image;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `x.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsImageMemoryRequirementsInfo2>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.p_next as _;
            self.p_next = next_ptr;
        }
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageSparseMemoryRequirementsInfo2.html>"]
pub struct ImageSparseMemoryRequirementsInfo2<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub image: Image,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for ImageSparseMemoryRequirementsInfo2<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            image: Image::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for ImageSparseMemoryRequirementsInfo2<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2;
}
impl<'a> ImageSparseMemoryRequirementsInfo2<'a> {
    #[inline]
    pub fn image(mut self, image: Image) -> Self {
        self.image = image;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceImageMemoryRequirements.html>"]
pub struct DeviceImageMemoryRequirements<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub p_create_info: *const ImageCreateInfo<'a>,
    pub plane_aspect: ImageAspectFlags,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for DeviceImageMemoryRequirements<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            p_create_info: ::std::ptr::null(),
            plane_aspect: ImageAspectFlags::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for DeviceImageMemoryRequirements<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DEVICE_IMAGE_MEMORY_REQUIREMENTS;
}
impl<'a> DeviceImageMemoryRequirements<'a> {
    #[inline]
    pub fn create_info(mut self, create_info: &'a ImageCreateInfo<'a>) -> Self {
        self.p_create_info = create_info;
        self
    }
    #[inline]
    pub fn plane_aspect(mut self, plane_aspect: ImageAspectFlags) -> Self {
        self.plane_aspect = plane_aspect;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryRequirements2.html>"]
pub struct MemoryRequirements2<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub memory_requirements: MemoryRequirements,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for MemoryRequirements2<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            memory_requirements: MemoryRequirements::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for MemoryRequirements2<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::MEMORY_REQUIREMENTS_2;
}
pub unsafe trait ExtendsMemoryRequirements2 {}
impl<'a> MemoryRequirements2<'a> {
    #[inline]
    pub fn memory_requirements(mut self, memory_requirements: MemoryRequirements) -> Self {
        self.memory_requirements = memory_requirements;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `x.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsMemoryRequirements2>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*mut T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.p_next as _;
            self.p_next = next_ptr;
        }
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSparseImageMemoryRequirements2.html>"]
pub struct SparseImageMemoryRequirements2<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub memory_requirements: SparseImageMemoryRequirements,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for SparseImageMemoryRequirements2<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            memory_requirements: SparseImageMemoryRequirements::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for SparseImageMemoryRequirements2<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::SPARSE_IMAGE_MEMORY_REQUIREMENTS_2;
}
impl<'a> SparseImageMemoryRequirements2<'a> {
    #[inline]
    pub fn memory_requirements(
        mut self,
        memory_requirements: SparseImageMemoryRequirements,
    ) -> Self {
        self.memory_requirements = memory_requirements;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePointClippingProperties.html>"]
pub struct PhysicalDevicePointClippingProperties<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub point_clipping_behavior: PointClippingBehavior,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDevicePointClippingProperties<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            point_clipping_behavior: PointClippingBehavior::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDevicePointClippingProperties<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES;
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDevicePointClippingProperties<'_> {}
impl<'a> PhysicalDevicePointClippingProperties<'a> {
    #[inline]
    pub fn point_clipping_behavior(
        mut self,
        point_clipping_behavior: PointClippingBehavior,
    ) -> Self {
        self.point_clipping_behavior = point_clipping_behavior;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryDedicatedRequirements.html>"]
pub struct MemoryDedicatedRequirements<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub prefers_dedicated_allocation: Bool32,
    pub requires_dedicated_allocation: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for MemoryDedicatedRequirements<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            prefers_dedicated_allocation: Bool32::default(),
            requires_dedicated_allocation: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for MemoryDedicatedRequirements<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::MEMORY_DEDICATED_REQUIREMENTS;
}
unsafe impl ExtendsMemoryRequirements2 for MemoryDedicatedRequirements<'_> {}
impl<'a> MemoryDedicatedRequirements<'a> {
    #[inline]
    pub fn prefers_dedicated_allocation(mut self, prefers_dedicated_allocation: bool) -> Self {
        self.prefers_dedicated_allocation = prefers_dedicated_allocation.into();
        self
    }
    #[inline]
    pub fn requires_dedicated_allocation(mut self, requires_dedicated_allocation: bool) -> Self {
        self.requires_dedicated_allocation = requires_dedicated_allocation.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryDedicatedAllocateInfo.html>"]
pub struct MemoryDedicatedAllocateInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub image: Image,
    pub buffer: Buffer,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for MemoryDedicatedAllocateInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            image: Image::default(),
            buffer: Buffer::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for MemoryDedicatedAllocateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::MEMORY_DEDICATED_ALLOCATE_INFO;
}
unsafe impl ExtendsMemoryAllocateInfo for MemoryDedicatedAllocateInfo<'_> {}
impl<'a> MemoryDedicatedAllocateInfo<'a> {
    #[inline]
    pub fn image(mut self, image: Image) -> Self {
        self.image = image;
        self
    }
    #[inline]
    pub fn buffer(mut self, buffer: Buffer) -> Self {
        self.buffer = buffer;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageViewUsageCreateInfo.html>"]
pub struct ImageViewUsageCreateInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub usage: ImageUsageFlags,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for ImageViewUsageCreateInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            usage: ImageUsageFlags::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for ImageViewUsageCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::IMAGE_VIEW_USAGE_CREATE_INFO;
}
unsafe impl ExtendsImageViewCreateInfo for ImageViewUsageCreateInfo<'_> {}
impl<'a> ImageViewUsageCreateInfo<'a> {
    #[inline]
    pub fn usage(mut self, usage: ImageUsageFlags) -> Self {
        self.usage = usage;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineTessellationDomainOriginStateCreateInfo.html>"]
pub struct PipelineTessellationDomainOriginStateCreateInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub domain_origin: TessellationDomainOrigin,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PipelineTessellationDomainOriginStateCreateInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            domain_origin: TessellationDomainOrigin::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PipelineTessellationDomainOriginStateCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO;
}
unsafe impl ExtendsPipelineTessellationStateCreateInfo
    for PipelineTessellationDomainOriginStateCreateInfo<'_>
{
}
impl<'a> PipelineTessellationDomainOriginStateCreateInfo<'a> {
    #[inline]
    pub fn domain_origin(mut self, domain_origin: TessellationDomainOrigin) -> Self {
        self.domain_origin = domain_origin;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSamplerYcbcrConversionInfo.html>"]
pub struct SamplerYcbcrConversionInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub conversion: SamplerYcbcrConversion,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for SamplerYcbcrConversionInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            conversion: SamplerYcbcrConversion::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for SamplerYcbcrConversionInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::SAMPLER_YCBCR_CONVERSION_INFO;
}
unsafe impl ExtendsSamplerCreateInfo for SamplerYcbcrConversionInfo<'_> {}
unsafe impl ExtendsImageViewCreateInfo for SamplerYcbcrConversionInfo<'_> {}
impl<'a> SamplerYcbcrConversionInfo<'a> {
    #[inline]
    pub fn conversion(mut self, conversion: SamplerYcbcrConversion) -> Self {
        self.conversion = conversion;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSamplerYcbcrConversionCreateInfo.html>"]
pub struct SamplerYcbcrConversionCreateInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub format: Format,
    pub ycbcr_model: SamplerYcbcrModelConversion,
    pub ycbcr_range: SamplerYcbcrRange,
    pub components: ComponentMapping,
    pub x_chroma_offset: ChromaLocation,
    pub y_chroma_offset: ChromaLocation,
    pub chroma_filter: Filter,
    pub force_explicit_reconstruction: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for SamplerYcbcrConversionCreateInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            format: Format::default(),
            ycbcr_model: SamplerYcbcrModelConversion::default(),
            ycbcr_range: SamplerYcbcrRange::default(),
            components: ComponentMapping::default(),
            x_chroma_offset: ChromaLocation::default(),
            y_chroma_offset: ChromaLocation::default(),
            chroma_filter: Filter::default(),
            force_explicit_reconstruction: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for SamplerYcbcrConversionCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::SAMPLER_YCBCR_CONVERSION_CREATE_INFO;
}
pub unsafe trait ExtendsSamplerYcbcrConversionCreateInfo {}
impl<'a> SamplerYcbcrConversionCreateInfo<'a> {
    #[inline]
    pub fn format(mut self, format: Format) -> Self {
        self.format = format;
        self
    }
    #[inline]
    pub fn ycbcr_model(mut self, ycbcr_model: SamplerYcbcrModelConversion) -> Self {
        self.ycbcr_model = ycbcr_model;
        self
    }
    #[inline]
    pub fn ycbcr_range(mut self, ycbcr_range: SamplerYcbcrRange) -> Self {
        self.ycbcr_range = ycbcr_range;
        self
    }
    #[inline]
    pub fn components(mut self, components: ComponentMapping) -> Self {
        self.components = components;
        self
    }
    #[inline]
    pub fn x_chroma_offset(mut self, x_chroma_offset: ChromaLocation) -> Self {
        self.x_chroma_offset = x_chroma_offset;
        self
    }
    #[inline]
    pub fn y_chroma_offset(mut self, y_chroma_offset: ChromaLocation) -> Self {
        self.y_chroma_offset = y_chroma_offset;
        self
    }
    #[inline]
    pub fn chroma_filter(mut self, chroma_filter: Filter) -> Self {
        self.chroma_filter = chroma_filter;
        self
    }
    #[inline]
    pub fn force_explicit_reconstruction(mut self, force_explicit_reconstruction: bool) -> Self {
        self.force_explicit_reconstruction = force_explicit_reconstruction.into();
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `x.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsSamplerYcbcrConversionCreateInfo>(
        mut self,
        next: &'a mut T,
    ) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.p_next as _;
            self.p_next = next_ptr;
        }
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBindImagePlaneMemoryInfo.html>"]
pub struct BindImagePlaneMemoryInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub plane_aspect: ImageAspectFlags,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for BindImagePlaneMemoryInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            plane_aspect: ImageAspectFlags::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for BindImagePlaneMemoryInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::BIND_IMAGE_PLANE_MEMORY_INFO;
}
unsafe impl ExtendsBindImageMemoryInfo for BindImagePlaneMemoryInfo<'_> {}
impl<'a> BindImagePlaneMemoryInfo<'a> {
    #[inline]
    pub fn plane_aspect(mut self, plane_aspect: ImageAspectFlags) -> Self {
        self.plane_aspect = plane_aspect;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImagePlaneMemoryRequirementsInfo.html>"]
pub struct ImagePlaneMemoryRequirementsInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub plane_aspect: ImageAspectFlags,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for ImagePlaneMemoryRequirementsInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            plane_aspect: ImageAspectFlags::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for ImagePlaneMemoryRequirementsInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO;
}
unsafe impl ExtendsImageMemoryRequirementsInfo2 for ImagePlaneMemoryRequirementsInfo<'_> {}
impl<'a> ImagePlaneMemoryRequirementsInfo<'a> {
    #[inline]
    pub fn plane_aspect(mut self, plane_aspect: ImageAspectFlags) -> Self {
        self.plane_aspect = plane_aspect;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceSamplerYcbcrConversionFeatures.html>"]
pub struct PhysicalDeviceSamplerYcbcrConversionFeatures<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub sampler_ycbcr_conversion: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceSamplerYcbcrConversionFeatures<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            sampler_ycbcr_conversion: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceSamplerYcbcrConversionFeatures<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES;
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceSamplerYcbcrConversionFeatures<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceSamplerYcbcrConversionFeatures<'_> {}
impl<'a> PhysicalDeviceSamplerYcbcrConversionFeatures<'a> {
    #[inline]
    pub fn sampler_ycbcr_conversion(mut self, sampler_ycbcr_conversion: bool) -> Self {
        self.sampler_ycbcr_conversion = sampler_ycbcr_conversion.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSamplerYcbcrConversionImageFormatProperties.html>"]
pub struct SamplerYcbcrConversionImageFormatProperties<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub combined_image_sampler_descriptor_count: u32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for SamplerYcbcrConversionImageFormatProperties<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            combined_image_sampler_descriptor_count: u32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for SamplerYcbcrConversionImageFormatProperties<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES;
}
unsafe impl ExtendsImageFormatProperties2 for SamplerYcbcrConversionImageFormatProperties<'_> {}
impl<'a> SamplerYcbcrConversionImageFormatProperties<'a> {
    #[inline]
    pub fn combined_image_sampler_descriptor_count(
        mut self,
        combined_image_sampler_descriptor_count: u32,
    ) -> Self {
        self.combined_image_sampler_descriptor_count = combined_image_sampler_descriptor_count;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkTextureLODGatherFormatPropertiesAMD.html>"]
pub struct TextureLODGatherFormatPropertiesAMD<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub supports_texture_gather_lod_bias_amd: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for TextureLODGatherFormatPropertiesAMD<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            supports_texture_gather_lod_bias_amd: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for TextureLODGatherFormatPropertiesAMD<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD;
}
unsafe impl ExtendsImageFormatProperties2 for TextureLODGatherFormatPropertiesAMD<'_> {}
impl<'a> TextureLODGatherFormatPropertiesAMD<'a> {
    #[inline]
    pub fn supports_texture_gather_lod_bias_amd(
        mut self,
        supports_texture_gather_lod_bias_amd: bool,
    ) -> Self {
        self.supports_texture_gather_lod_bias_amd = supports_texture_gather_lod_bias_amd.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkConditionalRenderingBeginInfoEXT.html>"]
pub struct ConditionalRenderingBeginInfoEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub buffer: Buffer,
    pub offset: DeviceSize,
    pub flags: ConditionalRenderingFlagsEXT,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for ConditionalRenderingBeginInfoEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            buffer: Buffer::default(),
            offset: DeviceSize::default(),
            flags: ConditionalRenderingFlagsEXT::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for ConditionalRenderingBeginInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::CONDITIONAL_RENDERING_BEGIN_INFO_EXT;
}
impl<'a> ConditionalRenderingBeginInfoEXT<'a> {
    #[inline]
    pub fn buffer(mut self, buffer: Buffer) -> Self {
        self.buffer = buffer;
        self
    }
    #[inline]
    pub fn offset(mut self, offset: DeviceSize) -> Self {
        self.offset = offset;
        self
    }
    #[inline]
    pub fn flags(mut self, flags: ConditionalRenderingFlagsEXT) -> Self {
        self.flags = flags;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkProtectedSubmitInfo.html>"]
pub struct ProtectedSubmitInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub protected_submit: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for ProtectedSubmitInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            protected_submit: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for ProtectedSubmitInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PROTECTED_SUBMIT_INFO;
}
unsafe impl ExtendsSubmitInfo for ProtectedSubmitInfo<'_> {}
impl<'a> ProtectedSubmitInfo<'a> {
    #[inline]
    pub fn protected_submit(mut self, protected_submit: bool) -> Self {
        self.protected_submit = protected_submit.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceProtectedMemoryFeatures.html>"]
pub struct PhysicalDeviceProtectedMemoryFeatures<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub protected_memory: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceProtectedMemoryFeatures<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            protected_memory: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceProtectedMemoryFeatures<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES;
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceProtectedMemoryFeatures<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceProtectedMemoryFeatures<'_> {}
impl<'a> PhysicalDeviceProtectedMemoryFeatures<'a> {
    #[inline]
    pub fn protected_memory(mut self, protected_memory: bool) -> Self {
        self.protected_memory = protected_memory.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceProtectedMemoryProperties.html>"]
pub struct PhysicalDeviceProtectedMemoryProperties<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub protected_no_fault: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceProtectedMemoryProperties<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            protected_no_fault: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceProtectedMemoryProperties<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES;
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceProtectedMemoryProperties<'_> {}
impl<'a> PhysicalDeviceProtectedMemoryProperties<'a> {
    #[inline]
    pub fn protected_no_fault(mut self, protected_no_fault: bool) -> Self {
        self.protected_no_fault = protected_no_fault.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceQueueInfo2.html>"]
pub struct DeviceQueueInfo2<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: DeviceQueueCreateFlags,
    pub queue_family_index: u32,
    pub queue_index: u32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for DeviceQueueInfo2<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: DeviceQueueCreateFlags::default(),
            queue_family_index: u32::default(),
            queue_index: u32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for DeviceQueueInfo2<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DEVICE_QUEUE_INFO_2;
}
impl<'a> DeviceQueueInfo2<'a> {
    #[inline]
    pub fn flags(mut self, flags: DeviceQueueCreateFlags) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn queue_family_index(mut self, queue_family_index: u32) -> Self {
        self.queue_family_index = queue_family_index;
        self
    }
    #[inline]
    pub fn queue_index(mut self, queue_index: u32) -> Self {
        self.queue_index = queue_index;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineCoverageToColorStateCreateInfoNV.html>"]
pub struct PipelineCoverageToColorStateCreateInfoNV<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: PipelineCoverageToColorStateCreateFlagsNV,
    pub coverage_to_color_enable: Bool32,
    pub coverage_to_color_location: u32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PipelineCoverageToColorStateCreateInfoNV<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: PipelineCoverageToColorStateCreateFlagsNV::default(),
            coverage_to_color_enable: Bool32::default(),
            coverage_to_color_location: u32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PipelineCoverageToColorStateCreateInfoNV<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV;
}
unsafe impl ExtendsPipelineMultisampleStateCreateInfo
    for PipelineCoverageToColorStateCreateInfoNV<'_>
{
}
impl<'a> PipelineCoverageToColorStateCreateInfoNV<'a> {
    #[inline]
    pub fn flags(mut self, flags: PipelineCoverageToColorStateCreateFlagsNV) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn coverage_to_color_enable(mut self, coverage_to_color_enable: bool) -> Self {
        self.coverage_to_color_enable = coverage_to_color_enable.into();
        self
    }
    #[inline]
    pub fn coverage_to_color_location(mut self, coverage_to_color_location: u32) -> Self {
        self.coverage_to_color_location = coverage_to_color_location;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceSamplerFilterMinmaxProperties.html>"]
pub struct PhysicalDeviceSamplerFilterMinmaxProperties<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub filter_minmax_single_component_formats: Bool32,
    pub filter_minmax_image_component_mapping: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceSamplerFilterMinmaxProperties<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            filter_minmax_single_component_formats: Bool32::default(),
            filter_minmax_image_component_mapping: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceSamplerFilterMinmaxProperties<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES;
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceSamplerFilterMinmaxProperties<'_> {}
impl<'a> PhysicalDeviceSamplerFilterMinmaxProperties<'a> {
    #[inline]
    pub fn filter_minmax_single_component_formats(
        mut self,
        filter_minmax_single_component_formats: bool,
    ) -> Self {
        self.filter_minmax_single_component_formats = filter_minmax_single_component_formats.into();
        self
    }
    #[inline]
    pub fn filter_minmax_image_component_mapping(
        mut self,
        filter_minmax_image_component_mapping: bool,
    ) -> Self {
        self.filter_minmax_image_component_mapping = filter_minmax_image_component_mapping.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSampleLocationEXT.html>"]
pub struct SampleLocationEXT {
    pub x: f32,
    pub y: f32,
}
impl SampleLocationEXT {
    #[inline]
    pub fn x(mut self, x: f32) -> Self {
        self.x = x;
        self
    }
    #[inline]
    pub fn y(mut self, y: f32) -> Self {
        self.y = y;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSampleLocationsInfoEXT.html>"]
pub struct SampleLocationsInfoEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub sample_locations_per_pixel: SampleCountFlags,
    pub sample_location_grid_size: Extent2D,
    pub sample_locations_count: u32,
    pub p_sample_locations: *const SampleLocationEXT,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for SampleLocationsInfoEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            sample_locations_per_pixel: SampleCountFlags::default(),
            sample_location_grid_size: Extent2D::default(),
            sample_locations_count: u32::default(),
            p_sample_locations: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for SampleLocationsInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::SAMPLE_LOCATIONS_INFO_EXT;
}
unsafe impl ExtendsImageMemoryBarrier for SampleLocationsInfoEXT<'_> {}
unsafe impl ExtendsImageMemoryBarrier2 for SampleLocationsInfoEXT<'_> {}
impl<'a> SampleLocationsInfoEXT<'a> {
    #[inline]
    pub fn sample_locations_per_pixel(
        mut self,
        sample_locations_per_pixel: SampleCountFlags,
    ) -> Self {
        self.sample_locations_per_pixel = sample_locations_per_pixel;
        self
    }
    #[inline]
    pub fn sample_location_grid_size(mut self, sample_location_grid_size: Extent2D) -> Self {
        self.sample_location_grid_size = sample_location_grid_size;
        self
    }
    #[inline]
    pub fn sample_locations(mut self, sample_locations: &'a [SampleLocationEXT]) -> Self {
        self.sample_locations_count = sample_locations.len() as _;
        self.p_sample_locations = sample_locations.as_ptr();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAttachmentSampleLocationsEXT.html>"]
pub struct AttachmentSampleLocationsEXT<'a> {
    pub attachment_index: u32,
    pub sample_locations_info: SampleLocationsInfoEXT<'a>,
    pub _marker: PhantomData<&'a ()>,
}
impl<'a> AttachmentSampleLocationsEXT<'a> {
    #[inline]
    pub fn attachment_index(mut self, attachment_index: u32) -> Self {
        self.attachment_index = attachment_index;
        self
    }
    #[inline]
    pub fn sample_locations_info(
        mut self,
        sample_locations_info: SampleLocationsInfoEXT<'a>,
    ) -> Self {
        self.sample_locations_info = sample_locations_info;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSubpassSampleLocationsEXT.html>"]
pub struct SubpassSampleLocationsEXT<'a> {
    pub subpass_index: u32,
    pub sample_locations_info: SampleLocationsInfoEXT<'a>,
    pub _marker: PhantomData<&'a ()>,
}
impl<'a> SubpassSampleLocationsEXT<'a> {
    #[inline]
    pub fn subpass_index(mut self, subpass_index: u32) -> Self {
        self.subpass_index = subpass_index;
        self
    }
    #[inline]
    pub fn sample_locations_info(
        mut self,
        sample_locations_info: SampleLocationsInfoEXT<'a>,
    ) -> Self {
        self.sample_locations_info = sample_locations_info;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderPassSampleLocationsBeginInfoEXT.html>"]
pub struct RenderPassSampleLocationsBeginInfoEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub attachment_initial_sample_locations_count: u32,
    pub p_attachment_initial_sample_locations: *const AttachmentSampleLocationsEXT<'a>,
    pub post_subpass_sample_locations_count: u32,
    pub p_post_subpass_sample_locations: *const SubpassSampleLocationsEXT<'a>,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for RenderPassSampleLocationsBeginInfoEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            attachment_initial_sample_locations_count: u32::default(),
            p_attachment_initial_sample_locations: ::std::ptr::null(),
            post_subpass_sample_locations_count: u32::default(),
            p_post_subpass_sample_locations: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for RenderPassSampleLocationsBeginInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT;
}
unsafe impl ExtendsRenderPassBeginInfo for RenderPassSampleLocationsBeginInfoEXT<'_> {}
impl<'a> RenderPassSampleLocationsBeginInfoEXT<'a> {
    #[inline]
    pub fn attachment_initial_sample_locations(
        mut self,
        attachment_initial_sample_locations: &'a [AttachmentSampleLocationsEXT],
    ) -> Self {
        self.attachment_initial_sample_locations_count =
            attachment_initial_sample_locations.len() as _;
        self.p_attachment_initial_sample_locations = attachment_initial_sample_locations.as_ptr();
        self
    }
    #[inline]
    pub fn post_subpass_sample_locations(
        mut self,
        post_subpass_sample_locations: &'a [SubpassSampleLocationsEXT],
    ) -> Self {
        self.post_subpass_sample_locations_count = post_subpass_sample_locations.len() as _;
        self.p_post_subpass_sample_locations = post_subpass_sample_locations.as_ptr();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineSampleLocationsStateCreateInfoEXT.html>"]
pub struct PipelineSampleLocationsStateCreateInfoEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub sample_locations_enable: Bool32,
    pub sample_locations_info: SampleLocationsInfoEXT<'a>,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PipelineSampleLocationsStateCreateInfoEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            sample_locations_enable: Bool32::default(),
            sample_locations_info: SampleLocationsInfoEXT::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PipelineSampleLocationsStateCreateInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT;
}
unsafe impl ExtendsPipelineMultisampleStateCreateInfo
    for PipelineSampleLocationsStateCreateInfoEXT<'_>
{
}
impl<'a> PipelineSampleLocationsStateCreateInfoEXT<'a> {
    #[inline]
    pub fn sample_locations_enable(mut self, sample_locations_enable: bool) -> Self {
        self.sample_locations_enable = sample_locations_enable.into();
        self
    }
    #[inline]
    pub fn sample_locations_info(
        mut self,
        sample_locations_info: SampleLocationsInfoEXT<'a>,
    ) -> Self {
        self.sample_locations_info = sample_locations_info;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceSampleLocationsPropertiesEXT.html>"]
pub struct PhysicalDeviceSampleLocationsPropertiesEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub sample_location_sample_counts: SampleCountFlags,
    pub max_sample_location_grid_size: Extent2D,
    pub sample_location_coordinate_range: [f32; 2],
    pub sample_location_sub_pixel_bits: u32,
    pub variable_sample_locations: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceSampleLocationsPropertiesEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            sample_location_sample_counts: SampleCountFlags::default(),
            max_sample_location_grid_size: Extent2D::default(),
            sample_location_coordinate_range: unsafe { ::std::mem::zeroed() },
            sample_location_sub_pixel_bits: u32::default(),
            variable_sample_locations: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceSampleLocationsPropertiesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT;
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceSampleLocationsPropertiesEXT<'_> {}
impl<'a> PhysicalDeviceSampleLocationsPropertiesEXT<'a> {
    #[inline]
    pub fn sample_location_sample_counts(
        mut self,
        sample_location_sample_counts: SampleCountFlags,
    ) -> Self {
        self.sample_location_sample_counts = sample_location_sample_counts;
        self
    }
    #[inline]
    pub fn max_sample_location_grid_size(
        mut self,
        max_sample_location_grid_size: Extent2D,
    ) -> Self {
        self.max_sample_location_grid_size = max_sample_location_grid_size;
        self
    }
    #[inline]
    pub fn sample_location_coordinate_range(
        mut self,
        sample_location_coordinate_range: [f32; 2],
    ) -> Self {
        self.sample_location_coordinate_range = sample_location_coordinate_range;
        self
    }
    #[inline]
    pub fn sample_location_sub_pixel_bits(mut self, sample_location_sub_pixel_bits: u32) -> Self {
        self.sample_location_sub_pixel_bits = sample_location_sub_pixel_bits;
        self
    }
    #[inline]
    pub fn variable_sample_locations(mut self, variable_sample_locations: bool) -> Self {
        self.variable_sample_locations = variable_sample_locations.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMultisamplePropertiesEXT.html>"]
pub struct MultisamplePropertiesEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub max_sample_location_grid_size: Extent2D,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for MultisamplePropertiesEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            max_sample_location_grid_size: Extent2D::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for MultisamplePropertiesEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::MULTISAMPLE_PROPERTIES_EXT;
}
impl<'a> MultisamplePropertiesEXT<'a> {
    #[inline]
    pub fn max_sample_location_grid_size(
        mut self,
        max_sample_location_grid_size: Extent2D,
    ) -> Self {
        self.max_sample_location_grid_size = max_sample_location_grid_size;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSamplerReductionModeCreateInfo.html>"]
pub struct SamplerReductionModeCreateInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub reduction_mode: SamplerReductionMode,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for SamplerReductionModeCreateInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            reduction_mode: SamplerReductionMode::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for SamplerReductionModeCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::SAMPLER_REDUCTION_MODE_CREATE_INFO;
}
unsafe impl ExtendsSamplerCreateInfo for SamplerReductionModeCreateInfo<'_> {}
impl<'a> SamplerReductionModeCreateInfo<'a> {
    #[inline]
    pub fn reduction_mode(mut self, reduction_mode: SamplerReductionMode) -> Self {
        self.reduction_mode = reduction_mode;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT.html>"]
pub struct PhysicalDeviceBlendOperationAdvancedFeaturesEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub advanced_blend_coherent_operations: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceBlendOperationAdvancedFeaturesEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            advanced_blend_coherent_operations: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceBlendOperationAdvancedFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT;
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceBlendOperationAdvancedFeaturesEXT<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceBlendOperationAdvancedFeaturesEXT<'_> {}
impl<'a> PhysicalDeviceBlendOperationAdvancedFeaturesEXT<'a> {
    #[inline]
    pub fn advanced_blend_coherent_operations(
        mut self,
        advanced_blend_coherent_operations: bool,
    ) -> Self {
        self.advanced_blend_coherent_operations = advanced_blend_coherent_operations.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMultiDrawFeaturesEXT.html>"]
pub struct PhysicalDeviceMultiDrawFeaturesEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub multi_draw: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceMultiDrawFeaturesEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            multi_draw: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceMultiDrawFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT;
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceMultiDrawFeaturesEXT<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceMultiDrawFeaturesEXT<'_> {}
impl<'a> PhysicalDeviceMultiDrawFeaturesEXT<'a> {
    #[inline]
    pub fn multi_draw(mut self, multi_draw: bool) -> Self {
        self.multi_draw = multi_draw.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT.html>"]
pub struct PhysicalDeviceBlendOperationAdvancedPropertiesEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub advanced_blend_max_color_attachments: u32,
    pub advanced_blend_independent_blend: Bool32,
    pub advanced_blend_non_premultiplied_src_color: Bool32,
    pub advanced_blend_non_premultiplied_dst_color: Bool32,
    pub advanced_blend_correlated_overlap: Bool32,
    pub advanced_blend_all_operations: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceBlendOperationAdvancedPropertiesEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            advanced_blend_max_color_attachments: u32::default(),
            advanced_blend_independent_blend: Bool32::default(),
            advanced_blend_non_premultiplied_src_color: Bool32::default(),
            advanced_blend_non_premultiplied_dst_color: Bool32::default(),
            advanced_blend_correlated_overlap: Bool32::default(),
            advanced_blend_all_operations: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceBlendOperationAdvancedPropertiesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT;
}
unsafe impl ExtendsPhysicalDeviceProperties2
    for PhysicalDeviceBlendOperationAdvancedPropertiesEXT<'_>
{
}
impl<'a> PhysicalDeviceBlendOperationAdvancedPropertiesEXT<'a> {
    #[inline]
    pub fn advanced_blend_max_color_attachments(
        mut self,
        advanced_blend_max_color_attachments: u32,
    ) -> Self {
        self.advanced_blend_max_color_attachments = advanced_blend_max_color_attachments;
        self
    }
    #[inline]
    pub fn advanced_blend_independent_blend(
        mut self,
        advanced_blend_independent_blend: bool,
    ) -> Self {
        self.advanced_blend_independent_blend = advanced_blend_independent_blend.into();
        self
    }
    #[inline]
    pub fn advanced_blend_non_premultiplied_src_color(
        mut self,
        advanced_blend_non_premultiplied_src_color: bool,
    ) -> Self {
        self.advanced_blend_non_premultiplied_src_color =
            advanced_blend_non_premultiplied_src_color.into();
        self
    }
    #[inline]
    pub fn advanced_blend_non_premultiplied_dst_color(
        mut self,
        advanced_blend_non_premultiplied_dst_color: bool,
    ) -> Self {
        self.advanced_blend_non_premultiplied_dst_color =
            advanced_blend_non_premultiplied_dst_color.into();
        self
    }
    #[inline]
    pub fn advanced_blend_correlated_overlap(
        mut self,
        advanced_blend_correlated_overlap: bool,
    ) -> Self {
        self.advanced_blend_correlated_overlap = advanced_blend_correlated_overlap.into();
        self
    }
    #[inline]
    pub fn advanced_blend_all_operations(mut self, advanced_blend_all_operations: bool) -> Self {
        self.advanced_blend_all_operations = advanced_blend_all_operations.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineColorBlendAdvancedStateCreateInfoEXT.html>"]
pub struct PipelineColorBlendAdvancedStateCreateInfoEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub src_premultiplied: Bool32,
    pub dst_premultiplied: Bool32,
    pub blend_overlap: BlendOverlapEXT,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PipelineColorBlendAdvancedStateCreateInfoEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            src_premultiplied: Bool32::default(),
            dst_premultiplied: Bool32::default(),
            blend_overlap: BlendOverlapEXT::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PipelineColorBlendAdvancedStateCreateInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT;
}
unsafe impl ExtendsPipelineColorBlendStateCreateInfo
    for PipelineColorBlendAdvancedStateCreateInfoEXT<'_>
{
}
impl<'a> PipelineColorBlendAdvancedStateCreateInfoEXT<'a> {
    #[inline]
    pub fn src_premultiplied(mut self, src_premultiplied: bool) -> Self {
        self.src_premultiplied = src_premultiplied.into();
        self
    }
    #[inline]
    pub fn dst_premultiplied(mut self, dst_premultiplied: bool) -> Self {
        self.dst_premultiplied = dst_premultiplied.into();
        self
    }
    #[inline]
    pub fn blend_overlap(mut self, blend_overlap: BlendOverlapEXT) -> Self {
        self.blend_overlap = blend_overlap;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceInlineUniformBlockFeatures.html>"]
pub struct PhysicalDeviceInlineUniformBlockFeatures<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub inline_uniform_block: Bool32,
    pub descriptor_binding_inline_uniform_block_update_after_bind: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceInlineUniformBlockFeatures<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            inline_uniform_block: Bool32::default(),
            descriptor_binding_inline_uniform_block_update_after_bind: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceInlineUniformBlockFeatures<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES;
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceInlineUniformBlockFeatures<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceInlineUniformBlockFeatures<'_> {}
impl<'a> PhysicalDeviceInlineUniformBlockFeatures<'a> {
    #[inline]
    pub fn inline_uniform_block(mut self, inline_uniform_block: bool) -> Self {
        self.inline_uniform_block = inline_uniform_block.into();
        self
    }
    #[inline]
    pub fn descriptor_binding_inline_uniform_block_update_after_bind(
        mut self,
        descriptor_binding_inline_uniform_block_update_after_bind: bool,
    ) -> Self {
        self.descriptor_binding_inline_uniform_block_update_after_bind =
            descriptor_binding_inline_uniform_block_update_after_bind.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceInlineUniformBlockProperties.html>"]
pub struct PhysicalDeviceInlineUniformBlockProperties<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub max_inline_uniform_block_size: u32,
    pub max_per_stage_descriptor_inline_uniform_blocks: u32,
    pub max_per_stage_descriptor_update_after_bind_inline_uniform_blocks: u32,
    pub max_descriptor_set_inline_uniform_blocks: u32,
    pub max_descriptor_set_update_after_bind_inline_uniform_blocks: u32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceInlineUniformBlockProperties<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            max_inline_uniform_block_size: u32::default(),
            max_per_stage_descriptor_inline_uniform_blocks: u32::default(),
            max_per_stage_descriptor_update_after_bind_inline_uniform_blocks: u32::default(),
            max_descriptor_set_inline_uniform_blocks: u32::default(),
            max_descriptor_set_update_after_bind_inline_uniform_blocks: u32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceInlineUniformBlockProperties<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES;
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceInlineUniformBlockProperties<'_> {}
impl<'a> PhysicalDeviceInlineUniformBlockProperties<'a> {
    #[inline]
    pub fn max_inline_uniform_block_size(mut self, max_inline_uniform_block_size: u32) -> Self {
        self.max_inline_uniform_block_size = max_inline_uniform_block_size;
        self
    }
    #[inline]
    pub fn max_per_stage_descriptor_inline_uniform_blocks(
        mut self,
        max_per_stage_descriptor_inline_uniform_blocks: u32,
    ) -> Self {
        self.max_per_stage_descriptor_inline_uniform_blocks =
            max_per_stage_descriptor_inline_uniform_blocks;
        self
    }
    #[inline]
    pub fn max_per_stage_descriptor_update_after_bind_inline_uniform_blocks(
        mut self,
        max_per_stage_descriptor_update_after_bind_inline_uniform_blocks: u32,
    ) -> Self {
        self.max_per_stage_descriptor_update_after_bind_inline_uniform_blocks =
            max_per_stage_descriptor_update_after_bind_inline_uniform_blocks;
        self
    }
    #[inline]
    pub fn max_descriptor_set_inline_uniform_blocks(
        mut self,
        max_descriptor_set_inline_uniform_blocks: u32,
    ) -> Self {
        self.max_descriptor_set_inline_uniform_blocks = max_descriptor_set_inline_uniform_blocks;
        self
    }
    #[inline]
    pub fn max_descriptor_set_update_after_bind_inline_uniform_blocks(
        mut self,
        max_descriptor_set_update_after_bind_inline_uniform_blocks: u32,
    ) -> Self {
        self.max_descriptor_set_update_after_bind_inline_uniform_blocks =
            max_descriptor_set_update_after_bind_inline_uniform_blocks;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkWriteDescriptorSetInlineUniformBlock.html>"]
pub struct WriteDescriptorSetInlineUniformBlock<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub data_size: u32,
    pub p_data: *const c_void,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for WriteDescriptorSetInlineUniformBlock<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            data_size: u32::default(),
            p_data: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for WriteDescriptorSetInlineUniformBlock<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK;
}
unsafe impl ExtendsWriteDescriptorSet for WriteDescriptorSetInlineUniformBlock<'_> {}
impl<'a> WriteDescriptorSetInlineUniformBlock<'a> {
    #[inline]
    pub fn data(mut self, data: &'a [u8]) -> Self {
        self.data_size = data.len() as _;
        self.p_data = data.as_ptr() as *const c_void;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorPoolInlineUniformBlockCreateInfo.html>"]
pub struct DescriptorPoolInlineUniformBlockCreateInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub max_inline_uniform_block_bindings: u32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for DescriptorPoolInlineUniformBlockCreateInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            max_inline_uniform_block_bindings: u32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for DescriptorPoolInlineUniformBlockCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO;
}
unsafe impl ExtendsDescriptorPoolCreateInfo for DescriptorPoolInlineUniformBlockCreateInfo<'_> {}
impl<'a> DescriptorPoolInlineUniformBlockCreateInfo<'a> {
    #[inline]
    pub fn max_inline_uniform_block_bindings(
        mut self,
        max_inline_uniform_block_bindings: u32,
    ) -> Self {
        self.max_inline_uniform_block_bindings = max_inline_uniform_block_bindings;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineCoverageModulationStateCreateInfoNV.html>"]
pub struct PipelineCoverageModulationStateCreateInfoNV<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: PipelineCoverageModulationStateCreateFlagsNV,
    pub coverage_modulation_mode: CoverageModulationModeNV,
    pub coverage_modulation_table_enable: Bool32,
    pub coverage_modulation_table_count: u32,
    pub p_coverage_modulation_table: *const f32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PipelineCoverageModulationStateCreateInfoNV<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: PipelineCoverageModulationStateCreateFlagsNV::default(),
            coverage_modulation_mode: CoverageModulationModeNV::default(),
            coverage_modulation_table_enable: Bool32::default(),
            coverage_modulation_table_count: u32::default(),
            p_coverage_modulation_table: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PipelineCoverageModulationStateCreateInfoNV<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV;
}
unsafe impl ExtendsPipelineMultisampleStateCreateInfo
    for PipelineCoverageModulationStateCreateInfoNV<'_>
{
}
impl<'a> PipelineCoverageModulationStateCreateInfoNV<'a> {
    #[inline]
    pub fn flags(mut self, flags: PipelineCoverageModulationStateCreateFlagsNV) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn coverage_modulation_mode(
        mut self,
        coverage_modulation_mode: CoverageModulationModeNV,
    ) -> Self {
        self.coverage_modulation_mode = coverage_modulation_mode;
        self
    }
    #[inline]
    pub fn coverage_modulation_table_enable(
        mut self,
        coverage_modulation_table_enable: bool,
    ) -> Self {
        self.coverage_modulation_table_enable = coverage_modulation_table_enable.into();
        self
    }
    #[inline]
    pub fn coverage_modulation_table(mut self, coverage_modulation_table: &'a [f32]) -> Self {
        self.coverage_modulation_table_count = coverage_modulation_table.len() as _;
        self.p_coverage_modulation_table = coverage_modulation_table.as_ptr();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageFormatListCreateInfo.html>"]
pub struct ImageFormatListCreateInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub view_format_count: u32,
    pub p_view_formats: *const Format,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for ImageFormatListCreateInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            view_format_count: u32::default(),
            p_view_formats: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for ImageFormatListCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::IMAGE_FORMAT_LIST_CREATE_INFO;
}
unsafe impl ExtendsImageCreateInfo for ImageFormatListCreateInfo<'_> {}
unsafe impl ExtendsSwapchainCreateInfoKHR for ImageFormatListCreateInfo<'_> {}
unsafe impl ExtendsPhysicalDeviceImageFormatInfo2 for ImageFormatListCreateInfo<'_> {}
impl<'a> ImageFormatListCreateInfo<'a> {
    #[inline]
    pub fn view_formats(mut self, view_formats: &'a [Format]) -> Self {
        self.view_format_count = view_formats.len() as _;
        self.p_view_formats = view_formats.as_ptr();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkValidationCacheCreateInfoEXT.html>"]
pub struct ValidationCacheCreateInfoEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: ValidationCacheCreateFlagsEXT,
    pub initial_data_size: usize,
    pub p_initial_data: *const c_void,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for ValidationCacheCreateInfoEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: ValidationCacheCreateFlagsEXT::default(),
            initial_data_size: usize::default(),
            p_initial_data: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for ValidationCacheCreateInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::VALIDATION_CACHE_CREATE_INFO_EXT;
}
impl<'a> ValidationCacheCreateInfoEXT<'a> {
    #[inline]
    pub fn flags(mut self, flags: ValidationCacheCreateFlagsEXT) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn initial_data(mut self, initial_data: &'a [u8]) -> Self {
        self.initial_data_size = initial_data.len();
        self.p_initial_data = initial_data.as_ptr() as *const c_void;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkShaderModuleValidationCacheCreateInfoEXT.html>"]
pub struct ShaderModuleValidationCacheCreateInfoEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub validation_cache: ValidationCacheEXT,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for ShaderModuleValidationCacheCreateInfoEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            validation_cache: ValidationCacheEXT::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for ShaderModuleValidationCacheCreateInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT;
}
unsafe impl ExtendsShaderModuleCreateInfo for ShaderModuleValidationCacheCreateInfoEXT<'_> {}
impl<'a> ShaderModuleValidationCacheCreateInfoEXT<'a> {
    #[inline]
    pub fn validation_cache(mut self, validation_cache: ValidationCacheEXT) -> Self {
        self.validation_cache = validation_cache;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMaintenance3Properties.html>"]
pub struct PhysicalDeviceMaintenance3Properties<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub max_per_set_descriptors: u32,
    pub max_memory_allocation_size: DeviceSize,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceMaintenance3Properties<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            max_per_set_descriptors: u32::default(),
            max_memory_allocation_size: DeviceSize::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceMaintenance3Properties<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES;
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceMaintenance3Properties<'_> {}
impl<'a> PhysicalDeviceMaintenance3Properties<'a> {
    #[inline]
    pub fn max_per_set_descriptors(mut self, max_per_set_descriptors: u32) -> Self {
        self.max_per_set_descriptors = max_per_set_descriptors;
        self
    }
    #[inline]
    pub fn max_memory_allocation_size(mut self, max_memory_allocation_size: DeviceSize) -> Self {
        self.max_memory_allocation_size = max_memory_allocation_size;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMaintenance4Features.html>"]
pub struct PhysicalDeviceMaintenance4Features<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub maintenance4: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceMaintenance4Features<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            maintenance4: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceMaintenance4Features<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES;
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceMaintenance4Features<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceMaintenance4Features<'_> {}
impl<'a> PhysicalDeviceMaintenance4Features<'a> {
    #[inline]
    pub fn maintenance4(mut self, maintenance4: bool) -> Self {
        self.maintenance4 = maintenance4.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMaintenance4Properties.html>"]
pub struct PhysicalDeviceMaintenance4Properties<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub max_buffer_size: DeviceSize,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceMaintenance4Properties<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            max_buffer_size: DeviceSize::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceMaintenance4Properties<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES;
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceMaintenance4Properties<'_> {}
impl<'a> PhysicalDeviceMaintenance4Properties<'a> {
    #[inline]
    pub fn max_buffer_size(mut self, max_buffer_size: DeviceSize) -> Self {
        self.max_buffer_size = max_buffer_size;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorSetLayoutSupport.html>"]
pub struct DescriptorSetLayoutSupport<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub supported: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for DescriptorSetLayoutSupport<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            supported: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for DescriptorSetLayoutSupport<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DESCRIPTOR_SET_LAYOUT_SUPPORT;
}
pub unsafe trait ExtendsDescriptorSetLayoutSupport {}
impl<'a> DescriptorSetLayoutSupport<'a> {
    #[inline]
    pub fn supported(mut self, supported: bool) -> Self {
        self.supported = supported.into();
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `x.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsDescriptorSetLayoutSupport>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*mut T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.p_next as _;
            self.p_next = next_ptr;
        }
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderDrawParametersFeatures.html>"]
pub struct PhysicalDeviceShaderDrawParametersFeatures<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shader_draw_parameters: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceShaderDrawParametersFeatures<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            shader_draw_parameters: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceShaderDrawParametersFeatures<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES;
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceShaderDrawParametersFeatures<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceShaderDrawParametersFeatures<'_> {}
impl<'a> PhysicalDeviceShaderDrawParametersFeatures<'a> {
    #[inline]
    pub fn shader_draw_parameters(mut self, shader_draw_parameters: bool) -> Self {
        self.shader_draw_parameters = shader_draw_parameters.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderFloat16Int8Features.html>"]
pub struct PhysicalDeviceShaderFloat16Int8Features<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shader_float16: Bool32,
    pub shader_int8: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceShaderFloat16Int8Features<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            shader_float16: Bool32::default(),
            shader_int8: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceShaderFloat16Int8Features<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES;
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceShaderFloat16Int8Features<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceShaderFloat16Int8Features<'_> {}
impl<'a> PhysicalDeviceShaderFloat16Int8Features<'a> {
    #[inline]
    pub fn shader_float16(mut self, shader_float16: bool) -> Self {
        self.shader_float16 = shader_float16.into();
        self
    }
    #[inline]
    pub fn shader_int8(mut self, shader_int8: bool) -> Self {
        self.shader_int8 = shader_int8.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFloatControlsProperties.html>"]
pub struct PhysicalDeviceFloatControlsProperties<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub denorm_behavior_independence: ShaderFloatControlsIndependence,
    pub rounding_mode_independence: ShaderFloatControlsIndependence,
    pub shader_signed_zero_inf_nan_preserve_float16: Bool32,
    pub shader_signed_zero_inf_nan_preserve_float32: Bool32,
    pub shader_signed_zero_inf_nan_preserve_float64: Bool32,
    pub shader_denorm_preserve_float16: Bool32,
    pub shader_denorm_preserve_float32: Bool32,
    pub shader_denorm_preserve_float64: Bool32,
    pub shader_denorm_flush_to_zero_float16: Bool32,
    pub shader_denorm_flush_to_zero_float32: Bool32,
    pub shader_denorm_flush_to_zero_float64: Bool32,
    pub shader_rounding_mode_rte_float16: Bool32,
    pub shader_rounding_mode_rte_float32: Bool32,
    pub shader_rounding_mode_rte_float64: Bool32,
    pub shader_rounding_mode_rtz_float16: Bool32,
    pub shader_rounding_mode_rtz_float32: Bool32,
    pub shader_rounding_mode_rtz_float64: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceFloatControlsProperties<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            denorm_behavior_independence: ShaderFloatControlsIndependence::default(),
            rounding_mode_independence: ShaderFloatControlsIndependence::default(),
            shader_signed_zero_inf_nan_preserve_float16: Bool32::default(),
            shader_signed_zero_inf_nan_preserve_float32: Bool32::default(),
            shader_signed_zero_inf_nan_preserve_float64: Bool32::default(),
            shader_denorm_preserve_float16: Bool32::default(),
            shader_denorm_preserve_float32: Bool32::default(),
            shader_denorm_preserve_float64: Bool32::default(),
            shader_denorm_flush_to_zero_float16: Bool32::default(),
            shader_denorm_flush_to_zero_float32: Bool32::default(),
            shader_denorm_flush_to_zero_float64: Bool32::default(),
            shader_rounding_mode_rte_float16: Bool32::default(),
            shader_rounding_mode_rte_float32: Bool32::default(),
            shader_rounding_mode_rte_float64: Bool32::default(),
            shader_rounding_mode_rtz_float16: Bool32::default(),
            shader_rounding_mode_rtz_float32: Bool32::default(),
            shader_rounding_mode_rtz_float64: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceFloatControlsProperties<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES;
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceFloatControlsProperties<'_> {}
impl<'a> PhysicalDeviceFloatControlsProperties<'a> {
    #[inline]
    pub fn denorm_behavior_independence(
        mut self,
        denorm_behavior_independence: ShaderFloatControlsIndependence,
    ) -> Self {
        self.denorm_behavior_independence = denorm_behavior_independence;
        self
    }
    #[inline]
    pub fn rounding_mode_independence(
        mut self,
        rounding_mode_independence: ShaderFloatControlsIndependence,
    ) -> Self {
        self.rounding_mode_independence = rounding_mode_independence;
        self
    }
    #[inline]
    pub fn shader_signed_zero_inf_nan_preserve_float16(
        mut self,
        shader_signed_zero_inf_nan_preserve_float16: bool,
    ) -> Self {
        self.shader_signed_zero_inf_nan_preserve_float16 =
            shader_signed_zero_inf_nan_preserve_float16.into();
        self
    }
    #[inline]
    pub fn shader_signed_zero_inf_nan_preserve_float32(
        mut self,
        shader_signed_zero_inf_nan_preserve_float32: bool,
    ) -> Self {
        self.shader_signed_zero_inf_nan_preserve_float32 =
            shader_signed_zero_inf_nan_preserve_float32.into();
        self
    }
    #[inline]
    pub fn shader_signed_zero_inf_nan_preserve_float64(
        mut self,
        shader_signed_zero_inf_nan_preserve_float64: bool,
    ) -> Self {
        self.shader_signed_zero_inf_nan_preserve_float64 =
            shader_signed_zero_inf_nan_preserve_float64.into();
        self
    }
    #[inline]
    pub fn shader_denorm_preserve_float16(mut self, shader_denorm_preserve_float16: bool) -> Self {
        self.shader_denorm_preserve_float16 = shader_denorm_preserve_float16.into();
        self
    }
    #[inline]
    pub fn shader_denorm_preserve_float32(mut self, shader_denorm_preserve_float32: bool) -> Self {
        self.shader_denorm_preserve_float32 = shader_denorm_preserve_float32.into();
        self
    }
    #[inline]
    pub fn shader_denorm_preserve_float64(mut self, shader_denorm_preserve_float64: bool) -> Self {
        self.shader_denorm_preserve_float64 = shader_denorm_preserve_float64.into();
        self
    }
    #[inline]
    pub fn shader_denorm_flush_to_zero_float16(
        mut self,
        shader_denorm_flush_to_zero_float16: bool,
    ) -> Self {
        self.shader_denorm_flush_to_zero_float16 = shader_denorm_flush_to_zero_float16.into();
        self
    }
    #[inline]
    pub fn shader_denorm_flush_to_zero_float32(
        mut self,
        shader_denorm_flush_to_zero_float32: bool,
    ) -> Self {
        self.shader_denorm_flush_to_zero_float32 = shader_denorm_flush_to_zero_float32.into();
        self
    }
    #[inline]
    pub fn shader_denorm_flush_to_zero_float64(
        mut self,
        shader_denorm_flush_to_zero_float64: bool,
    ) -> Self {
        self.shader_denorm_flush_to_zero_float64 = shader_denorm_flush_to_zero_float64.into();
        self
    }
    #[inline]
    pub fn shader_rounding_mode_rte_float16(
        mut self,
        shader_rounding_mode_rte_float16: bool,
    ) -> Self {
        self.shader_rounding_mode_rte_float16 = shader_rounding_mode_rte_float16.into();
        self
    }
    #[inline]
    pub fn shader_rounding_mode_rte_float32(
        mut self,
        shader_rounding_mode_rte_float32: bool,
    ) -> Self {
        self.shader_rounding_mode_rte_float32 = shader_rounding_mode_rte_float32.into();
        self
    }
    #[inline]
    pub fn shader_rounding_mode_rte_float64(
        mut self,
        shader_rounding_mode_rte_float64: bool,
    ) -> Self {
        self.shader_rounding_mode_rte_float64 = shader_rounding_mode_rte_float64.into();
        self
    }
    #[inline]
    pub fn shader_rounding_mode_rtz_float16(
        mut self,
        shader_rounding_mode_rtz_float16: bool,
    ) -> Self {
        self.shader_rounding_mode_rtz_float16 = shader_rounding_mode_rtz_float16.into();
        self
    }
    #[inline]
    pub fn shader_rounding_mode_rtz_float32(
        mut self,
        shader_rounding_mode_rtz_float32: bool,
    ) -> Self {
        self.shader_rounding_mode_rtz_float32 = shader_rounding_mode_rtz_float32.into();
        self
    }
    #[inline]
    pub fn shader_rounding_mode_rtz_float64(
        mut self,
        shader_rounding_mode_rtz_float64: bool,
    ) -> Self {
        self.shader_rounding_mode_rtz_float64 = shader_rounding_mode_rtz_float64.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceHostQueryResetFeatures.html>"]
pub struct PhysicalDeviceHostQueryResetFeatures<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub host_query_reset: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceHostQueryResetFeatures<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            host_query_reset: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceHostQueryResetFeatures<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES;
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceHostQueryResetFeatures<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceHostQueryResetFeatures<'_> {}
impl<'a> PhysicalDeviceHostQueryResetFeatures<'a> {
    #[inline]
    pub fn host_query_reset(mut self, host_query_reset: bool) -> Self {
        self.host_query_reset = host_query_reset.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkNativeBufferUsage2ANDROID.html>"]
pub struct NativeBufferUsage2ANDROID {
    pub consumer: u64,
    pub producer: u64,
}
impl NativeBufferUsage2ANDROID {
    #[inline]
    pub fn consumer(mut self, consumer: u64) -> Self {
        self.consumer = consumer;
        self
    }
    #[inline]
    pub fn producer(mut self, producer: u64) -> Self {
        self.producer = producer;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkNativeBufferANDROID.html>"]
pub struct NativeBufferANDROID<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub handle: *const c_void,
    pub stride: c_int,
    pub format: c_int,
    pub usage: c_int,
    pub usage2: NativeBufferUsage2ANDROID,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for NativeBufferANDROID<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            handle: ::std::ptr::null(),
            stride: c_int::default(),
            format: c_int::default(),
            usage: c_int::default(),
            usage2: NativeBufferUsage2ANDROID::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for NativeBufferANDROID<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::NATIVE_BUFFER_ANDROID;
}
impl<'a> NativeBufferANDROID<'a> {
    #[inline]
    pub fn handle(mut self, handle: *const c_void) -> Self {
        self.handle = handle;
        self
    }
    #[inline]
    pub fn stride(mut self, stride: c_int) -> Self {
        self.stride = stride;
        self
    }
    #[inline]
    pub fn format(mut self, format: c_int) -> Self {
        self.format = format;
        self
    }
    #[inline]
    pub fn usage(mut self, usage: c_int) -> Self {
        self.usage = usage;
        self
    }
    #[inline]
    pub fn usage2(mut self, usage2: NativeBufferUsage2ANDROID) -> Self {
        self.usage2 = usage2;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSwapchainImageCreateInfoANDROID.html>"]
pub struct SwapchainImageCreateInfoANDROID<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub usage: SwapchainImageUsageFlagsANDROID,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for SwapchainImageCreateInfoANDROID<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            usage: SwapchainImageUsageFlagsANDROID::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for SwapchainImageCreateInfoANDROID<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::SWAPCHAIN_IMAGE_CREATE_INFO_ANDROID;
}
impl<'a> SwapchainImageCreateInfoANDROID<'a> {
    #[inline]
    pub fn usage(mut self, usage: SwapchainImageUsageFlagsANDROID) -> Self {
        self.usage = usage;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePresentationPropertiesANDROID.html>"]
pub struct PhysicalDevicePresentationPropertiesANDROID<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub shared_image: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDevicePresentationPropertiesANDROID<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            shared_image: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDevicePresentationPropertiesANDROID<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_PRESENTATION_PROPERTIES_ANDROID;
}
impl<'a> PhysicalDevicePresentationPropertiesANDROID<'a> {
    #[inline]
    pub fn shared_image(mut self, shared_image: bool) -> Self {
        self.shared_image = shared_image.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkShaderResourceUsageAMD.html>"]
pub struct ShaderResourceUsageAMD {
    pub num_used_vgprs: u32,
    pub num_used_sgprs: u32,
    pub lds_size_per_local_work_group: u32,
    pub lds_usage_size_in_bytes: usize,
    pub scratch_mem_usage_in_bytes: usize,
}
impl ShaderResourceUsageAMD {
    #[inline]
    pub fn num_used_vgprs(mut self, num_used_vgprs: u32) -> Self {
        self.num_used_vgprs = num_used_vgprs;
        self
    }
    #[inline]
    pub fn num_used_sgprs(mut self, num_used_sgprs: u32) -> Self {
        self.num_used_sgprs = num_used_sgprs;
        self
    }
    #[inline]
    pub fn lds_size_per_local_work_group(mut self, lds_size_per_local_work_group: u32) -> Self {
        self.lds_size_per_local_work_group = lds_size_per_local_work_group;
        self
    }
    #[inline]
    pub fn lds_usage_size_in_bytes(mut self, lds_usage_size_in_bytes: usize) -> Self {
        self.lds_usage_size_in_bytes = lds_usage_size_in_bytes;
        self
    }
    #[inline]
    pub fn scratch_mem_usage_in_bytes(mut self, scratch_mem_usage_in_bytes: usize) -> Self {
        self.scratch_mem_usage_in_bytes = scratch_mem_usage_in_bytes;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkShaderStatisticsInfoAMD.html>"]
pub struct ShaderStatisticsInfoAMD {
    pub shader_stage_mask: ShaderStageFlags,
    pub resource_usage: ShaderResourceUsageAMD,
    pub num_physical_vgprs: u32,
    pub num_physical_sgprs: u32,
    pub num_available_vgprs: u32,
    pub num_available_sgprs: u32,
    pub compute_work_group_size: [u32; 3],
}
impl ::std::default::Default for ShaderStatisticsInfoAMD {
    #[inline]
    fn default() -> Self {
        Self {
            shader_stage_mask: ShaderStageFlags::default(),
            resource_usage: ShaderResourceUsageAMD::default(),
            num_physical_vgprs: u32::default(),
            num_physical_sgprs: u32::default(),
            num_available_vgprs: u32::default(),
            num_available_sgprs: u32::default(),
            compute_work_group_size: unsafe { ::std::mem::zeroed() },
        }
    }
}
impl ShaderStatisticsInfoAMD {
    #[inline]
    pub fn shader_stage_mask(mut self, shader_stage_mask: ShaderStageFlags) -> Self {
        self.shader_stage_mask = shader_stage_mask;
        self
    }
    #[inline]
    pub fn resource_usage(mut self, resource_usage: ShaderResourceUsageAMD) -> Self {
        self.resource_usage = resource_usage;
        self
    }
    #[inline]
    pub fn num_physical_vgprs(mut self, num_physical_vgprs: u32) -> Self {
        self.num_physical_vgprs = num_physical_vgprs;
        self
    }
    #[inline]
    pub fn num_physical_sgprs(mut self, num_physical_sgprs: u32) -> Self {
        self.num_physical_sgprs = num_physical_sgprs;
        self
    }
    #[inline]
    pub fn num_available_vgprs(mut self, num_available_vgprs: u32) -> Self {
        self.num_available_vgprs = num_available_vgprs;
        self
    }
    #[inline]
    pub fn num_available_sgprs(mut self, num_available_sgprs: u32) -> Self {
        self.num_available_sgprs = num_available_sgprs;
        self
    }
    #[inline]
    pub fn compute_work_group_size(mut self, compute_work_group_size: [u32; 3]) -> Self {
        self.compute_work_group_size = compute_work_group_size;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceQueueGlobalPriorityCreateInfoKHR.html>"]
pub struct DeviceQueueGlobalPriorityCreateInfoKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub global_priority: QueueGlobalPriorityKHR,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for DeviceQueueGlobalPriorityCreateInfoKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            global_priority: QueueGlobalPriorityKHR::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for DeviceQueueGlobalPriorityCreateInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_KHR;
}
unsafe impl ExtendsDeviceQueueCreateInfo for DeviceQueueGlobalPriorityCreateInfoKHR<'_> {}
impl<'a> DeviceQueueGlobalPriorityCreateInfoKHR<'a> {
    #[inline]
    pub fn global_priority(mut self, global_priority: QueueGlobalPriorityKHR) -> Self {
        self.global_priority = global_priority;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR.html>"]
pub struct PhysicalDeviceGlobalPriorityQueryFeaturesKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub global_priority_query: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceGlobalPriorityQueryFeaturesKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            global_priority_query: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceGlobalPriorityQueryFeaturesKHR<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_KHR;
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceGlobalPriorityQueryFeaturesKHR<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceGlobalPriorityQueryFeaturesKHR<'_> {}
impl<'a> PhysicalDeviceGlobalPriorityQueryFeaturesKHR<'a> {
    #[inline]
    pub fn global_priority_query(mut self, global_priority_query: bool) -> Self {
        self.global_priority_query = global_priority_query.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkQueueFamilyGlobalPriorityPropertiesKHR.html>"]
pub struct QueueFamilyGlobalPriorityPropertiesKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub priority_count: u32,
    pub priorities: [QueueGlobalPriorityKHR; MAX_GLOBAL_PRIORITY_SIZE_KHR],
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for QueueFamilyGlobalPriorityPropertiesKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            priority_count: u32::default(),
            priorities: unsafe { ::std::mem::zeroed() },
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for QueueFamilyGlobalPriorityPropertiesKHR<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_KHR;
}
unsafe impl ExtendsQueueFamilyProperties2 for QueueFamilyGlobalPriorityPropertiesKHR<'_> {}
impl<'a> QueueFamilyGlobalPriorityPropertiesKHR<'a> {
    #[inline]
    pub fn priority_count(mut self, priority_count: u32) -> Self {
        self.priority_count = priority_count;
        self
    }
    #[inline]
    pub fn priorities(
        mut self,
        priorities: [QueueGlobalPriorityKHR; MAX_GLOBAL_PRIORITY_SIZE_KHR],
    ) -> Self {
        self.priorities = priorities;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDebugUtilsObjectNameInfoEXT.html>"]
pub struct DebugUtilsObjectNameInfoEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub object_type: ObjectType,
    pub object_handle: u64,
    pub p_object_name: *const c_char,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for DebugUtilsObjectNameInfoEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            object_type: ObjectType::default(),
            object_handle: u64::default(),
            p_object_name: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for DebugUtilsObjectNameInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DEBUG_UTILS_OBJECT_NAME_INFO_EXT;
}
unsafe impl ExtendsPipelineShaderStageCreateInfo for DebugUtilsObjectNameInfoEXT<'_> {}
impl<'a> DebugUtilsObjectNameInfoEXT<'a> {
    #[inline]
    pub fn object_type(mut self, object_type: ObjectType) -> Self {
        self.object_type = object_type;
        self
    }
    #[inline]
    pub fn object_handle(mut self, object_handle: u64) -> Self {
        self.object_handle = object_handle;
        self
    }
    #[inline]
    pub fn object_name(mut self, object_name: &'a ::std::ffi::CStr) -> Self {
        self.p_object_name = object_name.as_ptr();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDebugUtilsObjectTagInfoEXT.html>"]
pub struct DebugUtilsObjectTagInfoEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub object_type: ObjectType,
    pub object_handle: u64,
    pub tag_name: u64,
    pub tag_size: usize,
    pub p_tag: *const c_void,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for DebugUtilsObjectTagInfoEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            object_type: ObjectType::default(),
            object_handle: u64::default(),
            tag_name: u64::default(),
            tag_size: usize::default(),
            p_tag: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for DebugUtilsObjectTagInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DEBUG_UTILS_OBJECT_TAG_INFO_EXT;
}
impl<'a> DebugUtilsObjectTagInfoEXT<'a> {
    #[inline]
    pub fn object_type(mut self, object_type: ObjectType) -> Self {
        self.object_type = object_type;
        self
    }
    #[inline]
    pub fn object_handle(mut self, object_handle: u64) -> Self {
        self.object_handle = object_handle;
        self
    }
    #[inline]
    pub fn tag_name(mut self, tag_name: u64) -> Self {
        self.tag_name = tag_name;
        self
    }
    #[inline]
    pub fn tag(mut self, tag: &'a [u8]) -> Self {
        self.tag_size = tag.len();
        self.p_tag = tag.as_ptr() as *const c_void;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDebugUtilsLabelEXT.html>"]
pub struct DebugUtilsLabelEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub p_label_name: *const c_char,
    pub color: [f32; 4],
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for DebugUtilsLabelEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            p_label_name: ::std::ptr::null(),
            color: unsafe { ::std::mem::zeroed() },
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for DebugUtilsLabelEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DEBUG_UTILS_LABEL_EXT;
}
impl<'a> DebugUtilsLabelEXT<'a> {
    #[inline]
    pub fn label_name(mut self, label_name: &'a ::std::ffi::CStr) -> Self {
        self.p_label_name = label_name.as_ptr();
        self
    }
    #[inline]
    pub fn color(mut self, color: [f32; 4]) -> Self {
        self.color = color;
        self
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDebugUtilsMessengerCreateInfoEXT.html>"]
pub struct DebugUtilsMessengerCreateInfoEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: DebugUtilsMessengerCreateFlagsEXT,
    pub message_severity: DebugUtilsMessageSeverityFlagsEXT,
    pub message_type: DebugUtilsMessageTypeFlagsEXT,
    pub pfn_user_callback: PFN_vkDebugUtilsMessengerCallbackEXT,
    pub p_user_data: *mut c_void,
    pub _marker: PhantomData<&'a ()>,
}
#[cfg(feature = "debug")]
impl fmt::Debug for DebugUtilsMessengerCreateInfoEXT<'_> {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DebugUtilsMessengerCreateInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("message_severity", &self.message_severity)
            .field("message_type", &self.message_type)
            .field(
                "pfn_user_callback",
                &(self.pfn_user_callback.map(|x| x as *const ())),
            )
            .field("p_user_data", &self.p_user_data)
            .finish()
    }
}
impl ::std::default::Default for DebugUtilsMessengerCreateInfoEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: DebugUtilsMessengerCreateFlagsEXT::default(),
            message_severity: DebugUtilsMessageSeverityFlagsEXT::default(),
            message_type: DebugUtilsMessageTypeFlagsEXT::default(),
            pfn_user_callback: PFN_vkDebugUtilsMessengerCallbackEXT::default(),
            p_user_data: ::std::ptr::null_mut(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for DebugUtilsMessengerCreateInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT;
}
unsafe impl ExtendsInstanceCreateInfo for DebugUtilsMessengerCreateInfoEXT<'_> {}
impl<'a> DebugUtilsMessengerCreateInfoEXT<'a> {
    #[inline]
    pub fn flags(mut self, flags: DebugUtilsMessengerCreateFlagsEXT) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn message_severity(mut self, message_severity: DebugUtilsMessageSeverityFlagsEXT) -> Self {
        self.message_severity = message_severity;
        self
    }
    #[inline]
    pub fn message_type(mut self, message_type: DebugUtilsMessageTypeFlagsEXT) -> Self {
        self.message_type = message_type;
        self
    }
    #[inline]
    pub fn pfn_user_callback(
        mut self,
        pfn_user_callback: PFN_vkDebugUtilsMessengerCallbackEXT,
    ) -> Self {
        self.pfn_user_callback = pfn_user_callback;
        self
    }
    #[inline]
    pub fn user_data(mut self, user_data: *mut c_void) -> Self {
        self.p_user_data = user_data;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDebugUtilsMessengerCallbackDataEXT.html>"]
pub struct DebugUtilsMessengerCallbackDataEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: DebugUtilsMessengerCallbackDataFlagsEXT,
    pub p_message_id_name: *const c_char,
    pub message_id_number: i32,
    pub p_message: *const c_char,
    pub queue_label_count: u32,
    pub p_queue_labels: *const DebugUtilsLabelEXT<'a>,
    pub cmd_buf_label_count: u32,
    pub p_cmd_buf_labels: *const DebugUtilsLabelEXT<'a>,
    pub object_count: u32,
    pub p_objects: *const DebugUtilsObjectNameInfoEXT<'a>,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for DebugUtilsMessengerCallbackDataEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: DebugUtilsMessengerCallbackDataFlagsEXT::default(),
            p_message_id_name: ::std::ptr::null(),
            message_id_number: i32::default(),
            p_message: ::std::ptr::null(),
            queue_label_count: u32::default(),
            p_queue_labels: ::std::ptr::null(),
            cmd_buf_label_count: u32::default(),
            p_cmd_buf_labels: ::std::ptr::null(),
            object_count: u32::default(),
            p_objects: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for DebugUtilsMessengerCallbackDataEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT;
}
impl<'a> DebugUtilsMessengerCallbackDataEXT<'a> {
    #[inline]
    pub fn flags(mut self, flags: DebugUtilsMessengerCallbackDataFlagsEXT) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn message_id_name(mut self, message_id_name: &'a ::std::ffi::CStr) -> Self {
        self.p_message_id_name = message_id_name.as_ptr();
        self
    }
    #[inline]
    pub fn message_id_number(mut self, message_id_number: i32) -> Self {
        self.message_id_number = message_id_number;
        self
    }
    #[inline]
    pub fn message(mut self, message: &'a ::std::ffi::CStr) -> Self {
        self.p_message = message.as_ptr();
        self
    }
    #[inline]
    pub fn queue_labels(mut self, queue_labels: &'a [DebugUtilsLabelEXT]) -> Self {
        self.queue_label_count = queue_labels.len() as _;
        self.p_queue_labels = queue_labels.as_ptr();
        self
    }
    #[inline]
    pub fn cmd_buf_labels(mut self, cmd_buf_labels: &'a [DebugUtilsLabelEXT]) -> Self {
        self.cmd_buf_label_count = cmd_buf_labels.len() as _;
        self.p_cmd_buf_labels = cmd_buf_labels.as_ptr();
        self
    }
    #[inline]
    pub fn objects(mut self, objects: &'a [DebugUtilsObjectNameInfoEXT]) -> Self {
        self.object_count = objects.len() as _;
        self.p_objects = objects.as_ptr();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDeviceMemoryReportFeaturesEXT.html>"]
pub struct PhysicalDeviceDeviceMemoryReportFeaturesEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub device_memory_report: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceDeviceMemoryReportFeaturesEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            device_memory_report: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceDeviceMemoryReportFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT;
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceDeviceMemoryReportFeaturesEXT<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceDeviceMemoryReportFeaturesEXT<'_> {}
impl<'a> PhysicalDeviceDeviceMemoryReportFeaturesEXT<'a> {
    #[inline]
    pub fn device_memory_report(mut self, device_memory_report: bool) -> Self {
        self.device_memory_report = device_memory_report.into();
        self
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceDeviceMemoryReportCreateInfoEXT.html>"]
pub struct DeviceDeviceMemoryReportCreateInfoEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: DeviceMemoryReportFlagsEXT,
    pub pfn_user_callback: PFN_vkDeviceMemoryReportCallbackEXT,
    pub p_user_data: *mut c_void,
    pub _marker: PhantomData<&'a ()>,
}
#[cfg(feature = "debug")]
impl fmt::Debug for DeviceDeviceMemoryReportCreateInfoEXT<'_> {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DeviceDeviceMemoryReportCreateInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field(
                "pfn_user_callback",
                &(self.pfn_user_callback.map(|x| x as *const ())),
            )
            .field("p_user_data", &self.p_user_data)
            .finish()
    }
}
impl ::std::default::Default for DeviceDeviceMemoryReportCreateInfoEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: DeviceMemoryReportFlagsEXT::default(),
            pfn_user_callback: PFN_vkDeviceMemoryReportCallbackEXT::default(),
            p_user_data: ::std::ptr::null_mut(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for DeviceDeviceMemoryReportCreateInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT;
}
unsafe impl ExtendsDeviceCreateInfo for DeviceDeviceMemoryReportCreateInfoEXT<'_> {}
impl<'a> DeviceDeviceMemoryReportCreateInfoEXT<'a> {
    #[inline]
    pub fn flags(mut self, flags: DeviceMemoryReportFlagsEXT) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn pfn_user_callback(
        mut self,
        pfn_user_callback: PFN_vkDeviceMemoryReportCallbackEXT,
    ) -> Self {
        self.pfn_user_callback = pfn_user_callback;
        self
    }
    #[inline]
    pub fn user_data(mut self, user_data: *mut c_void) -> Self {
        self.p_user_data = user_data;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceMemoryReportCallbackDataEXT.html>"]
pub struct DeviceMemoryReportCallbackDataEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub flags: DeviceMemoryReportFlagsEXT,
    pub ty: DeviceMemoryReportEventTypeEXT,
    pub memory_object_id: u64,
    pub size: DeviceSize,
    pub object_type: ObjectType,
    pub object_handle: u64,
    pub heap_index: u32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for DeviceMemoryReportCallbackDataEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            flags: DeviceMemoryReportFlagsEXT::default(),
            ty: DeviceMemoryReportEventTypeEXT::default(),
            memory_object_id: u64::default(),
            size: DeviceSize::default(),
            object_type: ObjectType::default(),
            object_handle: u64::default(),
            heap_index: u32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for DeviceMemoryReportCallbackDataEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DEVICE_MEMORY_REPORT_CALLBACK_DATA_EXT;
}
impl<'a> DeviceMemoryReportCallbackDataEXT<'a> {
    #[inline]
    pub fn flags(mut self, flags: DeviceMemoryReportFlagsEXT) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn ty(mut self, ty: DeviceMemoryReportEventTypeEXT) -> Self {
        self.ty = ty;
        self
    }
    #[inline]
    pub fn memory_object_id(mut self, memory_object_id: u64) -> Self {
        self.memory_object_id = memory_object_id;
        self
    }
    #[inline]
    pub fn size(mut self, size: DeviceSize) -> Self {
        self.size = size;
        self
    }
    #[inline]
    pub fn object_type(mut self, object_type: ObjectType) -> Self {
        self.object_type = object_type;
        self
    }
    #[inline]
    pub fn object_handle(mut self, object_handle: u64) -> Self {
        self.object_handle = object_handle;
        self
    }
    #[inline]
    pub fn heap_index(mut self, heap_index: u32) -> Self {
        self.heap_index = heap_index;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImportMemoryHostPointerInfoEXT.html>"]
pub struct ImportMemoryHostPointerInfoEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub handle_type: ExternalMemoryHandleTypeFlags,
    pub p_host_pointer: *mut c_void,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for ImportMemoryHostPointerInfoEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            handle_type: ExternalMemoryHandleTypeFlags::default(),
            p_host_pointer: ::std::ptr::null_mut(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for ImportMemoryHostPointerInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::IMPORT_MEMORY_HOST_POINTER_INFO_EXT;
}
unsafe impl ExtendsMemoryAllocateInfo for ImportMemoryHostPointerInfoEXT<'_> {}
impl<'a> ImportMemoryHostPointerInfoEXT<'a> {
    #[inline]
    pub fn handle_type(mut self, handle_type: ExternalMemoryHandleTypeFlags) -> Self {
        self.handle_type = handle_type;
        self
    }
    #[inline]
    pub fn host_pointer(mut self, host_pointer: *mut c_void) -> Self {
        self.p_host_pointer = host_pointer;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryHostPointerPropertiesEXT.html>"]
pub struct MemoryHostPointerPropertiesEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub memory_type_bits: u32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for MemoryHostPointerPropertiesEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            memory_type_bits: u32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for MemoryHostPointerPropertiesEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::MEMORY_HOST_POINTER_PROPERTIES_EXT;
}
impl<'a> MemoryHostPointerPropertiesEXT<'a> {
    #[inline]
    pub fn memory_type_bits(mut self, memory_type_bits: u32) -> Self {
        self.memory_type_bits = memory_type_bits;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceExternalMemoryHostPropertiesEXT.html>"]
pub struct PhysicalDeviceExternalMemoryHostPropertiesEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub min_imported_host_pointer_alignment: DeviceSize,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceExternalMemoryHostPropertiesEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            min_imported_host_pointer_alignment: DeviceSize::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceExternalMemoryHostPropertiesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT;
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceExternalMemoryHostPropertiesEXT<'_> {}
impl<'a> PhysicalDeviceExternalMemoryHostPropertiesEXT<'a> {
    #[inline]
    pub fn min_imported_host_pointer_alignment(
        mut self,
        min_imported_host_pointer_alignment: DeviceSize,
    ) -> Self {
        self.min_imported_host_pointer_alignment = min_imported_host_pointer_alignment;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceConservativeRasterizationPropertiesEXT.html>"]
pub struct PhysicalDeviceConservativeRasterizationPropertiesEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub primitive_overestimation_size: f32,
    pub max_extra_primitive_overestimation_size: f32,
    pub extra_primitive_overestimation_size_granularity: f32,
    pub primitive_underestimation: Bool32,
    pub conservative_point_and_line_rasterization: Bool32,
    pub degenerate_triangles_rasterized: Bool32,
    pub degenerate_lines_rasterized: Bool32,
    pub fully_covered_fragment_shader_input_variable: Bool32,
    pub conservative_rasterization_post_depth_coverage: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceConservativeRasterizationPropertiesEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            primitive_overestimation_size: f32::default(),
            max_extra_primitive_overestimation_size: f32::default(),
            extra_primitive_overestimation_size_granularity: f32::default(),
            primitive_underestimation: Bool32::default(),
            conservative_point_and_line_rasterization: Bool32::default(),
            degenerate_triangles_rasterized: Bool32::default(),
            degenerate_lines_rasterized: Bool32::default(),
            fully_covered_fragment_shader_input_variable: Bool32::default(),
            conservative_rasterization_post_depth_coverage: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceConservativeRasterizationPropertiesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT;
}
unsafe impl ExtendsPhysicalDeviceProperties2
    for PhysicalDeviceConservativeRasterizationPropertiesEXT<'_>
{
}
impl<'a> PhysicalDeviceConservativeRasterizationPropertiesEXT<'a> {
    #[inline]
    pub fn primitive_overestimation_size(mut self, primitive_overestimation_size: f32) -> Self {
        self.primitive_overestimation_size = primitive_overestimation_size;
        self
    }
    #[inline]
    pub fn max_extra_primitive_overestimation_size(
        mut self,
        max_extra_primitive_overestimation_size: f32,
    ) -> Self {
        self.max_extra_primitive_overestimation_size = max_extra_primitive_overestimation_size;
        self
    }
    #[inline]
    pub fn extra_primitive_overestimation_size_granularity(
        mut self,
        extra_primitive_overestimation_size_granularity: f32,
    ) -> Self {
        self.extra_primitive_overestimation_size_granularity =
            extra_primitive_overestimation_size_granularity;
        self
    }
    #[inline]
    pub fn primitive_underestimation(mut self, primitive_underestimation: bool) -> Self {
        self.primitive_underestimation = primitive_underestimation.into();
        self
    }
    #[inline]
    pub fn conservative_point_and_line_rasterization(
        mut self,
        conservative_point_and_line_rasterization: bool,
    ) -> Self {
        self.conservative_point_and_line_rasterization =
            conservative_point_and_line_rasterization.into();
        self
    }
    #[inline]
    pub fn degenerate_triangles_rasterized(
        mut self,
        degenerate_triangles_rasterized: bool,
    ) -> Self {
        self.degenerate_triangles_rasterized = degenerate_triangles_rasterized.into();
        self
    }
    #[inline]
    pub fn degenerate_lines_rasterized(mut self, degenerate_lines_rasterized: bool) -> Self {
        self.degenerate_lines_rasterized = degenerate_lines_rasterized.into();
        self
    }
    #[inline]
    pub fn fully_covered_fragment_shader_input_variable(
        mut self,
        fully_covered_fragment_shader_input_variable: bool,
    ) -> Self {
        self.fully_covered_fragment_shader_input_variable =
            fully_covered_fragment_shader_input_variable.into();
        self
    }
    #[inline]
    pub fn conservative_rasterization_post_depth_coverage(
        mut self,
        conservative_rasterization_post_depth_coverage: bool,
    ) -> Self {
        self.conservative_rasterization_post_depth_coverage =
            conservative_rasterization_post_depth_coverage.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCalibratedTimestampInfoEXT.html>"]
pub struct CalibratedTimestampInfoEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub time_domain: TimeDomainEXT,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for CalibratedTimestampInfoEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            time_domain: TimeDomainEXT::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for CalibratedTimestampInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::CALIBRATED_TIMESTAMP_INFO_EXT;
}
impl<'a> CalibratedTimestampInfoEXT<'a> {
    #[inline]
    pub fn time_domain(mut self, time_domain: TimeDomainEXT) -> Self {
        self.time_domain = time_domain;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderCorePropertiesAMD.html>"]
pub struct PhysicalDeviceShaderCorePropertiesAMD<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shader_engine_count: u32,
    pub shader_arrays_per_engine_count: u32,
    pub compute_units_per_shader_array: u32,
    pub simd_per_compute_unit: u32,
    pub wavefronts_per_simd: u32,
    pub wavefront_size: u32,
    pub sgprs_per_simd: u32,
    pub min_sgpr_allocation: u32,
    pub max_sgpr_allocation: u32,
    pub sgpr_allocation_granularity: u32,
    pub vgprs_per_simd: u32,
    pub min_vgpr_allocation: u32,
    pub max_vgpr_allocation: u32,
    pub vgpr_allocation_granularity: u32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceShaderCorePropertiesAMD<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            shader_engine_count: u32::default(),
            shader_arrays_per_engine_count: u32::default(),
            compute_units_per_shader_array: u32::default(),
            simd_per_compute_unit: u32::default(),
            wavefronts_per_simd: u32::default(),
            wavefront_size: u32::default(),
            sgprs_per_simd: u32::default(),
            min_sgpr_allocation: u32::default(),
            max_sgpr_allocation: u32::default(),
            sgpr_allocation_granularity: u32::default(),
            vgprs_per_simd: u32::default(),
            min_vgpr_allocation: u32::default(),
            max_vgpr_allocation: u32::default(),
            vgpr_allocation_granularity: u32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceShaderCorePropertiesAMD<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD;
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceShaderCorePropertiesAMD<'_> {}
impl<'a> PhysicalDeviceShaderCorePropertiesAMD<'a> {
    #[inline]
    pub fn shader_engine_count(mut self, shader_engine_count: u32) -> Self {
        self.shader_engine_count = shader_engine_count;
        self
    }
    #[inline]
    pub fn shader_arrays_per_engine_count(mut self, shader_arrays_per_engine_count: u32) -> Self {
        self.shader_arrays_per_engine_count = shader_arrays_per_engine_count;
        self
    }
    #[inline]
    pub fn compute_units_per_shader_array(mut self, compute_units_per_shader_array: u32) -> Self {
        self.compute_units_per_shader_array = compute_units_per_shader_array;
        self
    }
    #[inline]
    pub fn simd_per_compute_unit(mut self, simd_per_compute_unit: u32) -> Self {
        self.simd_per_compute_unit = simd_per_compute_unit;
        self
    }
    #[inline]
    pub fn wavefronts_per_simd(mut self, wavefronts_per_simd: u32) -> Self {
        self.wavefronts_per_simd = wavefronts_per_simd;
        self
    }
    #[inline]
    pub fn wavefront_size(mut self, wavefront_size: u32) -> Self {
        self.wavefront_size = wavefront_size;
        self
    }
    #[inline]
    pub fn sgprs_per_simd(mut self, sgprs_per_simd: u32) -> Self {
        self.sgprs_per_simd = sgprs_per_simd;
        self
    }
    #[inline]
    pub fn min_sgpr_allocation(mut self, min_sgpr_allocation: u32) -> Self {
        self.min_sgpr_allocation = min_sgpr_allocation;
        self
    }
    #[inline]
    pub fn max_sgpr_allocation(mut self, max_sgpr_allocation: u32) -> Self {
        self.max_sgpr_allocation = max_sgpr_allocation;
        self
    }
    #[inline]
    pub fn sgpr_allocation_granularity(mut self, sgpr_allocation_granularity: u32) -> Self {
        self.sgpr_allocation_granularity = sgpr_allocation_granularity;
        self
    }
    #[inline]
    pub fn vgprs_per_simd(mut self, vgprs_per_simd: u32) -> Self {
        self.vgprs_per_simd = vgprs_per_simd;
        self
    }
    #[inline]
    pub fn min_vgpr_allocation(mut self, min_vgpr_allocation: u32) -> Self {
        self.min_vgpr_allocation = min_vgpr_allocation;
        self
    }
    #[inline]
    pub fn max_vgpr_allocation(mut self, max_vgpr_allocation: u32) -> Self {
        self.max_vgpr_allocation = max_vgpr_allocation;
        self
    }
    #[inline]
    pub fn vgpr_allocation_granularity(mut self, vgpr_allocation_granularity: u32) -> Self {
        self.vgpr_allocation_granularity = vgpr_allocation_granularity;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderCoreProperties2AMD.html>"]
pub struct PhysicalDeviceShaderCoreProperties2AMD<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shader_core_features: ShaderCorePropertiesFlagsAMD,
    pub active_compute_unit_count: u32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceShaderCoreProperties2AMD<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            shader_core_features: ShaderCorePropertiesFlagsAMD::default(),
            active_compute_unit_count: u32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceShaderCoreProperties2AMD<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD;
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceShaderCoreProperties2AMD<'_> {}
impl<'a> PhysicalDeviceShaderCoreProperties2AMD<'a> {
    #[inline]
    pub fn shader_core_features(
        mut self,
        shader_core_features: ShaderCorePropertiesFlagsAMD,
    ) -> Self {
        self.shader_core_features = shader_core_features;
        self
    }
    #[inline]
    pub fn active_compute_unit_count(mut self, active_compute_unit_count: u32) -> Self {
        self.active_compute_unit_count = active_compute_unit_count;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineRasterizationConservativeStateCreateInfoEXT.html>"]
pub struct PipelineRasterizationConservativeStateCreateInfoEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: PipelineRasterizationConservativeStateCreateFlagsEXT,
    pub conservative_rasterization_mode: ConservativeRasterizationModeEXT,
    pub extra_primitive_overestimation_size: f32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PipelineRasterizationConservativeStateCreateInfoEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: PipelineRasterizationConservativeStateCreateFlagsEXT::default(),
            conservative_rasterization_mode: ConservativeRasterizationModeEXT::default(),
            extra_primitive_overestimation_size: f32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PipelineRasterizationConservativeStateCreateInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT;
}
unsafe impl ExtendsPipelineRasterizationStateCreateInfo
    for PipelineRasterizationConservativeStateCreateInfoEXT<'_>
{
}
impl<'a> PipelineRasterizationConservativeStateCreateInfoEXT<'a> {
    #[inline]
    pub fn flags(mut self, flags: PipelineRasterizationConservativeStateCreateFlagsEXT) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn conservative_rasterization_mode(
        mut self,
        conservative_rasterization_mode: ConservativeRasterizationModeEXT,
    ) -> Self {
        self.conservative_rasterization_mode = conservative_rasterization_mode;
        self
    }
    #[inline]
    pub fn extra_primitive_overestimation_size(
        mut self,
        extra_primitive_overestimation_size: f32,
    ) -> Self {
        self.extra_primitive_overestimation_size = extra_primitive_overestimation_size;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDescriptorIndexingFeatures.html>"]
pub struct PhysicalDeviceDescriptorIndexingFeatures<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shader_input_attachment_array_dynamic_indexing: Bool32,
    pub shader_uniform_texel_buffer_array_dynamic_indexing: Bool32,
    pub shader_storage_texel_buffer_array_dynamic_indexing: Bool32,
    pub shader_uniform_buffer_array_non_uniform_indexing: Bool32,
    pub shader_sampled_image_array_non_uniform_indexing: Bool32,
    pub shader_storage_buffer_array_non_uniform_indexing: Bool32,
    pub shader_storage_image_array_non_uniform_indexing: Bool32,
    pub shader_input_attachment_array_non_uniform_indexing: Bool32,
    pub shader_uniform_texel_buffer_array_non_uniform_indexing: Bool32,
    pub shader_storage_texel_buffer_array_non_uniform_indexing: Bool32,
    pub descriptor_binding_uniform_buffer_update_after_bind: Bool32,
    pub descriptor_binding_sampled_image_update_after_bind: Bool32,
    pub descriptor_binding_storage_image_update_after_bind: Bool32,
    pub descriptor_binding_storage_buffer_update_after_bind: Bool32,
    pub descriptor_binding_uniform_texel_buffer_update_after_bind: Bool32,
    pub descriptor_binding_storage_texel_buffer_update_after_bind: Bool32,
    pub descriptor_binding_update_unused_while_pending: Bool32,
    pub descriptor_binding_partially_bound: Bool32,
    pub descriptor_binding_variable_descriptor_count: Bool32,
    pub runtime_descriptor_array: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceDescriptorIndexingFeatures<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            shader_input_attachment_array_dynamic_indexing: Bool32::default(),
            shader_uniform_texel_buffer_array_dynamic_indexing: Bool32::default(),
            shader_storage_texel_buffer_array_dynamic_indexing: Bool32::default(),
            shader_uniform_buffer_array_non_uniform_indexing: Bool32::default(),
            shader_sampled_image_array_non_uniform_indexing: Bool32::default(),
            shader_storage_buffer_array_non_uniform_indexing: Bool32::default(),
            shader_storage_image_array_non_uniform_indexing: Bool32::default(),
            shader_input_attachment_array_non_uniform_indexing: Bool32::default(),
            shader_uniform_texel_buffer_array_non_uniform_indexing: Bool32::default(),
            shader_storage_texel_buffer_array_non_uniform_indexing: Bool32::default(),
            descriptor_binding_uniform_buffer_update_after_bind: Bool32::default(),
            descriptor_binding_sampled_image_update_after_bind: Bool32::default(),
            descriptor_binding_storage_image_update_after_bind: Bool32::default(),
            descriptor_binding_storage_buffer_update_after_bind: Bool32::default(),
            descriptor_binding_uniform_texel_buffer_update_after_bind: Bool32::default(),
            descriptor_binding_storage_texel_buffer_update_after_bind: Bool32::default(),
            descriptor_binding_update_unused_while_pending: Bool32::default(),
            descriptor_binding_partially_bound: Bool32::default(),
            descriptor_binding_variable_descriptor_count: Bool32::default(),
            runtime_descriptor_array: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceDescriptorIndexingFeatures<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES;
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceDescriptorIndexingFeatures<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceDescriptorIndexingFeatures<'_> {}
impl<'a> PhysicalDeviceDescriptorIndexingFeatures<'a> {
    #[inline]
    pub fn shader_input_attachment_array_dynamic_indexing(
        mut self,
        shader_input_attachment_array_dynamic_indexing: bool,
    ) -> Self {
        self.shader_input_attachment_array_dynamic_indexing =
            shader_input_attachment_array_dynamic_indexing.into();
        self
    }
    #[inline]
    pub fn shader_uniform_texel_buffer_array_dynamic_indexing(
        mut self,
        shader_uniform_texel_buffer_array_dynamic_indexing: bool,
    ) -> Self {
        self.shader_uniform_texel_buffer_array_dynamic_indexing =
            shader_uniform_texel_buffer_array_dynamic_indexing.into();
        self
    }
    #[inline]
    pub fn shader_storage_texel_buffer_array_dynamic_indexing(
        mut self,
        shader_storage_texel_buffer_array_dynamic_indexing: bool,
    ) -> Self {
        self.shader_storage_texel_buffer_array_dynamic_indexing =
            shader_storage_texel_buffer_array_dynamic_indexing.into();
        self
    }
    #[inline]
    pub fn shader_uniform_buffer_array_non_uniform_indexing(
        mut self,
        shader_uniform_buffer_array_non_uniform_indexing: bool,
    ) -> Self {
        self.shader_uniform_buffer_array_non_uniform_indexing =
            shader_uniform_buffer_array_non_uniform_indexing.into();
        self
    }
    #[inline]
    pub fn shader_sampled_image_array_non_uniform_indexing(
        mut self,
        shader_sampled_image_array_non_uniform_indexing: bool,
    ) -> Self {
        self.shader_sampled_image_array_non_uniform_indexing =
            shader_sampled_image_array_non_uniform_indexing.into();
        self
    }
    #[inline]
    pub fn shader_storage_buffer_array_non_uniform_indexing(
        mut self,
        shader_storage_buffer_array_non_uniform_indexing: bool,
    ) -> Self {
        self.shader_storage_buffer_array_non_uniform_indexing =
            shader_storage_buffer_array_non_uniform_indexing.into();
        self
    }
    #[inline]
    pub fn shader_storage_image_array_non_uniform_indexing(
        mut self,
        shader_storage_image_array_non_uniform_indexing: bool,
    ) -> Self {
        self.shader_storage_image_array_non_uniform_indexing =
            shader_storage_image_array_non_uniform_indexing.into();
        self
    }
    #[inline]
    pub fn shader_input_attachment_array_non_uniform_indexing(
        mut self,
        shader_input_attachment_array_non_uniform_indexing: bool,
    ) -> Self {
        self.shader_input_attachment_array_non_uniform_indexing =
            shader_input_attachment_array_non_uniform_indexing.into();
        self
    }
    #[inline]
    pub fn shader_uniform_texel_buffer_array_non_uniform_indexing(
        mut self,
        shader_uniform_texel_buffer_array_non_uniform_indexing: bool,
    ) -> Self {
        self.shader_uniform_texel_buffer_array_non_uniform_indexing =
            shader_uniform_texel_buffer_array_non_uniform_indexing.into();
        self
    }
    #[inline]
    pub fn shader_storage_texel_buffer_array_non_uniform_indexing(
        mut self,
        shader_storage_texel_buffer_array_non_uniform_indexing: bool,
    ) -> Self {
        self.shader_storage_texel_buffer_array_non_uniform_indexing =
            shader_storage_texel_buffer_array_non_uniform_indexing.into();
        self
    }
    #[inline]
    pub fn descriptor_binding_uniform_buffer_update_after_bind(
        mut self,
        descriptor_binding_uniform_buffer_update_after_bind: bool,
    ) -> Self {
        self.descriptor_binding_uniform_buffer_update_after_bind =
            descriptor_binding_uniform_buffer_update_after_bind.into();
        self
    }
    #[inline]
    pub fn descriptor_binding_sampled_image_update_after_bind(
        mut self,
        descriptor_binding_sampled_image_update_after_bind: bool,
    ) -> Self {
        self.descriptor_binding_sampled_image_update_after_bind =
            descriptor_binding_sampled_image_update_after_bind.into();
        self
    }
    #[inline]
    pub fn descriptor_binding_storage_image_update_after_bind(
        mut self,
        descriptor_binding_storage_image_update_after_bind: bool,
    ) -> Self {
        self.descriptor_binding_storage_image_update_after_bind =
            descriptor_binding_storage_image_update_after_bind.into();
        self
    }
    #[inline]
    pub fn descriptor_binding_storage_buffer_update_after_bind(
        mut self,
        descriptor_binding_storage_buffer_update_after_bind: bool,
    ) -> Self {
        self.descriptor_binding_storage_buffer_update_after_bind =
            descriptor_binding_storage_buffer_update_after_bind.into();
        self
    }
    #[inline]
    pub fn descriptor_binding_uniform_texel_buffer_update_after_bind(
        mut self,
        descriptor_binding_uniform_texel_buffer_update_after_bind: bool,
    ) -> Self {
        self.descriptor_binding_uniform_texel_buffer_update_after_bind =
            descriptor_binding_uniform_texel_buffer_update_after_bind.into();
        self
    }
    #[inline]
    pub fn descriptor_binding_storage_texel_buffer_update_after_bind(
        mut self,
        descriptor_binding_storage_texel_buffer_update_after_bind: bool,
    ) -> Self {
        self.descriptor_binding_storage_texel_buffer_update_after_bind =
            descriptor_binding_storage_texel_buffer_update_after_bind.into();
        self
    }
    #[inline]
    pub fn descriptor_binding_update_unused_while_pending(
        mut self,
        descriptor_binding_update_unused_while_pending: bool,
    ) -> Self {
        self.descriptor_binding_update_unused_while_pending =
            descriptor_binding_update_unused_while_pending.into();
        self
    }
    #[inline]
    pub fn descriptor_binding_partially_bound(
        mut self,
        descriptor_binding_partially_bound: bool,
    ) -> Self {
        self.descriptor_binding_partially_bound = descriptor_binding_partially_bound.into();
        self
    }
    #[inline]
    pub fn descriptor_binding_variable_descriptor_count(
        mut self,
        descriptor_binding_variable_descriptor_count: bool,
    ) -> Self {
        self.descriptor_binding_variable_descriptor_count =
            descriptor_binding_variable_descriptor_count.into();
        self
    }
    #[inline]
    pub fn runtime_descriptor_array(mut self, runtime_descriptor_array: bool) -> Self {
        self.runtime_descriptor_array = runtime_descriptor_array.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDescriptorIndexingProperties.html>"]
pub struct PhysicalDeviceDescriptorIndexingProperties<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub max_update_after_bind_descriptors_in_all_pools: u32,
    pub shader_uniform_buffer_array_non_uniform_indexing_native: Bool32,
    pub shader_sampled_image_array_non_uniform_indexing_native: Bool32,
    pub shader_storage_buffer_array_non_uniform_indexing_native: Bool32,
    pub shader_storage_image_array_non_uniform_indexing_native: Bool32,
    pub shader_input_attachment_array_non_uniform_indexing_native: Bool32,
    pub robust_buffer_access_update_after_bind: Bool32,
    pub quad_divergent_implicit_lod: Bool32,
    pub max_per_stage_descriptor_update_after_bind_samplers: u32,
    pub max_per_stage_descriptor_update_after_bind_uniform_buffers: u32,
    pub max_per_stage_descriptor_update_after_bind_storage_buffers: u32,
    pub max_per_stage_descriptor_update_after_bind_sampled_images: u32,
    pub max_per_stage_descriptor_update_after_bind_storage_images: u32,
    pub max_per_stage_descriptor_update_after_bind_input_attachments: u32,
    pub max_per_stage_update_after_bind_resources: u32,
    pub max_descriptor_set_update_after_bind_samplers: u32,
    pub max_descriptor_set_update_after_bind_uniform_buffers: u32,
    pub max_descriptor_set_update_after_bind_uniform_buffers_dynamic: u32,
    pub max_descriptor_set_update_after_bind_storage_buffers: u32,
    pub max_descriptor_set_update_after_bind_storage_buffers_dynamic: u32,
    pub max_descriptor_set_update_after_bind_sampled_images: u32,
    pub max_descriptor_set_update_after_bind_storage_images: u32,
    pub max_descriptor_set_update_after_bind_input_attachments: u32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceDescriptorIndexingProperties<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            max_update_after_bind_descriptors_in_all_pools: u32::default(),
            shader_uniform_buffer_array_non_uniform_indexing_native: Bool32::default(),
            shader_sampled_image_array_non_uniform_indexing_native: Bool32::default(),
            shader_storage_buffer_array_non_uniform_indexing_native: Bool32::default(),
            shader_storage_image_array_non_uniform_indexing_native: Bool32::default(),
            shader_input_attachment_array_non_uniform_indexing_native: Bool32::default(),
            robust_buffer_access_update_after_bind: Bool32::default(),
            quad_divergent_implicit_lod: Bool32::default(),
            max_per_stage_descriptor_update_after_bind_samplers: u32::default(),
            max_per_stage_descriptor_update_after_bind_uniform_buffers: u32::default(),
            max_per_stage_descriptor_update_after_bind_storage_buffers: u32::default(),
            max_per_stage_descriptor_update_after_bind_sampled_images: u32::default(),
            max_per_stage_descriptor_update_after_bind_storage_images: u32::default(),
            max_per_stage_descriptor_update_after_bind_input_attachments: u32::default(),
            max_per_stage_update_after_bind_resources: u32::default(),
            max_descriptor_set_update_after_bind_samplers: u32::default(),
            max_descriptor_set_update_after_bind_uniform_buffers: u32::default(),
            max_descriptor_set_update_after_bind_uniform_buffers_dynamic: u32::default(),
            max_descriptor_set_update_after_bind_storage_buffers: u32::default(),
            max_descriptor_set_update_after_bind_storage_buffers_dynamic: u32::default(),
            max_descriptor_set_update_after_bind_sampled_images: u32::default(),
            max_descriptor_set_update_after_bind_storage_images: u32::default(),
            max_descriptor_set_update_after_bind_input_attachments: u32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceDescriptorIndexingProperties<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES;
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceDescriptorIndexingProperties<'_> {}
impl<'a> PhysicalDeviceDescriptorIndexingProperties<'a> {
    #[inline]
    pub fn max_update_after_bind_descriptors_in_all_pools(
        mut self,
        max_update_after_bind_descriptors_in_all_pools: u32,
    ) -> Self {
        self.max_update_after_bind_descriptors_in_all_pools =
            max_update_after_bind_descriptors_in_all_pools;
        self
    }
    #[inline]
    pub fn shader_uniform_buffer_array_non_uniform_indexing_native(
        mut self,
        shader_uniform_buffer_array_non_uniform_indexing_native: bool,
    ) -> Self {
        self.shader_uniform_buffer_array_non_uniform_indexing_native =
            shader_uniform_buffer_array_non_uniform_indexing_native.into();
        self
    }
    #[inline]
    pub fn shader_sampled_image_array_non_uniform_indexing_native(
        mut self,
        shader_sampled_image_array_non_uniform_indexing_native: bool,
    ) -> Self {
        self.shader_sampled_image_array_non_uniform_indexing_native =
            shader_sampled_image_array_non_uniform_indexing_native.into();
        self
    }
    #[inline]
    pub fn shader_storage_buffer_array_non_uniform_indexing_native(
        mut self,
        shader_storage_buffer_array_non_uniform_indexing_native: bool,
    ) -> Self {
        self.shader_storage_buffer_array_non_uniform_indexing_native =
            shader_storage_buffer_array_non_uniform_indexing_native.into();
        self
    }
    #[inline]
    pub fn shader_storage_image_array_non_uniform_indexing_native(
        mut self,
        shader_storage_image_array_non_uniform_indexing_native: bool,
    ) -> Self {
        self.shader_storage_image_array_non_uniform_indexing_native =
            shader_storage_image_array_non_uniform_indexing_native.into();
        self
    }
    #[inline]
    pub fn shader_input_attachment_array_non_uniform_indexing_native(
        mut self,
        shader_input_attachment_array_non_uniform_indexing_native: bool,
    ) -> Self {
        self.shader_input_attachment_array_non_uniform_indexing_native =
            shader_input_attachment_array_non_uniform_indexing_native.into();
        self
    }
    #[inline]
    pub fn robust_buffer_access_update_after_bind(
        mut self,
        robust_buffer_access_update_after_bind: bool,
    ) -> Self {
        self.robust_buffer_access_update_after_bind = robust_buffer_access_update_after_bind.into();
        self
    }
    #[inline]
    pub fn quad_divergent_implicit_lod(mut self, quad_divergent_implicit_lod: bool) -> Self {
        self.quad_divergent_implicit_lod = quad_divergent_implicit_lod.into();
        self
    }
    #[inline]
    pub fn max_per_stage_descriptor_update_after_bind_samplers(
        mut self,
        max_per_stage_descriptor_update_after_bind_samplers: u32,
    ) -> Self {
        self.max_per_stage_descriptor_update_after_bind_samplers =
            max_per_stage_descriptor_update_after_bind_samplers;
        self
    }
    #[inline]
    pub fn max_per_stage_descriptor_update_after_bind_uniform_buffers(
        mut self,
        max_per_stage_descriptor_update_after_bind_uniform_buffers: u32,
    ) -> Self {
        self.max_per_stage_descriptor_update_after_bind_uniform_buffers =
            max_per_stage_descriptor_update_after_bind_uniform_buffers;
        self
    }
    #[inline]
    pub fn max_per_stage_descriptor_update_after_bind_storage_buffers(
        mut self,
        max_per_stage_descriptor_update_after_bind_storage_buffers: u32,
    ) -> Self {
        self.max_per_stage_descriptor_update_after_bind_storage_buffers =
            max_per_stage_descriptor_update_after_bind_storage_buffers;
        self
    }
    #[inline]
    pub fn max_per_stage_descriptor_update_after_bind_sampled_images(
        mut self,
        max_per_stage_descriptor_update_after_bind_sampled_images: u32,
    ) -> Self {
        self.max_per_stage_descriptor_update_after_bind_sampled_images =
            max_per_stage_descriptor_update_after_bind_sampled_images;
        self
    }
    #[inline]
    pub fn max_per_stage_descriptor_update_after_bind_storage_images(
        mut self,
        max_per_stage_descriptor_update_after_bind_storage_images: u32,
    ) -> Self {
        self.max_per_stage_descriptor_update_after_bind_storage_images =
            max_per_stage_descriptor_update_after_bind_storage_images;
        self
    }
    #[inline]
    pub fn max_per_stage_descriptor_update_after_bind_input_attachments(
        mut self,
        max_per_stage_descriptor_update_after_bind_input_attachments: u32,
    ) -> Self {
        self.max_per_stage_descriptor_update_after_bind_input_attachments =
            max_per_stage_descriptor_update_after_bind_input_attachments;
        self
    }
    #[inline]
    pub fn max_per_stage_update_after_bind_resources(
        mut self,
        max_per_stage_update_after_bind_resources: u32,
    ) -> Self {
        self.max_per_stage_update_after_bind_resources = max_per_stage_update_after_bind_resources;
        self
    }
    #[inline]
    pub fn max_descriptor_set_update_after_bind_samplers(
        mut self,
        max_descriptor_set_update_after_bind_samplers: u32,
    ) -> Self {
        self.max_descriptor_set_update_after_bind_samplers =
            max_descriptor_set_update_after_bind_samplers;
        self
    }
    #[inline]
    pub fn max_descriptor_set_update_after_bind_uniform_buffers(
        mut self,
        max_descriptor_set_update_after_bind_uniform_buffers: u32,
    ) -> Self {
        self.max_descriptor_set_update_after_bind_uniform_buffers =
            max_descriptor_set_update_after_bind_uniform_buffers;
        self
    }
    #[inline]
    pub fn max_descriptor_set_update_after_bind_uniform_buffers_dynamic(
        mut self,
        max_descriptor_set_update_after_bind_uniform_buffers_dynamic: u32,
    ) -> Self {
        self.max_descriptor_set_update_after_bind_uniform_buffers_dynamic =
            max_descriptor_set_update_after_bind_uniform_buffers_dynamic;
        self
    }
    #[inline]
    pub fn max_descriptor_set_update_after_bind_storage_buffers(
        mut self,
        max_descriptor_set_update_after_bind_storage_buffers: u32,
    ) -> Self {
        self.max_descriptor_set_update_after_bind_storage_buffers =
            max_descriptor_set_update_after_bind_storage_buffers;
        self
    }
    #[inline]
    pub fn max_descriptor_set_update_after_bind_storage_buffers_dynamic(
        mut self,
        max_descriptor_set_update_after_bind_storage_buffers_dynamic: u32,
    ) -> Self {
        self.max_descriptor_set_update_after_bind_storage_buffers_dynamic =
            max_descriptor_set_update_after_bind_storage_buffers_dynamic;
        self
    }
    #[inline]
    pub fn max_descriptor_set_update_after_bind_sampled_images(
        mut self,
        max_descriptor_set_update_after_bind_sampled_images: u32,
    ) -> Self {
        self.max_descriptor_set_update_after_bind_sampled_images =
            max_descriptor_set_update_after_bind_sampled_images;
        self
    }
    #[inline]
    pub fn max_descriptor_set_update_after_bind_storage_images(
        mut self,
        max_descriptor_set_update_after_bind_storage_images: u32,
    ) -> Self {
        self.max_descriptor_set_update_after_bind_storage_images =
            max_descriptor_set_update_after_bind_storage_images;
        self
    }
    #[inline]
    pub fn max_descriptor_set_update_after_bind_input_attachments(
        mut self,
        max_descriptor_set_update_after_bind_input_attachments: u32,
    ) -> Self {
        self.max_descriptor_set_update_after_bind_input_attachments =
            max_descriptor_set_update_after_bind_input_attachments;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorSetLayoutBindingFlagsCreateInfo.html>"]
pub struct DescriptorSetLayoutBindingFlagsCreateInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub binding_count: u32,
    pub p_binding_flags: *const DescriptorBindingFlags,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for DescriptorSetLayoutBindingFlagsCreateInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            binding_count: u32::default(),
            p_binding_flags: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for DescriptorSetLayoutBindingFlagsCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO;
}
unsafe impl ExtendsDescriptorSetLayoutCreateInfo for DescriptorSetLayoutBindingFlagsCreateInfo<'_> {}
impl<'a> DescriptorSetLayoutBindingFlagsCreateInfo<'a> {
    #[inline]
    pub fn binding_flags(mut self, binding_flags: &'a [DescriptorBindingFlags]) -> Self {
        self.binding_count = binding_flags.len() as _;
        self.p_binding_flags = binding_flags.as_ptr();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorSetVariableDescriptorCountAllocateInfo.html>"]
pub struct DescriptorSetVariableDescriptorCountAllocateInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub descriptor_set_count: u32,
    pub p_descriptor_counts: *const u32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for DescriptorSetVariableDescriptorCountAllocateInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            descriptor_set_count: u32::default(),
            p_descriptor_counts: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for DescriptorSetVariableDescriptorCountAllocateInfo<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO;
}
unsafe impl ExtendsDescriptorSetAllocateInfo
    for DescriptorSetVariableDescriptorCountAllocateInfo<'_>
{
}
impl<'a> DescriptorSetVariableDescriptorCountAllocateInfo<'a> {
    #[inline]
    pub fn descriptor_counts(mut self, descriptor_counts: &'a [u32]) -> Self {
        self.descriptor_set_count = descriptor_counts.len() as _;
        self.p_descriptor_counts = descriptor_counts.as_ptr();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorSetVariableDescriptorCountLayoutSupport.html>"]
pub struct DescriptorSetVariableDescriptorCountLayoutSupport<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub max_variable_descriptor_count: u32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for DescriptorSetVariableDescriptorCountLayoutSupport<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            max_variable_descriptor_count: u32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for DescriptorSetVariableDescriptorCountLayoutSupport<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT;
}
unsafe impl ExtendsDescriptorSetLayoutSupport
    for DescriptorSetVariableDescriptorCountLayoutSupport<'_>
{
}
impl<'a> DescriptorSetVariableDescriptorCountLayoutSupport<'a> {
    #[inline]
    pub fn max_variable_descriptor_count(mut self, max_variable_descriptor_count: u32) -> Self {
        self.max_variable_descriptor_count = max_variable_descriptor_count;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAttachmentDescription2.html>"]
pub struct AttachmentDescription2<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: AttachmentDescriptionFlags,
    pub format: Format,
    pub samples: SampleCountFlags,
    pub load_op: AttachmentLoadOp,
    pub store_op: AttachmentStoreOp,
    pub stencil_load_op: AttachmentLoadOp,
    pub stencil_store_op: AttachmentStoreOp,
    pub initial_layout: ImageLayout,
    pub final_layout: ImageLayout,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for AttachmentDescription2<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: AttachmentDescriptionFlags::default(),
            format: Format::default(),
            samples: SampleCountFlags::default(),
            load_op: AttachmentLoadOp::default(),
            store_op: AttachmentStoreOp::default(),
            stencil_load_op: AttachmentLoadOp::default(),
            stencil_store_op: AttachmentStoreOp::default(),
            initial_layout: ImageLayout::default(),
            final_layout: ImageLayout::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for AttachmentDescription2<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ATTACHMENT_DESCRIPTION_2;
}
pub unsafe trait ExtendsAttachmentDescription2 {}
impl<'a> AttachmentDescription2<'a> {
    #[inline]
    pub fn flags(mut self, flags: AttachmentDescriptionFlags) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn format(mut self, format: Format) -> Self {
        self.format = format;
        self
    }
    #[inline]
    pub fn samples(mut self, samples: SampleCountFlags) -> Self {
        self.samples = samples;
        self
    }
    #[inline]
    pub fn load_op(mut self, load_op: AttachmentLoadOp) -> Self {
        self.load_op = load_op;
        self
    }
    #[inline]
    pub fn store_op(mut self, store_op: AttachmentStoreOp) -> Self {
        self.store_op = store_op;
        self
    }
    #[inline]
    pub fn stencil_load_op(mut self, stencil_load_op: AttachmentLoadOp) -> Self {
        self.stencil_load_op = stencil_load_op;
        self
    }
    #[inline]
    pub fn stencil_store_op(mut self, stencil_store_op: AttachmentStoreOp) -> Self {
        self.stencil_store_op = stencil_store_op;
        self
    }
    #[inline]
    pub fn initial_layout(mut self, initial_layout: ImageLayout) -> Self {
        self.initial_layout = initial_layout;
        self
    }
    #[inline]
    pub fn final_layout(mut self, final_layout: ImageLayout) -> Self {
        self.final_layout = final_layout;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `x.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsAttachmentDescription2>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.p_next as _;
            self.p_next = next_ptr;
        }
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAttachmentReference2.html>"]
pub struct AttachmentReference2<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub attachment: u32,
    pub layout: ImageLayout,
    pub aspect_mask: ImageAspectFlags,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for AttachmentReference2<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            attachment: u32::default(),
            layout: ImageLayout::default(),
            aspect_mask: ImageAspectFlags::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for AttachmentReference2<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ATTACHMENT_REFERENCE_2;
}
pub unsafe trait ExtendsAttachmentReference2 {}
impl<'a> AttachmentReference2<'a> {
    #[inline]
    pub fn attachment(mut self, attachment: u32) -> Self {
        self.attachment = attachment;
        self
    }
    #[inline]
    pub fn layout(mut self, layout: ImageLayout) -> Self {
        self.layout = layout;
        self
    }
    #[inline]
    pub fn aspect_mask(mut self, aspect_mask: ImageAspectFlags) -> Self {
        self.aspect_mask = aspect_mask;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `x.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsAttachmentReference2>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.p_next as _;
            self.p_next = next_ptr;
        }
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSubpassDescription2.html>"]
pub struct SubpassDescription2<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: SubpassDescriptionFlags,
    pub pipeline_bind_point: PipelineBindPoint,
    pub view_mask: u32,
    pub input_attachment_count: u32,
    pub p_input_attachments: *const AttachmentReference2<'a>,
    pub color_attachment_count: u32,
    pub p_color_attachments: *const AttachmentReference2<'a>,
    pub p_resolve_attachments: *const AttachmentReference2<'a>,
    pub p_depth_stencil_attachment: *const AttachmentReference2<'a>,
    pub preserve_attachment_count: u32,
    pub p_preserve_attachments: *const u32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for SubpassDescription2<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: SubpassDescriptionFlags::default(),
            pipeline_bind_point: PipelineBindPoint::default(),
            view_mask: u32::default(),
            input_attachment_count: u32::default(),
            p_input_attachments: ::std::ptr::null(),
            color_attachment_count: u32::default(),
            p_color_attachments: ::std::ptr::null(),
            p_resolve_attachments: ::std::ptr::null(),
            p_depth_stencil_attachment: ::std::ptr::null(),
            preserve_attachment_count: u32::default(),
            p_preserve_attachments: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for SubpassDescription2<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::SUBPASS_DESCRIPTION_2;
}
pub unsafe trait ExtendsSubpassDescription2 {}
impl<'a> SubpassDescription2<'a> {
    #[inline]
    pub fn flags(mut self, flags: SubpassDescriptionFlags) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn pipeline_bind_point(mut self, pipeline_bind_point: PipelineBindPoint) -> Self {
        self.pipeline_bind_point = pipeline_bind_point;
        self
    }
    #[inline]
    pub fn view_mask(mut self, view_mask: u32) -> Self {
        self.view_mask = view_mask;
        self
    }
    #[inline]
    pub fn input_attachments(mut self, input_attachments: &'a [AttachmentReference2]) -> Self {
        self.input_attachment_count = input_attachments.len() as _;
        self.p_input_attachments = input_attachments.as_ptr();
        self
    }
    #[inline]
    pub fn color_attachments(mut self, color_attachments: &'a [AttachmentReference2]) -> Self {
        self.color_attachment_count = color_attachments.len() as _;
        self.p_color_attachments = color_attachments.as_ptr();
        self
    }
    #[inline]
    pub fn resolve_attachments(mut self, resolve_attachments: &'a [AttachmentReference2]) -> Self {
        self.color_attachment_count = resolve_attachments.len() as _;
        self.p_resolve_attachments = resolve_attachments.as_ptr();
        self
    }
    #[inline]
    pub fn depth_stencil_attachment(
        mut self,
        depth_stencil_attachment: &'a AttachmentReference2<'a>,
    ) -> Self {
        self.p_depth_stencil_attachment = depth_stencil_attachment;
        self
    }
    #[inline]
    pub fn preserve_attachments(mut self, preserve_attachments: &'a [u32]) -> Self {
        self.preserve_attachment_count = preserve_attachments.len() as _;
        self.p_preserve_attachments = preserve_attachments.as_ptr();
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `x.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsSubpassDescription2>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.p_next as _;
            self.p_next = next_ptr;
        }
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSubpassDependency2.html>"]
pub struct SubpassDependency2<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub src_subpass: u32,
    pub dst_subpass: u32,
    pub src_stage_mask: PipelineStageFlags,
    pub dst_stage_mask: PipelineStageFlags,
    pub src_access_mask: AccessFlags,
    pub dst_access_mask: AccessFlags,
    pub dependency_flags: DependencyFlags,
    pub view_offset: i32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for SubpassDependency2<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            src_subpass: u32::default(),
            dst_subpass: u32::default(),
            src_stage_mask: PipelineStageFlags::default(),
            dst_stage_mask: PipelineStageFlags::default(),
            src_access_mask: AccessFlags::default(),
            dst_access_mask: AccessFlags::default(),
            dependency_flags: DependencyFlags::default(),
            view_offset: i32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for SubpassDependency2<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::SUBPASS_DEPENDENCY_2;
}
pub unsafe trait ExtendsSubpassDependency2 {}
impl<'a> SubpassDependency2<'a> {
    #[inline]
    pub fn src_subpass(mut self, src_subpass: u32) -> Self {
        self.src_subpass = src_subpass;
        self
    }
    #[inline]
    pub fn dst_subpass(mut self, dst_subpass: u32) -> Self {
        self.dst_subpass = dst_subpass;
        self
    }
    #[inline]
    pub fn src_stage_mask(mut self, src_stage_mask: PipelineStageFlags) -> Self {
        self.src_stage_mask = src_stage_mask;
        self
    }
    #[inline]
    pub fn dst_stage_mask(mut self, dst_stage_mask: PipelineStageFlags) -> Self {
        self.dst_stage_mask = dst_stage_mask;
        self
    }
    #[inline]
    pub fn src_access_mask(mut self, src_access_mask: AccessFlags) -> Self {
        self.src_access_mask = src_access_mask;
        self
    }
    #[inline]
    pub fn dst_access_mask(mut self, dst_access_mask: AccessFlags) -> Self {
        self.dst_access_mask = dst_access_mask;
        self
    }
    #[inline]
    pub fn dependency_flags(mut self, dependency_flags: DependencyFlags) -> Self {
        self.dependency_flags = dependency_flags;
        self
    }
    #[inline]
    pub fn view_offset(mut self, view_offset: i32) -> Self {
        self.view_offset = view_offset;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `x.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsSubpassDependency2>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.p_next as _;
            self.p_next = next_ptr;
        }
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderPassCreateInfo2.html>"]
pub struct RenderPassCreateInfo2<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: RenderPassCreateFlags,
    pub attachment_count: u32,
    pub p_attachments: *const AttachmentDescription2<'a>,
    pub subpass_count: u32,
    pub p_subpasses: *const SubpassDescription2<'a>,
    pub dependency_count: u32,
    pub p_dependencies: *const SubpassDependency2<'a>,
    pub correlated_view_mask_count: u32,
    pub p_correlated_view_masks: *const u32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for RenderPassCreateInfo2<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: RenderPassCreateFlags::default(),
            attachment_count: u32::default(),
            p_attachments: ::std::ptr::null(),
            subpass_count: u32::default(),
            p_subpasses: ::std::ptr::null(),
            dependency_count: u32::default(),
            p_dependencies: ::std::ptr::null(),
            correlated_view_mask_count: u32::default(),
            p_correlated_view_masks: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for RenderPassCreateInfo2<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::RENDER_PASS_CREATE_INFO_2;
}
pub unsafe trait ExtendsRenderPassCreateInfo2 {}
impl<'a> RenderPassCreateInfo2<'a> {
    #[inline]
    pub fn flags(mut self, flags: RenderPassCreateFlags) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn attachments(mut self, attachments: &'a [AttachmentDescription2]) -> Self {
        self.attachment_count = attachments.len() as _;
        self.p_attachments = attachments.as_ptr();
        self
    }
    #[inline]
    pub fn subpasses(mut self, subpasses: &'a [SubpassDescription2]) -> Self {
        self.subpass_count = subpasses.len() as _;
        self.p_subpasses = subpasses.as_ptr();
        self
    }
    #[inline]
    pub fn dependencies(mut self, dependencies: &'a [SubpassDependency2]) -> Self {
        self.dependency_count = dependencies.len() as _;
        self.p_dependencies = dependencies.as_ptr();
        self
    }
    #[inline]
    pub fn correlated_view_masks(mut self, correlated_view_masks: &'a [u32]) -> Self {
        self.correlated_view_mask_count = correlated_view_masks.len() as _;
        self.p_correlated_view_masks = correlated_view_masks.as_ptr();
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `x.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsRenderPassCreateInfo2>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.p_next as _;
            self.p_next = next_ptr;
        }
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSubpassBeginInfo.html>"]
pub struct SubpassBeginInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub contents: SubpassContents,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for SubpassBeginInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            contents: SubpassContents::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for SubpassBeginInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::SUBPASS_BEGIN_INFO;
}
impl<'a> SubpassBeginInfo<'a> {
    #[inline]
    pub fn contents(mut self, contents: SubpassContents) -> Self {
        self.contents = contents;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSubpassEndInfo.html>"]
pub struct SubpassEndInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for SubpassEndInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for SubpassEndInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::SUBPASS_END_INFO;
}
pub unsafe trait ExtendsSubpassEndInfo {}
impl<'a> SubpassEndInfo<'a> {
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `x.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsSubpassEndInfo>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.p_next as _;
            self.p_next = next_ptr;
        }
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceTimelineSemaphoreFeatures.html>"]
pub struct PhysicalDeviceTimelineSemaphoreFeatures<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub timeline_semaphore: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceTimelineSemaphoreFeatures<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            timeline_semaphore: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceTimelineSemaphoreFeatures<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES;
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceTimelineSemaphoreFeatures<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceTimelineSemaphoreFeatures<'_> {}
impl<'a> PhysicalDeviceTimelineSemaphoreFeatures<'a> {
    #[inline]
    pub fn timeline_semaphore(mut self, timeline_semaphore: bool) -> Self {
        self.timeline_semaphore = timeline_semaphore.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceTimelineSemaphoreProperties.html>"]
pub struct PhysicalDeviceTimelineSemaphoreProperties<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub max_timeline_semaphore_value_difference: u64,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceTimelineSemaphoreProperties<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            max_timeline_semaphore_value_difference: u64::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceTimelineSemaphoreProperties<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES;
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceTimelineSemaphoreProperties<'_> {}
impl<'a> PhysicalDeviceTimelineSemaphoreProperties<'a> {
    #[inline]
    pub fn max_timeline_semaphore_value_difference(
        mut self,
        max_timeline_semaphore_value_difference: u64,
    ) -> Self {
        self.max_timeline_semaphore_value_difference = max_timeline_semaphore_value_difference;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSemaphoreTypeCreateInfo.html>"]
pub struct SemaphoreTypeCreateInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub semaphore_type: SemaphoreType,
    pub initial_value: u64,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for SemaphoreTypeCreateInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            semaphore_type: SemaphoreType::default(),
            initial_value: u64::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for SemaphoreTypeCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::SEMAPHORE_TYPE_CREATE_INFO;
}
unsafe impl ExtendsSemaphoreCreateInfo for SemaphoreTypeCreateInfo<'_> {}
unsafe impl ExtendsPhysicalDeviceExternalSemaphoreInfo for SemaphoreTypeCreateInfo<'_> {}
impl<'a> SemaphoreTypeCreateInfo<'a> {
    #[inline]
    pub fn semaphore_type(mut self, semaphore_type: SemaphoreType) -> Self {
        self.semaphore_type = semaphore_type;
        self
    }
    #[inline]
    pub fn initial_value(mut self, initial_value: u64) -> Self {
        self.initial_value = initial_value;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkTimelineSemaphoreSubmitInfo.html>"]
pub struct TimelineSemaphoreSubmitInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub wait_semaphore_value_count: u32,
    pub p_wait_semaphore_values: *const u64,
    pub signal_semaphore_value_count: u32,
    pub p_signal_semaphore_values: *const u64,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for TimelineSemaphoreSubmitInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            wait_semaphore_value_count: u32::default(),
            p_wait_semaphore_values: ::std::ptr::null(),
            signal_semaphore_value_count: u32::default(),
            p_signal_semaphore_values: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for TimelineSemaphoreSubmitInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::TIMELINE_SEMAPHORE_SUBMIT_INFO;
}
unsafe impl ExtendsSubmitInfo for TimelineSemaphoreSubmitInfo<'_> {}
unsafe impl ExtendsBindSparseInfo for TimelineSemaphoreSubmitInfo<'_> {}
impl<'a> TimelineSemaphoreSubmitInfo<'a> {
    #[inline]
    pub fn wait_semaphore_values(mut self, wait_semaphore_values: &'a [u64]) -> Self {
        self.wait_semaphore_value_count = wait_semaphore_values.len() as _;
        self.p_wait_semaphore_values = wait_semaphore_values.as_ptr();
        self
    }
    #[inline]
    pub fn signal_semaphore_values(mut self, signal_semaphore_values: &'a [u64]) -> Self {
        self.signal_semaphore_value_count = signal_semaphore_values.len() as _;
        self.p_signal_semaphore_values = signal_semaphore_values.as_ptr();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSemaphoreWaitInfo.html>"]
pub struct SemaphoreWaitInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: SemaphoreWaitFlags,
    pub semaphore_count: u32,
    pub p_semaphores: *const Semaphore,
    pub p_values: *const u64,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for SemaphoreWaitInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: SemaphoreWaitFlags::default(),
            semaphore_count: u32::default(),
            p_semaphores: ::std::ptr::null(),
            p_values: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for SemaphoreWaitInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::SEMAPHORE_WAIT_INFO;
}
impl<'a> SemaphoreWaitInfo<'a> {
    #[inline]
    pub fn flags(mut self, flags: SemaphoreWaitFlags) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn semaphores(mut self, semaphores: &'a [Semaphore]) -> Self {
        self.semaphore_count = semaphores.len() as _;
        self.p_semaphores = semaphores.as_ptr();
        self
    }
    #[inline]
    pub fn values(mut self, values: &'a [u64]) -> Self {
        self.semaphore_count = values.len() as _;
        self.p_values = values.as_ptr();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSemaphoreSignalInfo.html>"]
pub struct SemaphoreSignalInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub semaphore: Semaphore,
    pub value: u64,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for SemaphoreSignalInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            semaphore: Semaphore::default(),
            value: u64::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for SemaphoreSignalInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::SEMAPHORE_SIGNAL_INFO;
}
impl<'a> SemaphoreSignalInfo<'a> {
    #[inline]
    pub fn semaphore(mut self, semaphore: Semaphore) -> Self {
        self.semaphore = semaphore;
        self
    }
    #[inline]
    pub fn value(mut self, value: u64) -> Self {
        self.value = value;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVertexInputBindingDivisorDescriptionEXT.html>"]
pub struct VertexInputBindingDivisorDescriptionEXT {
    pub binding: u32,
    pub divisor: u32,
}
impl VertexInputBindingDivisorDescriptionEXT {
    #[inline]
    pub fn binding(mut self, binding: u32) -> Self {
        self.binding = binding;
        self
    }
    #[inline]
    pub fn divisor(mut self, divisor: u32) -> Self {
        self.divisor = divisor;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineVertexInputDivisorStateCreateInfoEXT.html>"]
pub struct PipelineVertexInputDivisorStateCreateInfoEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub vertex_binding_divisor_count: u32,
    pub p_vertex_binding_divisors: *const VertexInputBindingDivisorDescriptionEXT,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PipelineVertexInputDivisorStateCreateInfoEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            vertex_binding_divisor_count: u32::default(),
            p_vertex_binding_divisors: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PipelineVertexInputDivisorStateCreateInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT;
}
unsafe impl ExtendsPipelineVertexInputStateCreateInfo
    for PipelineVertexInputDivisorStateCreateInfoEXT<'_>
{
}
impl<'a> PipelineVertexInputDivisorStateCreateInfoEXT<'a> {
    #[inline]
    pub fn vertex_binding_divisors(
        mut self,
        vertex_binding_divisors: &'a [VertexInputBindingDivisorDescriptionEXT],
    ) -> Self {
        self.vertex_binding_divisor_count = vertex_binding_divisors.len() as _;
        self.p_vertex_binding_divisors = vertex_binding_divisors.as_ptr();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT.html>"]
pub struct PhysicalDeviceVertexAttributeDivisorPropertiesEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub max_vertex_attrib_divisor: u32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceVertexAttributeDivisorPropertiesEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            max_vertex_attrib_divisor: u32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceVertexAttributeDivisorPropertiesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT;
}
unsafe impl ExtendsPhysicalDeviceProperties2
    for PhysicalDeviceVertexAttributeDivisorPropertiesEXT<'_>
{
}
impl<'a> PhysicalDeviceVertexAttributeDivisorPropertiesEXT<'a> {
    #[inline]
    pub fn max_vertex_attrib_divisor(mut self, max_vertex_attrib_divisor: u32) -> Self {
        self.max_vertex_attrib_divisor = max_vertex_attrib_divisor;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePCIBusInfoPropertiesEXT.html>"]
pub struct PhysicalDevicePCIBusInfoPropertiesEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub pci_domain: u32,
    pub pci_bus: u32,
    pub pci_device: u32,
    pub pci_function: u32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDevicePCIBusInfoPropertiesEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            pci_domain: u32::default(),
            pci_bus: u32::default(),
            pci_device: u32::default(),
            pci_function: u32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDevicePCIBusInfoPropertiesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT;
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDevicePCIBusInfoPropertiesEXT<'_> {}
impl<'a> PhysicalDevicePCIBusInfoPropertiesEXT<'a> {
    #[inline]
    pub fn pci_domain(mut self, pci_domain: u32) -> Self {
        self.pci_domain = pci_domain;
        self
    }
    #[inline]
    pub fn pci_bus(mut self, pci_bus: u32) -> Self {
        self.pci_bus = pci_bus;
        self
    }
    #[inline]
    pub fn pci_device(mut self, pci_device: u32) -> Self {
        self.pci_device = pci_device;
        self
    }
    #[inline]
    pub fn pci_function(mut self, pci_function: u32) -> Self {
        self.pci_function = pci_function;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImportAndroidHardwareBufferInfoANDROID.html>"]
pub struct ImportAndroidHardwareBufferInfoANDROID<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub buffer: *mut AHardwareBuffer,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for ImportAndroidHardwareBufferInfoANDROID<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            buffer: ::std::ptr::null_mut(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for ImportAndroidHardwareBufferInfoANDROID<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID;
}
unsafe impl ExtendsMemoryAllocateInfo for ImportAndroidHardwareBufferInfoANDROID<'_> {}
impl<'a> ImportAndroidHardwareBufferInfoANDROID<'a> {
    #[inline]
    pub fn buffer(mut self, buffer: *mut AHardwareBuffer) -> Self {
        self.buffer = buffer;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAndroidHardwareBufferUsageANDROID.html>"]
pub struct AndroidHardwareBufferUsageANDROID<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub android_hardware_buffer_usage: u64,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for AndroidHardwareBufferUsageANDROID<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            android_hardware_buffer_usage: u64::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for AndroidHardwareBufferUsageANDROID<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ANDROID_HARDWARE_BUFFER_USAGE_ANDROID;
}
unsafe impl ExtendsImageFormatProperties2 for AndroidHardwareBufferUsageANDROID<'_> {}
impl<'a> AndroidHardwareBufferUsageANDROID<'a> {
    #[inline]
    pub fn android_hardware_buffer_usage(mut self, android_hardware_buffer_usage: u64) -> Self {
        self.android_hardware_buffer_usage = android_hardware_buffer_usage;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAndroidHardwareBufferPropertiesANDROID.html>"]
pub struct AndroidHardwareBufferPropertiesANDROID<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub allocation_size: DeviceSize,
    pub memory_type_bits: u32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for AndroidHardwareBufferPropertiesANDROID<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            allocation_size: DeviceSize::default(),
            memory_type_bits: u32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for AndroidHardwareBufferPropertiesANDROID<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID;
}
pub unsafe trait ExtendsAndroidHardwareBufferPropertiesANDROID {}
impl<'a> AndroidHardwareBufferPropertiesANDROID<'a> {
    #[inline]
    pub fn allocation_size(mut self, allocation_size: DeviceSize) -> Self {
        self.allocation_size = allocation_size;
        self
    }
    #[inline]
    pub fn memory_type_bits(mut self, memory_type_bits: u32) -> Self {
        self.memory_type_bits = memory_type_bits;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `x.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsAndroidHardwareBufferPropertiesANDROID>(
        mut self,
        next: &'a mut T,
    ) -> Self {
        unsafe {
            let next_ptr = <*mut T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.p_next as _;
            self.p_next = next_ptr;
        }
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryGetAndroidHardwareBufferInfoANDROID.html>"]
pub struct MemoryGetAndroidHardwareBufferInfoANDROID<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub memory: DeviceMemory,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for MemoryGetAndroidHardwareBufferInfoANDROID<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            memory: DeviceMemory::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for MemoryGetAndroidHardwareBufferInfoANDROID<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID;
}
impl<'a> MemoryGetAndroidHardwareBufferInfoANDROID<'a> {
    #[inline]
    pub fn memory(mut self, memory: DeviceMemory) -> Self {
        self.memory = memory;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAndroidHardwareBufferFormatPropertiesANDROID.html>"]
pub struct AndroidHardwareBufferFormatPropertiesANDROID<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub format: Format,
    pub external_format: u64,
    pub format_features: FormatFeatureFlags,
    pub sampler_ycbcr_conversion_components: ComponentMapping,
    pub suggested_ycbcr_model: SamplerYcbcrModelConversion,
    pub suggested_ycbcr_range: SamplerYcbcrRange,
    pub suggested_x_chroma_offset: ChromaLocation,
    pub suggested_y_chroma_offset: ChromaLocation,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for AndroidHardwareBufferFormatPropertiesANDROID<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            format: Format::default(),
            external_format: u64::default(),
            format_features: FormatFeatureFlags::default(),
            sampler_ycbcr_conversion_components: ComponentMapping::default(),
            suggested_ycbcr_model: SamplerYcbcrModelConversion::default(),
            suggested_ycbcr_range: SamplerYcbcrRange::default(),
            suggested_x_chroma_offset: ChromaLocation::default(),
            suggested_y_chroma_offset: ChromaLocation::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for AndroidHardwareBufferFormatPropertiesANDROID<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID;
}
unsafe impl ExtendsAndroidHardwareBufferPropertiesANDROID
    for AndroidHardwareBufferFormatPropertiesANDROID<'_>
{
}
impl<'a> AndroidHardwareBufferFormatPropertiesANDROID<'a> {
    #[inline]
    pub fn format(mut self, format: Format) -> Self {
        self.format = format;
        self
    }
    #[inline]
    pub fn external_format(mut self, external_format: u64) -> Self {
        self.external_format = external_format;
        self
    }
    #[inline]
    pub fn format_features(mut self, format_features: FormatFeatureFlags) -> Self {
        self.format_features = format_features;
        self
    }
    #[inline]
    pub fn sampler_ycbcr_conversion_components(
        mut self,
        sampler_ycbcr_conversion_components: ComponentMapping,
    ) -> Self {
        self.sampler_ycbcr_conversion_components = sampler_ycbcr_conversion_components;
        self
    }
    #[inline]
    pub fn suggested_ycbcr_model(
        mut self,
        suggested_ycbcr_model: SamplerYcbcrModelConversion,
    ) -> Self {
        self.suggested_ycbcr_model = suggested_ycbcr_model;
        self
    }
    #[inline]
    pub fn suggested_ycbcr_range(mut self, suggested_ycbcr_range: SamplerYcbcrRange) -> Self {
        self.suggested_ycbcr_range = suggested_ycbcr_range;
        self
    }
    #[inline]
    pub fn suggested_x_chroma_offset(mut self, suggested_x_chroma_offset: ChromaLocation) -> Self {
        self.suggested_x_chroma_offset = suggested_x_chroma_offset;
        self
    }
    #[inline]
    pub fn suggested_y_chroma_offset(mut self, suggested_y_chroma_offset: ChromaLocation) -> Self {
        self.suggested_y_chroma_offset = suggested_y_chroma_offset;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandBufferInheritanceConditionalRenderingInfoEXT.html>"]
pub struct CommandBufferInheritanceConditionalRenderingInfoEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub conditional_rendering_enable: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for CommandBufferInheritanceConditionalRenderingInfoEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            conditional_rendering_enable: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for CommandBufferInheritanceConditionalRenderingInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT;
}
unsafe impl ExtendsCommandBufferInheritanceInfo
    for CommandBufferInheritanceConditionalRenderingInfoEXT<'_>
{
}
impl<'a> CommandBufferInheritanceConditionalRenderingInfoEXT<'a> {
    #[inline]
    pub fn conditional_rendering_enable(mut self, conditional_rendering_enable: bool) -> Self {
        self.conditional_rendering_enable = conditional_rendering_enable.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExternalFormatANDROID.html>"]
pub struct ExternalFormatANDROID<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub external_format: u64,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for ExternalFormatANDROID<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            external_format: u64::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for ExternalFormatANDROID<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::EXTERNAL_FORMAT_ANDROID;
}
unsafe impl ExtendsImageCreateInfo for ExternalFormatANDROID<'_> {}
unsafe impl ExtendsSamplerYcbcrConversionCreateInfo for ExternalFormatANDROID<'_> {}
impl<'a> ExternalFormatANDROID<'a> {
    #[inline]
    pub fn external_format(mut self, external_format: u64) -> Self {
        self.external_format = external_format;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevice8BitStorageFeatures.html>"]
pub struct PhysicalDevice8BitStorageFeatures<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub storage_buffer8_bit_access: Bool32,
    pub uniform_and_storage_buffer8_bit_access: Bool32,
    pub storage_push_constant8: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDevice8BitStorageFeatures<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            storage_buffer8_bit_access: Bool32::default(),
            uniform_and_storage_buffer8_bit_access: Bool32::default(),
            storage_push_constant8: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDevice8BitStorageFeatures<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES;
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDevice8BitStorageFeatures<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDevice8BitStorageFeatures<'_> {}
impl<'a> PhysicalDevice8BitStorageFeatures<'a> {
    #[inline]
    pub fn storage_buffer8_bit_access(mut self, storage_buffer8_bit_access: bool) -> Self {
        self.storage_buffer8_bit_access = storage_buffer8_bit_access.into();
        self
    }
    #[inline]
    pub fn uniform_and_storage_buffer8_bit_access(
        mut self,
        uniform_and_storage_buffer8_bit_access: bool,
    ) -> Self {
        self.uniform_and_storage_buffer8_bit_access = uniform_and_storage_buffer8_bit_access.into();
        self
    }
    #[inline]
    pub fn storage_push_constant8(mut self, storage_push_constant8: bool) -> Self {
        self.storage_push_constant8 = storage_push_constant8.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceConditionalRenderingFeaturesEXT.html>"]
pub struct PhysicalDeviceConditionalRenderingFeaturesEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub conditional_rendering: Bool32,
    pub inherited_conditional_rendering: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceConditionalRenderingFeaturesEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            conditional_rendering: Bool32::default(),
            inherited_conditional_rendering: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceConditionalRenderingFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT;
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceConditionalRenderingFeaturesEXT<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceConditionalRenderingFeaturesEXT<'_> {}
impl<'a> PhysicalDeviceConditionalRenderingFeaturesEXT<'a> {
    #[inline]
    pub fn conditional_rendering(mut self, conditional_rendering: bool) -> Self {
        self.conditional_rendering = conditional_rendering.into();
        self
    }
    #[inline]
    pub fn inherited_conditional_rendering(
        mut self,
        inherited_conditional_rendering: bool,
    ) -> Self {
        self.inherited_conditional_rendering = inherited_conditional_rendering.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkanMemoryModelFeatures.html>"]
pub struct PhysicalDeviceVulkanMemoryModelFeatures<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub vulkan_memory_model: Bool32,
    pub vulkan_memory_model_device_scope: Bool32,
    pub vulkan_memory_model_availability_visibility_chains: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceVulkanMemoryModelFeatures<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            vulkan_memory_model: Bool32::default(),
            vulkan_memory_model_device_scope: Bool32::default(),
            vulkan_memory_model_availability_visibility_chains: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceVulkanMemoryModelFeatures<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES;
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceVulkanMemoryModelFeatures<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceVulkanMemoryModelFeatures<'_> {}
impl<'a> PhysicalDeviceVulkanMemoryModelFeatures<'a> {
    #[inline]
    pub fn vulkan_memory_model(mut self, vulkan_memory_model: bool) -> Self {
        self.vulkan_memory_model = vulkan_memory_model.into();
        self
    }
    #[inline]
    pub fn vulkan_memory_model_device_scope(
        mut self,
        vulkan_memory_model_device_scope: bool,
    ) -> Self {
        self.vulkan_memory_model_device_scope = vulkan_memory_model_device_scope.into();
        self
    }
    #[inline]
    pub fn vulkan_memory_model_availability_visibility_chains(
        mut self,
        vulkan_memory_model_availability_visibility_chains: bool,
    ) -> Self {
        self.vulkan_memory_model_availability_visibility_chains =
            vulkan_memory_model_availability_visibility_chains.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderAtomicInt64Features.html>"]
pub struct PhysicalDeviceShaderAtomicInt64Features<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shader_buffer_int64_atomics: Bool32,
    pub shader_shared_int64_atomics: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceShaderAtomicInt64Features<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            shader_buffer_int64_atomics: Bool32::default(),
            shader_shared_int64_atomics: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceShaderAtomicInt64Features<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES;
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceShaderAtomicInt64Features<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceShaderAtomicInt64Features<'_> {}
impl<'a> PhysicalDeviceShaderAtomicInt64Features<'a> {
    #[inline]
    pub fn shader_buffer_int64_atomics(mut self, shader_buffer_int64_atomics: bool) -> Self {
        self.shader_buffer_int64_atomics = shader_buffer_int64_atomics.into();
        self
    }
    #[inline]
    pub fn shader_shared_int64_atomics(mut self, shader_shared_int64_atomics: bool) -> Self {
        self.shader_shared_int64_atomics = shader_shared_int64_atomics.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderAtomicFloatFeaturesEXT.html>"]
pub struct PhysicalDeviceShaderAtomicFloatFeaturesEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shader_buffer_float32_atomics: Bool32,
    pub shader_buffer_float32_atomic_add: Bool32,
    pub shader_buffer_float64_atomics: Bool32,
    pub shader_buffer_float64_atomic_add: Bool32,
    pub shader_shared_float32_atomics: Bool32,
    pub shader_shared_float32_atomic_add: Bool32,
    pub shader_shared_float64_atomics: Bool32,
    pub shader_shared_float64_atomic_add: Bool32,
    pub shader_image_float32_atomics: Bool32,
    pub shader_image_float32_atomic_add: Bool32,
    pub sparse_image_float32_atomics: Bool32,
    pub sparse_image_float32_atomic_add: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceShaderAtomicFloatFeaturesEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            shader_buffer_float32_atomics: Bool32::default(),
            shader_buffer_float32_atomic_add: Bool32::default(),
            shader_buffer_float64_atomics: Bool32::default(),
            shader_buffer_float64_atomic_add: Bool32::default(),
            shader_shared_float32_atomics: Bool32::default(),
            shader_shared_float32_atomic_add: Bool32::default(),
            shader_shared_float64_atomics: Bool32::default(),
            shader_shared_float64_atomic_add: Bool32::default(),
            shader_image_float32_atomics: Bool32::default(),
            shader_image_float32_atomic_add: Bool32::default(),
            sparse_image_float32_atomics: Bool32::default(),
            sparse_image_float32_atomic_add: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceShaderAtomicFloatFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT;
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceShaderAtomicFloatFeaturesEXT<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceShaderAtomicFloatFeaturesEXT<'_> {}
impl<'a> PhysicalDeviceShaderAtomicFloatFeaturesEXT<'a> {
    #[inline]
    pub fn shader_buffer_float32_atomics(mut self, shader_buffer_float32_atomics: bool) -> Self {
        self.shader_buffer_float32_atomics = shader_buffer_float32_atomics.into();
        self
    }
    #[inline]
    pub fn shader_buffer_float32_atomic_add(
        mut self,
        shader_buffer_float32_atomic_add: bool,
    ) -> Self {
        self.shader_buffer_float32_atomic_add = shader_buffer_float32_atomic_add.into();
        self
    }
    #[inline]
    pub fn shader_buffer_float64_atomics(mut self, shader_buffer_float64_atomics: bool) -> Self {
        self.shader_buffer_float64_atomics = shader_buffer_float64_atomics.into();
        self
    }
    #[inline]
    pub fn shader_buffer_float64_atomic_add(
        mut self,
        shader_buffer_float64_atomic_add: bool,
    ) -> Self {
        self.shader_buffer_float64_atomic_add = shader_buffer_float64_atomic_add.into();
        self
    }
    #[inline]
    pub fn shader_shared_float32_atomics(mut self, shader_shared_float32_atomics: bool) -> Self {
        self.shader_shared_float32_atomics = shader_shared_float32_atomics.into();
        self
    }
    #[inline]
    pub fn shader_shared_float32_atomic_add(
        mut self,
        shader_shared_float32_atomic_add: bool,
    ) -> Self {
        self.shader_shared_float32_atomic_add = shader_shared_float32_atomic_add.into();
        self
    }
    #[inline]
    pub fn shader_shared_float64_atomics(mut self, shader_shared_float64_atomics: bool) -> Self {
        self.shader_shared_float64_atomics = shader_shared_float64_atomics.into();
        self
    }
    #[inline]
    pub fn shader_shared_float64_atomic_add(
        mut self,
        shader_shared_float64_atomic_add: bool,
    ) -> Self {
        self.shader_shared_float64_atomic_add = shader_shared_float64_atomic_add.into();
        self
    }
    #[inline]
    pub fn shader_image_float32_atomics(mut self, shader_image_float32_atomics: bool) -> Self {
        self.shader_image_float32_atomics = shader_image_float32_atomics.into();
        self
    }
    #[inline]
    pub fn shader_image_float32_atomic_add(
        mut self,
        shader_image_float32_atomic_add: bool,
    ) -> Self {
        self.shader_image_float32_atomic_add = shader_image_float32_atomic_add.into();
        self
    }
    #[inline]
    pub fn sparse_image_float32_atomics(mut self, sparse_image_float32_atomics: bool) -> Self {
        self.sparse_image_float32_atomics = sparse_image_float32_atomics.into();
        self
    }
    #[inline]
    pub fn sparse_image_float32_atomic_add(
        mut self,
        sparse_image_float32_atomic_add: bool,
    ) -> Self {
        self.sparse_image_float32_atomic_add = sparse_image_float32_atomic_add.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT.html>"]
pub struct PhysicalDeviceShaderAtomicFloat2FeaturesEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shader_buffer_float16_atomics: Bool32,
    pub shader_buffer_float16_atomic_add: Bool32,
    pub shader_buffer_float16_atomic_min_max: Bool32,
    pub shader_buffer_float32_atomic_min_max: Bool32,
    pub shader_buffer_float64_atomic_min_max: Bool32,
    pub shader_shared_float16_atomics: Bool32,
    pub shader_shared_float16_atomic_add: Bool32,
    pub shader_shared_float16_atomic_min_max: Bool32,
    pub shader_shared_float32_atomic_min_max: Bool32,
    pub shader_shared_float64_atomic_min_max: Bool32,
    pub shader_image_float32_atomic_min_max: Bool32,
    pub sparse_image_float32_atomic_min_max: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceShaderAtomicFloat2FeaturesEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            shader_buffer_float16_atomics: Bool32::default(),
            shader_buffer_float16_atomic_add: Bool32::default(),
            shader_buffer_float16_atomic_min_max: Bool32::default(),
            shader_buffer_float32_atomic_min_max: Bool32::default(),
            shader_buffer_float64_atomic_min_max: Bool32::default(),
            shader_shared_float16_atomics: Bool32::default(),
            shader_shared_float16_atomic_add: Bool32::default(),
            shader_shared_float16_atomic_min_max: Bool32::default(),
            shader_shared_float32_atomic_min_max: Bool32::default(),
            shader_shared_float64_atomic_min_max: Bool32::default(),
            shader_image_float32_atomic_min_max: Bool32::default(),
            sparse_image_float32_atomic_min_max: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceShaderAtomicFloat2FeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT;
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceShaderAtomicFloat2FeaturesEXT<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceShaderAtomicFloat2FeaturesEXT<'_> {}
impl<'a> PhysicalDeviceShaderAtomicFloat2FeaturesEXT<'a> {
    #[inline]
    pub fn shader_buffer_float16_atomics(mut self, shader_buffer_float16_atomics: bool) -> Self {
        self.shader_buffer_float16_atomics = shader_buffer_float16_atomics.into();
        self
    }
    #[inline]
    pub fn shader_buffer_float16_atomic_add(
        mut self,
        shader_buffer_float16_atomic_add: bool,
    ) -> Self {
        self.shader_buffer_float16_atomic_add = shader_buffer_float16_atomic_add.into();
        self
    }
    #[inline]
    pub fn shader_buffer_float16_atomic_min_max(
        mut self,
        shader_buffer_float16_atomic_min_max: bool,
    ) -> Self {
        self.shader_buffer_float16_atomic_min_max = shader_buffer_float16_atomic_min_max.into();
        self
    }
    #[inline]
    pub fn shader_buffer_float32_atomic_min_max(
        mut self,
        shader_buffer_float32_atomic_min_max: bool,
    ) -> Self {
        self.shader_buffer_float32_atomic_min_max = shader_buffer_float32_atomic_min_max.into();
        self
    }
    #[inline]
    pub fn shader_buffer_float64_atomic_min_max(
        mut self,
        shader_buffer_float64_atomic_min_max: bool,
    ) -> Self {
        self.shader_buffer_float64_atomic_min_max = shader_buffer_float64_atomic_min_max.into();
        self
    }
    #[inline]
    pub fn shader_shared_float16_atomics(mut self, shader_shared_float16_atomics: bool) -> Self {
        self.shader_shared_float16_atomics = shader_shared_float16_atomics.into();
        self
    }
    #[inline]
    pub fn shader_shared_float16_atomic_add(
        mut self,
        shader_shared_float16_atomic_add: bool,
    ) -> Self {
        self.shader_shared_float16_atomic_add = shader_shared_float16_atomic_add.into();
        self
    }
    #[inline]
    pub fn shader_shared_float16_atomic_min_max(
        mut self,
        shader_shared_float16_atomic_min_max: bool,
    ) -> Self {
        self.shader_shared_float16_atomic_min_max = shader_shared_float16_atomic_min_max.into();
        self
    }
    #[inline]
    pub fn shader_shared_float32_atomic_min_max(
        mut self,
        shader_shared_float32_atomic_min_max: bool,
    ) -> Self {
        self.shader_shared_float32_atomic_min_max = shader_shared_float32_atomic_min_max.into();
        self
    }
    #[inline]
    pub fn shader_shared_float64_atomic_min_max(
        mut self,
        shader_shared_float64_atomic_min_max: bool,
    ) -> Self {
        self.shader_shared_float64_atomic_min_max = shader_shared_float64_atomic_min_max.into();
        self
    }
    #[inline]
    pub fn shader_image_float32_atomic_min_max(
        mut self,
        shader_image_float32_atomic_min_max: bool,
    ) -> Self {
        self.shader_image_float32_atomic_min_max = shader_image_float32_atomic_min_max.into();
        self
    }
    #[inline]
    pub fn sparse_image_float32_atomic_min_max(
        mut self,
        sparse_image_float32_atomic_min_max: bool,
    ) -> Self {
        self.sparse_image_float32_atomic_min_max = sparse_image_float32_atomic_min_max.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT.html>"]
pub struct PhysicalDeviceVertexAttributeDivisorFeaturesEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub vertex_attribute_instance_rate_divisor: Bool32,
    pub vertex_attribute_instance_rate_zero_divisor: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceVertexAttributeDivisorFeaturesEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            vertex_attribute_instance_rate_divisor: Bool32::default(),
            vertex_attribute_instance_rate_zero_divisor: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceVertexAttributeDivisorFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT;
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceVertexAttributeDivisorFeaturesEXT<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceVertexAttributeDivisorFeaturesEXT<'_> {}
impl<'a> PhysicalDeviceVertexAttributeDivisorFeaturesEXT<'a> {
    #[inline]
    pub fn vertex_attribute_instance_rate_divisor(
        mut self,
        vertex_attribute_instance_rate_divisor: bool,
    ) -> Self {
        self.vertex_attribute_instance_rate_divisor = vertex_attribute_instance_rate_divisor.into();
        self
    }
    #[inline]
    pub fn vertex_attribute_instance_rate_zero_divisor(
        mut self,
        vertex_attribute_instance_rate_zero_divisor: bool,
    ) -> Self {
        self.vertex_attribute_instance_rate_zero_divisor =
            vertex_attribute_instance_rate_zero_divisor.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkQueueFamilyCheckpointPropertiesNV.html>"]
pub struct QueueFamilyCheckpointPropertiesNV<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub checkpoint_execution_stage_mask: PipelineStageFlags,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for QueueFamilyCheckpointPropertiesNV<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            checkpoint_execution_stage_mask: PipelineStageFlags::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for QueueFamilyCheckpointPropertiesNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV;
}
unsafe impl ExtendsQueueFamilyProperties2 for QueueFamilyCheckpointPropertiesNV<'_> {}
impl<'a> QueueFamilyCheckpointPropertiesNV<'a> {
    #[inline]
    pub fn checkpoint_execution_stage_mask(
        mut self,
        checkpoint_execution_stage_mask: PipelineStageFlags,
    ) -> Self {
        self.checkpoint_execution_stage_mask = checkpoint_execution_stage_mask;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCheckpointDataNV.html>"]
pub struct CheckpointDataNV<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub stage: PipelineStageFlags,
    pub p_checkpoint_marker: *mut c_void,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for CheckpointDataNV<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            stage: PipelineStageFlags::default(),
            p_checkpoint_marker: ::std::ptr::null_mut(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for CheckpointDataNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::CHECKPOINT_DATA_NV;
}
impl<'a> CheckpointDataNV<'a> {
    #[inline]
    pub fn stage(mut self, stage: PipelineStageFlags) -> Self {
        self.stage = stage;
        self
    }
    #[inline]
    pub fn checkpoint_marker(mut self, checkpoint_marker: *mut c_void) -> Self {
        self.p_checkpoint_marker = checkpoint_marker;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDepthStencilResolveProperties.html>"]
pub struct PhysicalDeviceDepthStencilResolveProperties<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub supported_depth_resolve_modes: ResolveModeFlags,
    pub supported_stencil_resolve_modes: ResolveModeFlags,
    pub independent_resolve_none: Bool32,
    pub independent_resolve: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceDepthStencilResolveProperties<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            supported_depth_resolve_modes: ResolveModeFlags::default(),
            supported_stencil_resolve_modes: ResolveModeFlags::default(),
            independent_resolve_none: Bool32::default(),
            independent_resolve: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceDepthStencilResolveProperties<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES;
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceDepthStencilResolveProperties<'_> {}
impl<'a> PhysicalDeviceDepthStencilResolveProperties<'a> {
    #[inline]
    pub fn supported_depth_resolve_modes(
        mut self,
        supported_depth_resolve_modes: ResolveModeFlags,
    ) -> Self {
        self.supported_depth_resolve_modes = supported_depth_resolve_modes;
        self
    }
    #[inline]
    pub fn supported_stencil_resolve_modes(
        mut self,
        supported_stencil_resolve_modes: ResolveModeFlags,
    ) -> Self {
        self.supported_stencil_resolve_modes = supported_stencil_resolve_modes;
        self
    }
    #[inline]
    pub fn independent_resolve_none(mut self, independent_resolve_none: bool) -> Self {
        self.independent_resolve_none = independent_resolve_none.into();
        self
    }
    #[inline]
    pub fn independent_resolve(mut self, independent_resolve: bool) -> Self {
        self.independent_resolve = independent_resolve.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSubpassDescriptionDepthStencilResolve.html>"]
pub struct SubpassDescriptionDepthStencilResolve<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub depth_resolve_mode: ResolveModeFlags,
    pub stencil_resolve_mode: ResolveModeFlags,
    pub p_depth_stencil_resolve_attachment: *const AttachmentReference2<'a>,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for SubpassDescriptionDepthStencilResolve<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            depth_resolve_mode: ResolveModeFlags::default(),
            stencil_resolve_mode: ResolveModeFlags::default(),
            p_depth_stencil_resolve_attachment: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for SubpassDescriptionDepthStencilResolve<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE;
}
unsafe impl ExtendsSubpassDescription2 for SubpassDescriptionDepthStencilResolve<'_> {}
impl<'a> SubpassDescriptionDepthStencilResolve<'a> {
    #[inline]
    pub fn depth_resolve_mode(mut self, depth_resolve_mode: ResolveModeFlags) -> Self {
        self.depth_resolve_mode = depth_resolve_mode;
        self
    }
    #[inline]
    pub fn stencil_resolve_mode(mut self, stencil_resolve_mode: ResolveModeFlags) -> Self {
        self.stencil_resolve_mode = stencil_resolve_mode;
        self
    }
    #[inline]
    pub fn depth_stencil_resolve_attachment(
        mut self,
        depth_stencil_resolve_attachment: &'a AttachmentReference2<'a>,
    ) -> Self {
        self.p_depth_stencil_resolve_attachment = depth_stencil_resolve_attachment;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageViewASTCDecodeModeEXT.html>"]
pub struct ImageViewASTCDecodeModeEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub decode_mode: Format,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for ImageViewASTCDecodeModeEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            decode_mode: Format::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for ImageViewASTCDecodeModeEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::IMAGE_VIEW_ASTC_DECODE_MODE_EXT;
}
unsafe impl ExtendsImageViewCreateInfo for ImageViewASTCDecodeModeEXT<'_> {}
impl<'a> ImageViewASTCDecodeModeEXT<'a> {
    #[inline]
    pub fn decode_mode(mut self, decode_mode: Format) -> Self {
        self.decode_mode = decode_mode;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceASTCDecodeFeaturesEXT.html>"]
pub struct PhysicalDeviceASTCDecodeFeaturesEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub decode_mode_shared_exponent: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceASTCDecodeFeaturesEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            decode_mode_shared_exponent: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceASTCDecodeFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT;
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceASTCDecodeFeaturesEXT<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceASTCDecodeFeaturesEXT<'_> {}
impl<'a> PhysicalDeviceASTCDecodeFeaturesEXT<'a> {
    #[inline]
    pub fn decode_mode_shared_exponent(mut self, decode_mode_shared_exponent: bool) -> Self {
        self.decode_mode_shared_exponent = decode_mode_shared_exponent.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceTransformFeedbackFeaturesEXT.html>"]
pub struct PhysicalDeviceTransformFeedbackFeaturesEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub transform_feedback: Bool32,
    pub geometry_streams: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceTransformFeedbackFeaturesEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            transform_feedback: Bool32::default(),
            geometry_streams: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceTransformFeedbackFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT;
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceTransformFeedbackFeaturesEXT<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceTransformFeedbackFeaturesEXT<'_> {}
impl<'a> PhysicalDeviceTransformFeedbackFeaturesEXT<'a> {
    #[inline]
    pub fn transform_feedback(mut self, transform_feedback: bool) -> Self {
        self.transform_feedback = transform_feedback.into();
        self
    }
    #[inline]
    pub fn geometry_streams(mut self, geometry_streams: bool) -> Self {
        self.geometry_streams = geometry_streams.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceTransformFeedbackPropertiesEXT.html>"]
pub struct PhysicalDeviceTransformFeedbackPropertiesEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub max_transform_feedback_streams: u32,
    pub max_transform_feedback_buffers: u32,
    pub max_transform_feedback_buffer_size: DeviceSize,
    pub max_transform_feedback_stream_data_size: u32,
    pub max_transform_feedback_buffer_data_size: u32,
    pub max_transform_feedback_buffer_data_stride: u32,
    pub transform_feedback_queries: Bool32,
    pub transform_feedback_streams_lines_triangles: Bool32,
    pub transform_feedback_rasterization_stream_select: Bool32,
    pub transform_feedback_draw: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceTransformFeedbackPropertiesEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            max_transform_feedback_streams: u32::default(),
            max_transform_feedback_buffers: u32::default(),
            max_transform_feedback_buffer_size: DeviceSize::default(),
            max_transform_feedback_stream_data_size: u32::default(),
            max_transform_feedback_buffer_data_size: u32::default(),
            max_transform_feedback_buffer_data_stride: u32::default(),
            transform_feedback_queries: Bool32::default(),
            transform_feedback_streams_lines_triangles: Bool32::default(),
            transform_feedback_rasterization_stream_select: Bool32::default(),
            transform_feedback_draw: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceTransformFeedbackPropertiesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT;
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceTransformFeedbackPropertiesEXT<'_> {}
impl<'a> PhysicalDeviceTransformFeedbackPropertiesEXT<'a> {
    #[inline]
    pub fn max_transform_feedback_streams(mut self, max_transform_feedback_streams: u32) -> Self {
        self.max_transform_feedback_streams = max_transform_feedback_streams;
        self
    }
    #[inline]
    pub fn max_transform_feedback_buffers(mut self, max_transform_feedback_buffers: u32) -> Self {
        self.max_transform_feedback_buffers = max_transform_feedback_buffers;
        self
    }
    #[inline]
    pub fn max_transform_feedback_buffer_size(
        mut self,
        max_transform_feedback_buffer_size: DeviceSize,
    ) -> Self {
        self.max_transform_feedback_buffer_size = max_transform_feedback_buffer_size;
        self
    }
    #[inline]
    pub fn max_transform_feedback_stream_data_size(
        mut self,
        max_transform_feedback_stream_data_size: u32,
    ) -> Self {
        self.max_transform_feedback_stream_data_size = max_transform_feedback_stream_data_size;
        self
    }
    #[inline]
    pub fn max_transform_feedback_buffer_data_size(
        mut self,
        max_transform_feedback_buffer_data_size: u32,
    ) -> Self {
        self.max_transform_feedback_buffer_data_size = max_transform_feedback_buffer_data_size;
        self
    }
    #[inline]
    pub fn max_transform_feedback_buffer_data_stride(
        mut self,
        max_transform_feedback_buffer_data_stride: u32,
    ) -> Self {
        self.max_transform_feedback_buffer_data_stride = max_transform_feedback_buffer_data_stride;
        self
    }
    #[inline]
    pub fn transform_feedback_queries(mut self, transform_feedback_queries: bool) -> Self {
        self.transform_feedback_queries = transform_feedback_queries.into();
        self
    }
    #[inline]
    pub fn transform_feedback_streams_lines_triangles(
        mut self,
        transform_feedback_streams_lines_triangles: bool,
    ) -> Self {
        self.transform_feedback_streams_lines_triangles =
            transform_feedback_streams_lines_triangles.into();
        self
    }
    #[inline]
    pub fn transform_feedback_rasterization_stream_select(
        mut self,
        transform_feedback_rasterization_stream_select: bool,
    ) -> Self {
        self.transform_feedback_rasterization_stream_select =
            transform_feedback_rasterization_stream_select.into();
        self
    }
    #[inline]
    pub fn transform_feedback_draw(mut self, transform_feedback_draw: bool) -> Self {
        self.transform_feedback_draw = transform_feedback_draw.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineRasterizationStateStreamCreateInfoEXT.html>"]
pub struct PipelineRasterizationStateStreamCreateInfoEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: PipelineRasterizationStateStreamCreateFlagsEXT,
    pub rasterization_stream: u32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PipelineRasterizationStateStreamCreateInfoEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: PipelineRasterizationStateStreamCreateFlagsEXT::default(),
            rasterization_stream: u32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PipelineRasterizationStateStreamCreateInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT;
}
unsafe impl ExtendsPipelineRasterizationStateCreateInfo
    for PipelineRasterizationStateStreamCreateInfoEXT<'_>
{
}
impl<'a> PipelineRasterizationStateStreamCreateInfoEXT<'a> {
    #[inline]
    pub fn flags(mut self, flags: PipelineRasterizationStateStreamCreateFlagsEXT) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn rasterization_stream(mut self, rasterization_stream: u32) -> Self {
        self.rasterization_stream = rasterization_stream;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV.html>"]
pub struct PhysicalDeviceRepresentativeFragmentTestFeaturesNV<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub representative_fragment_test: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceRepresentativeFragmentTestFeaturesNV<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            representative_fragment_test: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceRepresentativeFragmentTestFeaturesNV<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV;
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceRepresentativeFragmentTestFeaturesNV<'_>
{
}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceRepresentativeFragmentTestFeaturesNV<'_> {}
impl<'a> PhysicalDeviceRepresentativeFragmentTestFeaturesNV<'a> {
    #[inline]
    pub fn representative_fragment_test(mut self, representative_fragment_test: bool) -> Self {
        self.representative_fragment_test = representative_fragment_test.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineRepresentativeFragmentTestStateCreateInfoNV.html>"]
pub struct PipelineRepresentativeFragmentTestStateCreateInfoNV<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub representative_fragment_test_enable: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PipelineRepresentativeFragmentTestStateCreateInfoNV<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            representative_fragment_test_enable: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PipelineRepresentativeFragmentTestStateCreateInfoNV<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV;
}
unsafe impl ExtendsGraphicsPipelineCreateInfo
    for PipelineRepresentativeFragmentTestStateCreateInfoNV<'_>
{
}
impl<'a> PipelineRepresentativeFragmentTestStateCreateInfoNV<'a> {
    #[inline]
    pub fn representative_fragment_test_enable(
        mut self,
        representative_fragment_test_enable: bool,
    ) -> Self {
        self.representative_fragment_test_enable = representative_fragment_test_enable.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceExclusiveScissorFeaturesNV.html>"]
pub struct PhysicalDeviceExclusiveScissorFeaturesNV<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub exclusive_scissor: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceExclusiveScissorFeaturesNV<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            exclusive_scissor: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceExclusiveScissorFeaturesNV<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV;
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceExclusiveScissorFeaturesNV<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceExclusiveScissorFeaturesNV<'_> {}
impl<'a> PhysicalDeviceExclusiveScissorFeaturesNV<'a> {
    #[inline]
    pub fn exclusive_scissor(mut self, exclusive_scissor: bool) -> Self {
        self.exclusive_scissor = exclusive_scissor.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineViewportExclusiveScissorStateCreateInfoNV.html>"]
pub struct PipelineViewportExclusiveScissorStateCreateInfoNV<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub exclusive_scissor_count: u32,
    pub p_exclusive_scissors: *const Rect2D,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PipelineViewportExclusiveScissorStateCreateInfoNV<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            exclusive_scissor_count: u32::default(),
            p_exclusive_scissors: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PipelineViewportExclusiveScissorStateCreateInfoNV<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV;
}
unsafe impl ExtendsPipelineViewportStateCreateInfo
    for PipelineViewportExclusiveScissorStateCreateInfoNV<'_>
{
}
impl<'a> PipelineViewportExclusiveScissorStateCreateInfoNV<'a> {
    #[inline]
    pub fn exclusive_scissors(mut self, exclusive_scissors: &'a [Rect2D]) -> Self {
        self.exclusive_scissor_count = exclusive_scissors.len() as _;
        self.p_exclusive_scissors = exclusive_scissors.as_ptr();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceCornerSampledImageFeaturesNV.html>"]
pub struct PhysicalDeviceCornerSampledImageFeaturesNV<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub corner_sampled_image: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceCornerSampledImageFeaturesNV<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            corner_sampled_image: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceCornerSampledImageFeaturesNV<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV;
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceCornerSampledImageFeaturesNV<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceCornerSampledImageFeaturesNV<'_> {}
impl<'a> PhysicalDeviceCornerSampledImageFeaturesNV<'a> {
    #[inline]
    pub fn corner_sampled_image(mut self, corner_sampled_image: bool) -> Self {
        self.corner_sampled_image = corner_sampled_image.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceComputeShaderDerivativesFeaturesNV.html>"]
pub struct PhysicalDeviceComputeShaderDerivativesFeaturesNV<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub compute_derivative_group_quads: Bool32,
    pub compute_derivative_group_linear: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceComputeShaderDerivativesFeaturesNV<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            compute_derivative_group_quads: Bool32::default(),
            compute_derivative_group_linear: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceComputeShaderDerivativesFeaturesNV<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV;
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceComputeShaderDerivativesFeaturesNV<'_>
{
}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceComputeShaderDerivativesFeaturesNV<'_> {}
impl<'a> PhysicalDeviceComputeShaderDerivativesFeaturesNV<'a> {
    #[inline]
    pub fn compute_derivative_group_quads(mut self, compute_derivative_group_quads: bool) -> Self {
        self.compute_derivative_group_quads = compute_derivative_group_quads.into();
        self
    }
    #[inline]
    pub fn compute_derivative_group_linear(
        mut self,
        compute_derivative_group_linear: bool,
    ) -> Self {
        self.compute_derivative_group_linear = compute_derivative_group_linear.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderImageFootprintFeaturesNV.html>"]
pub struct PhysicalDeviceShaderImageFootprintFeaturesNV<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub image_footprint: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceShaderImageFootprintFeaturesNV<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            image_footprint: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceShaderImageFootprintFeaturesNV<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV;
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceShaderImageFootprintFeaturesNV<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceShaderImageFootprintFeaturesNV<'_> {}
impl<'a> PhysicalDeviceShaderImageFootprintFeaturesNV<'a> {
    #[inline]
    pub fn image_footprint(mut self, image_footprint: bool) -> Self {
        self.image_footprint = image_footprint.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV.html>"]
pub struct PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub dedicated_allocation_image_aliasing: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            dedicated_allocation_image_aliasing: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV;
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV<'_>
{
}
unsafe impl ExtendsDeviceCreateInfo
    for PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV<'_>
{
}
impl<'a> PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV<'a> {
    #[inline]
    pub fn dedicated_allocation_image_aliasing(
        mut self,
        dedicated_allocation_image_aliasing: bool,
    ) -> Self {
        self.dedicated_allocation_image_aliasing = dedicated_allocation_image_aliasing.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkShadingRatePaletteNV.html>"]
pub struct ShadingRatePaletteNV<'a> {
    pub shading_rate_palette_entry_count: u32,
    pub p_shading_rate_palette_entries: *const ShadingRatePaletteEntryNV,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for ShadingRatePaletteNV<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            shading_rate_palette_entry_count: u32::default(),
            p_shading_rate_palette_entries: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
impl<'a> ShadingRatePaletteNV<'a> {
    #[inline]
    pub fn shading_rate_palette_entries(
        mut self,
        shading_rate_palette_entries: &'a [ShadingRatePaletteEntryNV],
    ) -> Self {
        self.shading_rate_palette_entry_count = shading_rate_palette_entries.len() as _;
        self.p_shading_rate_palette_entries = shading_rate_palette_entries.as_ptr();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineViewportShadingRateImageStateCreateInfoNV.html>"]
pub struct PipelineViewportShadingRateImageStateCreateInfoNV<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub shading_rate_image_enable: Bool32,
    pub viewport_count: u32,
    pub p_shading_rate_palettes: *const ShadingRatePaletteNV<'a>,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PipelineViewportShadingRateImageStateCreateInfoNV<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            shading_rate_image_enable: Bool32::default(),
            viewport_count: u32::default(),
            p_shading_rate_palettes: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PipelineViewportShadingRateImageStateCreateInfoNV<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV;
}
unsafe impl ExtendsPipelineViewportStateCreateInfo
    for PipelineViewportShadingRateImageStateCreateInfoNV<'_>
{
}
impl<'a> PipelineViewportShadingRateImageStateCreateInfoNV<'a> {
    #[inline]
    pub fn shading_rate_image_enable(mut self, shading_rate_image_enable: bool) -> Self {
        self.shading_rate_image_enable = shading_rate_image_enable.into();
        self
    }
    #[inline]
    pub fn shading_rate_palettes(
        mut self,
        shading_rate_palettes: &'a [ShadingRatePaletteNV],
    ) -> Self {
        self.viewport_count = shading_rate_palettes.len() as _;
        self.p_shading_rate_palettes = shading_rate_palettes.as_ptr();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShadingRateImageFeaturesNV.html>"]
pub struct PhysicalDeviceShadingRateImageFeaturesNV<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shading_rate_image: Bool32,
    pub shading_rate_coarse_sample_order: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceShadingRateImageFeaturesNV<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            shading_rate_image: Bool32::default(),
            shading_rate_coarse_sample_order: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceShadingRateImageFeaturesNV<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV;
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceShadingRateImageFeaturesNV<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceShadingRateImageFeaturesNV<'_> {}
impl<'a> PhysicalDeviceShadingRateImageFeaturesNV<'a> {
    #[inline]
    pub fn shading_rate_image(mut self, shading_rate_image: bool) -> Self {
        self.shading_rate_image = shading_rate_image.into();
        self
    }
    #[inline]
    pub fn shading_rate_coarse_sample_order(
        mut self,
        shading_rate_coarse_sample_order: bool,
    ) -> Self {
        self.shading_rate_coarse_sample_order = shading_rate_coarse_sample_order.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShadingRateImagePropertiesNV.html>"]
pub struct PhysicalDeviceShadingRateImagePropertiesNV<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shading_rate_texel_size: Extent2D,
    pub shading_rate_palette_size: u32,
    pub shading_rate_max_coarse_samples: u32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceShadingRateImagePropertiesNV<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            shading_rate_texel_size: Extent2D::default(),
            shading_rate_palette_size: u32::default(),
            shading_rate_max_coarse_samples: u32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceShadingRateImagePropertiesNV<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV;
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceShadingRateImagePropertiesNV<'_> {}
impl<'a> PhysicalDeviceShadingRateImagePropertiesNV<'a> {
    #[inline]
    pub fn shading_rate_texel_size(mut self, shading_rate_texel_size: Extent2D) -> Self {
        self.shading_rate_texel_size = shading_rate_texel_size;
        self
    }
    #[inline]
    pub fn shading_rate_palette_size(mut self, shading_rate_palette_size: u32) -> Self {
        self.shading_rate_palette_size = shading_rate_palette_size;
        self
    }
    #[inline]
    pub fn shading_rate_max_coarse_samples(mut self, shading_rate_max_coarse_samples: u32) -> Self {
        self.shading_rate_max_coarse_samples = shading_rate_max_coarse_samples;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceInvocationMaskFeaturesHUAWEI.html>"]
pub struct PhysicalDeviceInvocationMaskFeaturesHUAWEI<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub invocation_mask: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceInvocationMaskFeaturesHUAWEI<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            invocation_mask: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceInvocationMaskFeaturesHUAWEI<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI;
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceInvocationMaskFeaturesHUAWEI<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceInvocationMaskFeaturesHUAWEI<'_> {}
impl<'a> PhysicalDeviceInvocationMaskFeaturesHUAWEI<'a> {
    #[inline]
    pub fn invocation_mask(mut self, invocation_mask: bool) -> Self {
        self.invocation_mask = invocation_mask.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCoarseSampleLocationNV.html>"]
pub struct CoarseSampleLocationNV {
    pub pixel_x: u32,
    pub pixel_y: u32,
    pub sample: u32,
}
impl CoarseSampleLocationNV {
    #[inline]
    pub fn pixel_x(mut self, pixel_x: u32) -> Self {
        self.pixel_x = pixel_x;
        self
    }
    #[inline]
    pub fn pixel_y(mut self, pixel_y: u32) -> Self {
        self.pixel_y = pixel_y;
        self
    }
    #[inline]
    pub fn sample(mut self, sample: u32) -> Self {
        self.sample = sample;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCoarseSampleOrderCustomNV.html>"]
pub struct CoarseSampleOrderCustomNV<'a> {
    pub shading_rate: ShadingRatePaletteEntryNV,
    pub sample_count: u32,
    pub sample_location_count: u32,
    pub p_sample_locations: *const CoarseSampleLocationNV,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for CoarseSampleOrderCustomNV<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            shading_rate: ShadingRatePaletteEntryNV::default(),
            sample_count: u32::default(),
            sample_location_count: u32::default(),
            p_sample_locations: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
impl<'a> CoarseSampleOrderCustomNV<'a> {
    #[inline]
    pub fn shading_rate(mut self, shading_rate: ShadingRatePaletteEntryNV) -> Self {
        self.shading_rate = shading_rate;
        self
    }
    #[inline]
    pub fn sample_count(mut self, sample_count: u32) -> Self {
        self.sample_count = sample_count;
        self
    }
    #[inline]
    pub fn sample_locations(mut self, sample_locations: &'a [CoarseSampleLocationNV]) -> Self {
        self.sample_location_count = sample_locations.len() as _;
        self.p_sample_locations = sample_locations.as_ptr();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineViewportCoarseSampleOrderStateCreateInfoNV.html>"]
pub struct PipelineViewportCoarseSampleOrderStateCreateInfoNV<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub sample_order_type: CoarseSampleOrderTypeNV,
    pub custom_sample_order_count: u32,
    pub p_custom_sample_orders: *const CoarseSampleOrderCustomNV<'a>,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PipelineViewportCoarseSampleOrderStateCreateInfoNV<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            sample_order_type: CoarseSampleOrderTypeNV::default(),
            custom_sample_order_count: u32::default(),
            p_custom_sample_orders: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PipelineViewportCoarseSampleOrderStateCreateInfoNV<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV;
}
unsafe impl ExtendsPipelineViewportStateCreateInfo
    for PipelineViewportCoarseSampleOrderStateCreateInfoNV<'_>
{
}
impl<'a> PipelineViewportCoarseSampleOrderStateCreateInfoNV<'a> {
    #[inline]
    pub fn sample_order_type(mut self, sample_order_type: CoarseSampleOrderTypeNV) -> Self {
        self.sample_order_type = sample_order_type;
        self
    }
    #[inline]
    pub fn custom_sample_orders(
        mut self,
        custom_sample_orders: &'a [CoarseSampleOrderCustomNV],
    ) -> Self {
        self.custom_sample_order_count = custom_sample_orders.len() as _;
        self.p_custom_sample_orders = custom_sample_orders.as_ptr();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMeshShaderFeaturesNV.html>"]
pub struct PhysicalDeviceMeshShaderFeaturesNV<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub task_shader: Bool32,
    pub mesh_shader: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceMeshShaderFeaturesNV<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            task_shader: Bool32::default(),
            mesh_shader: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceMeshShaderFeaturesNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV;
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceMeshShaderFeaturesNV<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceMeshShaderFeaturesNV<'_> {}
impl<'a> PhysicalDeviceMeshShaderFeaturesNV<'a> {
    #[inline]
    pub fn task_shader(mut self, task_shader: bool) -> Self {
        self.task_shader = task_shader.into();
        self
    }
    #[inline]
    pub fn mesh_shader(mut self, mesh_shader: bool) -> Self {
        self.mesh_shader = mesh_shader.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMeshShaderPropertiesNV.html>"]
pub struct PhysicalDeviceMeshShaderPropertiesNV<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub max_draw_mesh_tasks_count: u32,
    pub max_task_work_group_invocations: u32,
    pub max_task_work_group_size: [u32; 3],
    pub max_task_total_memory_size: u32,
    pub max_task_output_count: u32,
    pub max_mesh_work_group_invocations: u32,
    pub max_mesh_work_group_size: [u32; 3],
    pub max_mesh_total_memory_size: u32,
    pub max_mesh_output_vertices: u32,
    pub max_mesh_output_primitives: u32,
    pub max_mesh_multiview_view_count: u32,
    pub mesh_output_per_vertex_granularity: u32,
    pub mesh_output_per_primitive_granularity: u32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceMeshShaderPropertiesNV<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            max_draw_mesh_tasks_count: u32::default(),
            max_task_work_group_invocations: u32::default(),
            max_task_work_group_size: unsafe { ::std::mem::zeroed() },
            max_task_total_memory_size: u32::default(),
            max_task_output_count: u32::default(),
            max_mesh_work_group_invocations: u32::default(),
            max_mesh_work_group_size: unsafe { ::std::mem::zeroed() },
            max_mesh_total_memory_size: u32::default(),
            max_mesh_output_vertices: u32::default(),
            max_mesh_output_primitives: u32::default(),
            max_mesh_multiview_view_count: u32::default(),
            mesh_output_per_vertex_granularity: u32::default(),
            mesh_output_per_primitive_granularity: u32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceMeshShaderPropertiesNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV;
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceMeshShaderPropertiesNV<'_> {}
impl<'a> PhysicalDeviceMeshShaderPropertiesNV<'a> {
    #[inline]
    pub fn max_draw_mesh_tasks_count(mut self, max_draw_mesh_tasks_count: u32) -> Self {
        self.max_draw_mesh_tasks_count = max_draw_mesh_tasks_count;
        self
    }
    #[inline]
    pub fn max_task_work_group_invocations(mut self, max_task_work_group_invocations: u32) -> Self {
        self.max_task_work_group_invocations = max_task_work_group_invocations;
        self
    }
    #[inline]
    pub fn max_task_work_group_size(mut self, max_task_work_group_size: [u32; 3]) -> Self {
        self.max_task_work_group_size = max_task_work_group_size;
        self
    }
    #[inline]
    pub fn max_task_total_memory_size(mut self, max_task_total_memory_size: u32) -> Self {
        self.max_task_total_memory_size = max_task_total_memory_size;
        self
    }
    #[inline]
    pub fn max_task_output_count(mut self, max_task_output_count: u32) -> Self {
        self.max_task_output_count = max_task_output_count;
        self
    }
    #[inline]
    pub fn max_mesh_work_group_invocations(mut self, max_mesh_work_group_invocations: u32) -> Self {
        self.max_mesh_work_group_invocations = max_mesh_work_group_invocations;
        self
    }
    #[inline]
    pub fn max_mesh_work_group_size(mut self, max_mesh_work_group_size: [u32; 3]) -> Self {
        self.max_mesh_work_group_size = max_mesh_work_group_size;
        self
    }
    #[inline]
    pub fn max_mesh_total_memory_size(mut self, max_mesh_total_memory_size: u32) -> Self {
        self.max_mesh_total_memory_size = max_mesh_total_memory_size;
        self
    }
    #[inline]
    pub fn max_mesh_output_vertices(mut self, max_mesh_output_vertices: u32) -> Self {
        self.max_mesh_output_vertices = max_mesh_output_vertices;
        self
    }
    #[inline]
    pub fn max_mesh_output_primitives(mut self, max_mesh_output_primitives: u32) -> Self {
        self.max_mesh_output_primitives = max_mesh_output_primitives;
        self
    }
    #[inline]
    pub fn max_mesh_multiview_view_count(mut self, max_mesh_multiview_view_count: u32) -> Self {
        self.max_mesh_multiview_view_count = max_mesh_multiview_view_count;
        self
    }
    #[inline]
    pub fn mesh_output_per_vertex_granularity(
        mut self,
        mesh_output_per_vertex_granularity: u32,
    ) -> Self {
        self.mesh_output_per_vertex_granularity = mesh_output_per_vertex_granularity;
        self
    }
    #[inline]
    pub fn mesh_output_per_primitive_granularity(
        mut self,
        mesh_output_per_primitive_granularity: u32,
    ) -> Self {
        self.mesh_output_per_primitive_granularity = mesh_output_per_primitive_granularity;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDrawMeshTasksIndirectCommandNV.html>"]
pub struct DrawMeshTasksIndirectCommandNV {
    pub task_count: u32,
    pub first_task: u32,
}
impl DrawMeshTasksIndirectCommandNV {
    #[inline]
    pub fn task_count(mut self, task_count: u32) -> Self {
        self.task_count = task_count;
        self
    }
    #[inline]
    pub fn first_task(mut self, first_task: u32) -> Self {
        self.first_task = first_task;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRayTracingShaderGroupCreateInfoNV.html>"]
pub struct RayTracingShaderGroupCreateInfoNV<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub ty: RayTracingShaderGroupTypeKHR,
    pub general_shader: u32,
    pub closest_hit_shader: u32,
    pub any_hit_shader: u32,
    pub intersection_shader: u32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for RayTracingShaderGroupCreateInfoNV<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            ty: RayTracingShaderGroupTypeKHR::default(),
            general_shader: u32::default(),
            closest_hit_shader: u32::default(),
            any_hit_shader: u32::default(),
            intersection_shader: u32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for RayTracingShaderGroupCreateInfoNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV;
}
impl<'a> RayTracingShaderGroupCreateInfoNV<'a> {
    #[inline]
    pub fn ty(mut self, ty: RayTracingShaderGroupTypeKHR) -> Self {
        self.ty = ty;
        self
    }
    #[inline]
    pub fn general_shader(mut self, general_shader: u32) -> Self {
        self.general_shader = general_shader;
        self
    }
    #[inline]
    pub fn closest_hit_shader(mut self, closest_hit_shader: u32) -> Self {
        self.closest_hit_shader = closest_hit_shader;
        self
    }
    #[inline]
    pub fn any_hit_shader(mut self, any_hit_shader: u32) -> Self {
        self.any_hit_shader = any_hit_shader;
        self
    }
    #[inline]
    pub fn intersection_shader(mut self, intersection_shader: u32) -> Self {
        self.intersection_shader = intersection_shader;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRayTracingShaderGroupCreateInfoKHR.html>"]
pub struct RayTracingShaderGroupCreateInfoKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub ty: RayTracingShaderGroupTypeKHR,
    pub general_shader: u32,
    pub closest_hit_shader: u32,
    pub any_hit_shader: u32,
    pub intersection_shader: u32,
    pub p_shader_group_capture_replay_handle: *const c_void,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for RayTracingShaderGroupCreateInfoKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            ty: RayTracingShaderGroupTypeKHR::default(),
            general_shader: u32::default(),
            closest_hit_shader: u32::default(),
            any_hit_shader: u32::default(),
            intersection_shader: u32::default(),
            p_shader_group_capture_replay_handle: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for RayTracingShaderGroupCreateInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR;
}
impl<'a> RayTracingShaderGroupCreateInfoKHR<'a> {
    #[inline]
    pub fn ty(mut self, ty: RayTracingShaderGroupTypeKHR) -> Self {
        self.ty = ty;
        self
    }
    #[inline]
    pub fn general_shader(mut self, general_shader: u32) -> Self {
        self.general_shader = general_shader;
        self
    }
    #[inline]
    pub fn closest_hit_shader(mut self, closest_hit_shader: u32) -> Self {
        self.closest_hit_shader = closest_hit_shader;
        self
    }
    #[inline]
    pub fn any_hit_shader(mut self, any_hit_shader: u32) -> Self {
        self.any_hit_shader = any_hit_shader;
        self
    }
    #[inline]
    pub fn intersection_shader(mut self, intersection_shader: u32) -> Self {
        self.intersection_shader = intersection_shader;
        self
    }
    #[inline]
    pub fn shader_group_capture_replay_handle(
        mut self,
        shader_group_capture_replay_handle: *const c_void,
    ) -> Self {
        self.p_shader_group_capture_replay_handle = shader_group_capture_replay_handle;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRayTracingPipelineCreateInfoNV.html>"]
pub struct RayTracingPipelineCreateInfoNV<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: PipelineCreateFlags,
    pub stage_count: u32,
    pub p_stages: *const PipelineShaderStageCreateInfo<'a>,
    pub group_count: u32,
    pub p_groups: *const RayTracingShaderGroupCreateInfoNV<'a>,
    pub max_recursion_depth: u32,
    pub layout: PipelineLayout,
    pub base_pipeline_handle: Pipeline,
    pub base_pipeline_index: i32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for RayTracingPipelineCreateInfoNV<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: PipelineCreateFlags::default(),
            stage_count: u32::default(),
            p_stages: ::std::ptr::null(),
            group_count: u32::default(),
            p_groups: ::std::ptr::null(),
            max_recursion_depth: u32::default(),
            layout: PipelineLayout::default(),
            base_pipeline_handle: Pipeline::default(),
            base_pipeline_index: i32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for RayTracingPipelineCreateInfoNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::RAY_TRACING_PIPELINE_CREATE_INFO_NV;
}
pub unsafe trait ExtendsRayTracingPipelineCreateInfoNV {}
impl<'a> RayTracingPipelineCreateInfoNV<'a> {
    #[inline]
    pub fn flags(mut self, flags: PipelineCreateFlags) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn stages(mut self, stages: &'a [PipelineShaderStageCreateInfo]) -> Self {
        self.stage_count = stages.len() as _;
        self.p_stages = stages.as_ptr();
        self
    }
    #[inline]
    pub fn groups(mut self, groups: &'a [RayTracingShaderGroupCreateInfoNV]) -> Self {
        self.group_count = groups.len() as _;
        self.p_groups = groups.as_ptr();
        self
    }
    #[inline]
    pub fn max_recursion_depth(mut self, max_recursion_depth: u32) -> Self {
        self.max_recursion_depth = max_recursion_depth;
        self
    }
    #[inline]
    pub fn layout(mut self, layout: PipelineLayout) -> Self {
        self.layout = layout;
        self
    }
    #[inline]
    pub fn base_pipeline_handle(mut self, base_pipeline_handle: Pipeline) -> Self {
        self.base_pipeline_handle = base_pipeline_handle;
        self
    }
    #[inline]
    pub fn base_pipeline_index(mut self, base_pipeline_index: i32) -> Self {
        self.base_pipeline_index = base_pipeline_index;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `x.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsRayTracingPipelineCreateInfoNV>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.p_next as _;
            self.p_next = next_ptr;
        }
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRayTracingPipelineCreateInfoKHR.html>"]
pub struct RayTracingPipelineCreateInfoKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: PipelineCreateFlags,
    pub stage_count: u32,
    pub p_stages: *const PipelineShaderStageCreateInfo<'a>,
    pub group_count: u32,
    pub p_groups: *const RayTracingShaderGroupCreateInfoKHR<'a>,
    pub max_pipeline_ray_recursion_depth: u32,
    pub p_library_info: *const PipelineLibraryCreateInfoKHR<'a>,
    pub p_library_interface: *const RayTracingPipelineInterfaceCreateInfoKHR<'a>,
    pub p_dynamic_state: *const PipelineDynamicStateCreateInfo<'a>,
    pub layout: PipelineLayout,
    pub base_pipeline_handle: Pipeline,
    pub base_pipeline_index: i32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for RayTracingPipelineCreateInfoKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: PipelineCreateFlags::default(),
            stage_count: u32::default(),
            p_stages: ::std::ptr::null(),
            group_count: u32::default(),
            p_groups: ::std::ptr::null(),
            max_pipeline_ray_recursion_depth: u32::default(),
            p_library_info: ::std::ptr::null(),
            p_library_interface: ::std::ptr::null(),
            p_dynamic_state: ::std::ptr::null(),
            layout: PipelineLayout::default(),
            base_pipeline_handle: Pipeline::default(),
            base_pipeline_index: i32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for RayTracingPipelineCreateInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::RAY_TRACING_PIPELINE_CREATE_INFO_KHR;
}
pub unsafe trait ExtendsRayTracingPipelineCreateInfoKHR {}
impl<'a> RayTracingPipelineCreateInfoKHR<'a> {
    #[inline]
    pub fn flags(mut self, flags: PipelineCreateFlags) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn stages(mut self, stages: &'a [PipelineShaderStageCreateInfo]) -> Self {
        self.stage_count = stages.len() as _;
        self.p_stages = stages.as_ptr();
        self
    }
    #[inline]
    pub fn groups(mut self, groups: &'a [RayTracingShaderGroupCreateInfoKHR]) -> Self {
        self.group_count = groups.len() as _;
        self.p_groups = groups.as_ptr();
        self
    }
    #[inline]
    pub fn max_pipeline_ray_recursion_depth(
        mut self,
        max_pipeline_ray_recursion_depth: u32,
    ) -> Self {
        self.max_pipeline_ray_recursion_depth = max_pipeline_ray_recursion_depth;
        self
    }
    #[inline]
    pub fn library_info(mut self, library_info: &'a PipelineLibraryCreateInfoKHR<'a>) -> Self {
        self.p_library_info = library_info;
        self
    }
    #[inline]
    pub fn library_interface(
        mut self,
        library_interface: &'a RayTracingPipelineInterfaceCreateInfoKHR<'a>,
    ) -> Self {
        self.p_library_interface = library_interface;
        self
    }
    #[inline]
    pub fn dynamic_state(mut self, dynamic_state: &'a PipelineDynamicStateCreateInfo<'a>) -> Self {
        self.p_dynamic_state = dynamic_state;
        self
    }
    #[inline]
    pub fn layout(mut self, layout: PipelineLayout) -> Self {
        self.layout = layout;
        self
    }
    #[inline]
    pub fn base_pipeline_handle(mut self, base_pipeline_handle: Pipeline) -> Self {
        self.base_pipeline_handle = base_pipeline_handle;
        self
    }
    #[inline]
    pub fn base_pipeline_index(mut self, base_pipeline_index: i32) -> Self {
        self.base_pipeline_index = base_pipeline_index;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `x.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsRayTracingPipelineCreateInfoKHR>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.p_next as _;
            self.p_next = next_ptr;
        }
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkGeometryTrianglesNV.html>"]
pub struct GeometryTrianglesNV<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub vertex_data: Buffer,
    pub vertex_offset: DeviceSize,
    pub vertex_count: u32,
    pub vertex_stride: DeviceSize,
    pub vertex_format: Format,
    pub index_data: Buffer,
    pub index_offset: DeviceSize,
    pub index_count: u32,
    pub index_type: IndexType,
    pub transform_data: Buffer,
    pub transform_offset: DeviceSize,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for GeometryTrianglesNV<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            vertex_data: Buffer::default(),
            vertex_offset: DeviceSize::default(),
            vertex_count: u32::default(),
            vertex_stride: DeviceSize::default(),
            vertex_format: Format::default(),
            index_data: Buffer::default(),
            index_offset: DeviceSize::default(),
            index_count: u32::default(),
            index_type: IndexType::default(),
            transform_data: Buffer::default(),
            transform_offset: DeviceSize::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for GeometryTrianglesNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::GEOMETRY_TRIANGLES_NV;
}
impl<'a> GeometryTrianglesNV<'a> {
    #[inline]
    pub fn vertex_data(mut self, vertex_data: Buffer) -> Self {
        self.vertex_data = vertex_data;
        self
    }
    #[inline]
    pub fn vertex_offset(mut self, vertex_offset: DeviceSize) -> Self {
        self.vertex_offset = vertex_offset;
        self
    }
    #[inline]
    pub fn vertex_count(mut self, vertex_count: u32) -> Self {
        self.vertex_count = vertex_count;
        self
    }
    #[inline]
    pub fn vertex_stride(mut self, vertex_stride: DeviceSize) -> Self {
        self.vertex_stride = vertex_stride;
        self
    }
    #[inline]
    pub fn vertex_format(mut self, vertex_format: Format) -> Self {
        self.vertex_format = vertex_format;
        self
    }
    #[inline]
    pub fn index_data(mut self, index_data: Buffer) -> Self {
        self.index_data = index_data;
        self
    }
    #[inline]
    pub fn index_offset(mut self, index_offset: DeviceSize) -> Self {
        self.index_offset = index_offset;
        self
    }
    #[inline]
    pub fn index_count(mut self, index_count: u32) -> Self {
        self.index_count = index_count;
        self
    }
    #[inline]
    pub fn index_type(mut self, index_type: IndexType) -> Self {
        self.index_type = index_type;
        self
    }
    #[inline]
    pub fn transform_data(mut self, transform_data: Buffer) -> Self {
        self.transform_data = transform_data;
        self
    }
    #[inline]
    pub fn transform_offset(mut self, transform_offset: DeviceSize) -> Self {
        self.transform_offset = transform_offset;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkGeometryAABBNV.html>"]
pub struct GeometryAABBNV<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub aabb_data: Buffer,
    pub num_aab_bs: u32,
    pub stride: u32,
    pub offset: DeviceSize,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for GeometryAABBNV<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            aabb_data: Buffer::default(),
            num_aab_bs: u32::default(),
            stride: u32::default(),
            offset: DeviceSize::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for GeometryAABBNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::GEOMETRY_AABB_NV;
}
impl<'a> GeometryAABBNV<'a> {
    #[inline]
    pub fn aabb_data(mut self, aabb_data: Buffer) -> Self {
        self.aabb_data = aabb_data;
        self
    }
    #[inline]
    pub fn num_aab_bs(mut self, num_aab_bs: u32) -> Self {
        self.num_aab_bs = num_aab_bs;
        self
    }
    #[inline]
    pub fn stride(mut self, stride: u32) -> Self {
        self.stride = stride;
        self
    }
    #[inline]
    pub fn offset(mut self, offset: DeviceSize) -> Self {
        self.offset = offset;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkGeometryDataNV.html>"]
pub struct GeometryDataNV<'a> {
    pub triangles: GeometryTrianglesNV<'a>,
    pub aabbs: GeometryAABBNV<'a>,
    pub _marker: PhantomData<&'a ()>,
}
impl<'a> GeometryDataNV<'a> {
    #[inline]
    pub fn triangles(mut self, triangles: GeometryTrianglesNV<'a>) -> Self {
        self.triangles = triangles;
        self
    }
    #[inline]
    pub fn aabbs(mut self, aabbs: GeometryAABBNV<'a>) -> Self {
        self.aabbs = aabbs;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkGeometryNV.html>"]
pub struct GeometryNV<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub geometry_type: GeometryTypeKHR,
    pub geometry: GeometryDataNV<'a>,
    pub flags: GeometryFlagsKHR,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for GeometryNV<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            geometry_type: GeometryTypeKHR::default(),
            geometry: GeometryDataNV::default(),
            flags: GeometryFlagsKHR::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for GeometryNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::GEOMETRY_NV;
}
impl<'a> GeometryNV<'a> {
    #[inline]
    pub fn geometry_type(mut self, geometry_type: GeometryTypeKHR) -> Self {
        self.geometry_type = geometry_type;
        self
    }
    #[inline]
    pub fn geometry(mut self, geometry: GeometryDataNV<'a>) -> Self {
        self.geometry = geometry;
        self
    }
    #[inline]
    pub fn flags(mut self, flags: GeometryFlagsKHR) -> Self {
        self.flags = flags;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAccelerationStructureInfoNV.html>"]
pub struct AccelerationStructureInfoNV<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub ty: AccelerationStructureTypeNV,
    pub flags: BuildAccelerationStructureFlagsNV,
    pub instance_count: u32,
    pub geometry_count: u32,
    pub p_geometries: *const GeometryNV<'a>,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for AccelerationStructureInfoNV<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            ty: AccelerationStructureTypeNV::default(),
            flags: BuildAccelerationStructureFlagsNV::default(),
            instance_count: u32::default(),
            geometry_count: u32::default(),
            p_geometries: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for AccelerationStructureInfoNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ACCELERATION_STRUCTURE_INFO_NV;
}
impl<'a> AccelerationStructureInfoNV<'a> {
    #[inline]
    pub fn ty(mut self, ty: AccelerationStructureTypeNV) -> Self {
        self.ty = ty;
        self
    }
    #[inline]
    pub fn flags(mut self, flags: BuildAccelerationStructureFlagsNV) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn instance_count(mut self, instance_count: u32) -> Self {
        self.instance_count = instance_count;
        self
    }
    #[inline]
    pub fn geometries(mut self, geometries: &'a [GeometryNV]) -> Self {
        self.geometry_count = geometries.len() as _;
        self.p_geometries = geometries.as_ptr();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAccelerationStructureCreateInfoNV.html>"]
pub struct AccelerationStructureCreateInfoNV<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub compacted_size: DeviceSize,
    pub info: AccelerationStructureInfoNV<'a>,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for AccelerationStructureCreateInfoNV<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            compacted_size: DeviceSize::default(),
            info: AccelerationStructureInfoNV::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for AccelerationStructureCreateInfoNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ACCELERATION_STRUCTURE_CREATE_INFO_NV;
}
impl<'a> AccelerationStructureCreateInfoNV<'a> {
    #[inline]
    pub fn compacted_size(mut self, compacted_size: DeviceSize) -> Self {
        self.compacted_size = compacted_size;
        self
    }
    #[inline]
    pub fn info(mut self, info: AccelerationStructureInfoNV<'a>) -> Self {
        self.info = info;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBindAccelerationStructureMemoryInfoNV.html>"]
pub struct BindAccelerationStructureMemoryInfoNV<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub acceleration_structure: AccelerationStructureNV,
    pub memory: DeviceMemory,
    pub memory_offset: DeviceSize,
    pub device_index_count: u32,
    pub p_device_indices: *const u32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for BindAccelerationStructureMemoryInfoNV<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            acceleration_structure: AccelerationStructureNV::default(),
            memory: DeviceMemory::default(),
            memory_offset: DeviceSize::default(),
            device_index_count: u32::default(),
            p_device_indices: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for BindAccelerationStructureMemoryInfoNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV;
}
impl<'a> BindAccelerationStructureMemoryInfoNV<'a> {
    #[inline]
    pub fn acceleration_structure(
        mut self,
        acceleration_structure: AccelerationStructureNV,
    ) -> Self {
        self.acceleration_structure = acceleration_structure;
        self
    }
    #[inline]
    pub fn memory(mut self, memory: DeviceMemory) -> Self {
        self.memory = memory;
        self
    }
    #[inline]
    pub fn memory_offset(mut self, memory_offset: DeviceSize) -> Self {
        self.memory_offset = memory_offset;
        self
    }
    #[inline]
    pub fn device_indices(mut self, device_indices: &'a [u32]) -> Self {
        self.device_index_count = device_indices.len() as _;
        self.p_device_indices = device_indices.as_ptr();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkWriteDescriptorSetAccelerationStructureKHR.html>"]
pub struct WriteDescriptorSetAccelerationStructureKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub acceleration_structure_count: u32,
    pub p_acceleration_structures: *const AccelerationStructureKHR,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for WriteDescriptorSetAccelerationStructureKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            acceleration_structure_count: u32::default(),
            p_acceleration_structures: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for WriteDescriptorSetAccelerationStructureKHR<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR;
}
unsafe impl ExtendsWriteDescriptorSet for WriteDescriptorSetAccelerationStructureKHR<'_> {}
impl<'a> WriteDescriptorSetAccelerationStructureKHR<'a> {
    #[inline]
    pub fn acceleration_structures(
        mut self,
        acceleration_structures: &'a [AccelerationStructureKHR],
    ) -> Self {
        self.acceleration_structure_count = acceleration_structures.len() as _;
        self.p_acceleration_structures = acceleration_structures.as_ptr();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkWriteDescriptorSetAccelerationStructureNV.html>"]
pub struct WriteDescriptorSetAccelerationStructureNV<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub acceleration_structure_count: u32,
    pub p_acceleration_structures: *const AccelerationStructureNV,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for WriteDescriptorSetAccelerationStructureNV<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            acceleration_structure_count: u32::default(),
            p_acceleration_structures: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for WriteDescriptorSetAccelerationStructureNV<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV;
}
unsafe impl ExtendsWriteDescriptorSet for WriteDescriptorSetAccelerationStructureNV<'_> {}
impl<'a> WriteDescriptorSetAccelerationStructureNV<'a> {
    #[inline]
    pub fn acceleration_structures(
        mut self,
        acceleration_structures: &'a [AccelerationStructureNV],
    ) -> Self {
        self.acceleration_structure_count = acceleration_structures.len() as _;
        self.p_acceleration_structures = acceleration_structures.as_ptr();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAccelerationStructureMemoryRequirementsInfoNV.html>"]
pub struct AccelerationStructureMemoryRequirementsInfoNV<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub ty: AccelerationStructureMemoryRequirementsTypeNV,
    pub acceleration_structure: AccelerationStructureNV,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for AccelerationStructureMemoryRequirementsInfoNV<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            ty: AccelerationStructureMemoryRequirementsTypeNV::default(),
            acceleration_structure: AccelerationStructureNV::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for AccelerationStructureMemoryRequirementsInfoNV<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV;
}
impl<'a> AccelerationStructureMemoryRequirementsInfoNV<'a> {
    #[inline]
    pub fn ty(mut self, ty: AccelerationStructureMemoryRequirementsTypeNV) -> Self {
        self.ty = ty;
        self
    }
    #[inline]
    pub fn acceleration_structure(
        mut self,
        acceleration_structure: AccelerationStructureNV,
    ) -> Self {
        self.acceleration_structure = acceleration_structure;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceAccelerationStructureFeaturesKHR.html>"]
pub struct PhysicalDeviceAccelerationStructureFeaturesKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub acceleration_structure: Bool32,
    pub acceleration_structure_capture_replay: Bool32,
    pub acceleration_structure_indirect_build: Bool32,
    pub acceleration_structure_host_commands: Bool32,
    pub descriptor_binding_acceleration_structure_update_after_bind: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceAccelerationStructureFeaturesKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            acceleration_structure: Bool32::default(),
            acceleration_structure_capture_replay: Bool32::default(),
            acceleration_structure_indirect_build: Bool32::default(),
            acceleration_structure_host_commands: Bool32::default(),
            descriptor_binding_acceleration_structure_update_after_bind: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceAccelerationStructureFeaturesKHR<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR;
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceAccelerationStructureFeaturesKHR<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceAccelerationStructureFeaturesKHR<'_> {}
impl<'a> PhysicalDeviceAccelerationStructureFeaturesKHR<'a> {
    #[inline]
    pub fn acceleration_structure(mut self, acceleration_structure: bool) -> Self {
        self.acceleration_structure = acceleration_structure.into();
        self
    }
    #[inline]
    pub fn acceleration_structure_capture_replay(
        mut self,
        acceleration_structure_capture_replay: bool,
    ) -> Self {
        self.acceleration_structure_capture_replay = acceleration_structure_capture_replay.into();
        self
    }
    #[inline]
    pub fn acceleration_structure_indirect_build(
        mut self,
        acceleration_structure_indirect_build: bool,
    ) -> Self {
        self.acceleration_structure_indirect_build = acceleration_structure_indirect_build.into();
        self
    }
    #[inline]
    pub fn acceleration_structure_host_commands(
        mut self,
        acceleration_structure_host_commands: bool,
    ) -> Self {
        self.acceleration_structure_host_commands = acceleration_structure_host_commands.into();
        self
    }
    #[inline]
    pub fn descriptor_binding_acceleration_structure_update_after_bind(
        mut self,
        descriptor_binding_acceleration_structure_update_after_bind: bool,
    ) -> Self {
        self.descriptor_binding_acceleration_structure_update_after_bind =
            descriptor_binding_acceleration_structure_update_after_bind.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceRayTracingPipelineFeaturesKHR.html>"]
pub struct PhysicalDeviceRayTracingPipelineFeaturesKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub ray_tracing_pipeline: Bool32,
    pub ray_tracing_pipeline_shader_group_handle_capture_replay: Bool32,
    pub ray_tracing_pipeline_shader_group_handle_capture_replay_mixed: Bool32,
    pub ray_tracing_pipeline_trace_rays_indirect: Bool32,
    pub ray_traversal_primitive_culling: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceRayTracingPipelineFeaturesKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            ray_tracing_pipeline: Bool32::default(),
            ray_tracing_pipeline_shader_group_handle_capture_replay: Bool32::default(),
            ray_tracing_pipeline_shader_group_handle_capture_replay_mixed: Bool32::default(),
            ray_tracing_pipeline_trace_rays_indirect: Bool32::default(),
            ray_traversal_primitive_culling: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceRayTracingPipelineFeaturesKHR<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR;
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceRayTracingPipelineFeaturesKHR<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceRayTracingPipelineFeaturesKHR<'_> {}
impl<'a> PhysicalDeviceRayTracingPipelineFeaturesKHR<'a> {
    #[inline]
    pub fn ray_tracing_pipeline(mut self, ray_tracing_pipeline: bool) -> Self {
        self.ray_tracing_pipeline = ray_tracing_pipeline.into();
        self
    }
    #[inline]
    pub fn ray_tracing_pipeline_shader_group_handle_capture_replay(
        mut self,
        ray_tracing_pipeline_shader_group_handle_capture_replay: bool,
    ) -> Self {
        self.ray_tracing_pipeline_shader_group_handle_capture_replay =
            ray_tracing_pipeline_shader_group_handle_capture_replay.into();
        self
    }
    #[inline]
    pub fn ray_tracing_pipeline_shader_group_handle_capture_replay_mixed(
        mut self,
        ray_tracing_pipeline_shader_group_handle_capture_replay_mixed: bool,
    ) -> Self {
        self.ray_tracing_pipeline_shader_group_handle_capture_replay_mixed =
            ray_tracing_pipeline_shader_group_handle_capture_replay_mixed.into();
        self
    }
    #[inline]
    pub fn ray_tracing_pipeline_trace_rays_indirect(
        mut self,
        ray_tracing_pipeline_trace_rays_indirect: bool,
    ) -> Self {
        self.ray_tracing_pipeline_trace_rays_indirect =
            ray_tracing_pipeline_trace_rays_indirect.into();
        self
    }
    #[inline]
    pub fn ray_traversal_primitive_culling(
        mut self,
        ray_traversal_primitive_culling: bool,
    ) -> Self {
        self.ray_traversal_primitive_culling = ray_traversal_primitive_culling.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceRayQueryFeaturesKHR.html>"]
pub struct PhysicalDeviceRayQueryFeaturesKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub ray_query: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceRayQueryFeaturesKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            ray_query: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceRayQueryFeaturesKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR;
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceRayQueryFeaturesKHR<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceRayQueryFeaturesKHR<'_> {}
impl<'a> PhysicalDeviceRayQueryFeaturesKHR<'a> {
    #[inline]
    pub fn ray_query(mut self, ray_query: bool) -> Self {
        self.ray_query = ray_query.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceAccelerationStructurePropertiesKHR.html>"]
pub struct PhysicalDeviceAccelerationStructurePropertiesKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub max_geometry_count: u64,
    pub max_instance_count: u64,
    pub max_primitive_count: u64,
    pub max_per_stage_descriptor_acceleration_structures: u32,
    pub max_per_stage_descriptor_update_after_bind_acceleration_structures: u32,
    pub max_descriptor_set_acceleration_structures: u32,
    pub max_descriptor_set_update_after_bind_acceleration_structures: u32,
    pub min_acceleration_structure_scratch_offset_alignment: u32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceAccelerationStructurePropertiesKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            max_geometry_count: u64::default(),
            max_instance_count: u64::default(),
            max_primitive_count: u64::default(),
            max_per_stage_descriptor_acceleration_structures: u32::default(),
            max_per_stage_descriptor_update_after_bind_acceleration_structures: u32::default(),
            max_descriptor_set_acceleration_structures: u32::default(),
            max_descriptor_set_update_after_bind_acceleration_structures: u32::default(),
            min_acceleration_structure_scratch_offset_alignment: u32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceAccelerationStructurePropertiesKHR<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR;
}
unsafe impl ExtendsPhysicalDeviceProperties2
    for PhysicalDeviceAccelerationStructurePropertiesKHR<'_>
{
}
impl<'a> PhysicalDeviceAccelerationStructurePropertiesKHR<'a> {
    #[inline]
    pub fn max_geometry_count(mut self, max_geometry_count: u64) -> Self {
        self.max_geometry_count = max_geometry_count;
        self
    }
    #[inline]
    pub fn max_instance_count(mut self, max_instance_count: u64) -> Self {
        self.max_instance_count = max_instance_count;
        self
    }
    #[inline]
    pub fn max_primitive_count(mut self, max_primitive_count: u64) -> Self {
        self.max_primitive_count = max_primitive_count;
        self
    }
    #[inline]
    pub fn max_per_stage_descriptor_acceleration_structures(
        mut self,
        max_per_stage_descriptor_acceleration_structures: u32,
    ) -> Self {
        self.max_per_stage_descriptor_acceleration_structures =
            max_per_stage_descriptor_acceleration_structures;
        self
    }
    #[inline]
    pub fn max_per_stage_descriptor_update_after_bind_acceleration_structures(
        mut self,
        max_per_stage_descriptor_update_after_bind_acceleration_structures: u32,
    ) -> Self {
        self.max_per_stage_descriptor_update_after_bind_acceleration_structures =
            max_per_stage_descriptor_update_after_bind_acceleration_structures;
        self
    }
    #[inline]
    pub fn max_descriptor_set_acceleration_structures(
        mut self,
        max_descriptor_set_acceleration_structures: u32,
    ) -> Self {
        self.max_descriptor_set_acceleration_structures =
            max_descriptor_set_acceleration_structures;
        self
    }
    #[inline]
    pub fn max_descriptor_set_update_after_bind_acceleration_structures(
        mut self,
        max_descriptor_set_update_after_bind_acceleration_structures: u32,
    ) -> Self {
        self.max_descriptor_set_update_after_bind_acceleration_structures =
            max_descriptor_set_update_after_bind_acceleration_structures;
        self
    }
    #[inline]
    pub fn min_acceleration_structure_scratch_offset_alignment(
        mut self,
        min_acceleration_structure_scratch_offset_alignment: u32,
    ) -> Self {
        self.min_acceleration_structure_scratch_offset_alignment =
            min_acceleration_structure_scratch_offset_alignment;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceRayTracingPipelinePropertiesKHR.html>"]
pub struct PhysicalDeviceRayTracingPipelinePropertiesKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shader_group_handle_size: u32,
    pub max_ray_recursion_depth: u32,
    pub max_shader_group_stride: u32,
    pub shader_group_base_alignment: u32,
    pub shader_group_handle_capture_replay_size: u32,
    pub max_ray_dispatch_invocation_count: u32,
    pub shader_group_handle_alignment: u32,
    pub max_ray_hit_attribute_size: u32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceRayTracingPipelinePropertiesKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            shader_group_handle_size: u32::default(),
            max_ray_recursion_depth: u32::default(),
            max_shader_group_stride: u32::default(),
            shader_group_base_alignment: u32::default(),
            shader_group_handle_capture_replay_size: u32::default(),
            max_ray_dispatch_invocation_count: u32::default(),
            shader_group_handle_alignment: u32::default(),
            max_ray_hit_attribute_size: u32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceRayTracingPipelinePropertiesKHR<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR;
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceRayTracingPipelinePropertiesKHR<'_> {}
impl<'a> PhysicalDeviceRayTracingPipelinePropertiesKHR<'a> {
    #[inline]
    pub fn shader_group_handle_size(mut self, shader_group_handle_size: u32) -> Self {
        self.shader_group_handle_size = shader_group_handle_size;
        self
    }
    #[inline]
    pub fn max_ray_recursion_depth(mut self, max_ray_recursion_depth: u32) -> Self {
        self.max_ray_recursion_depth = max_ray_recursion_depth;
        self
    }
    #[inline]
    pub fn max_shader_group_stride(mut self, max_shader_group_stride: u32) -> Self {
        self.max_shader_group_stride = max_shader_group_stride;
        self
    }
    #[inline]
    pub fn shader_group_base_alignment(mut self, shader_group_base_alignment: u32) -> Self {
        self.shader_group_base_alignment = shader_group_base_alignment;
        self
    }
    #[inline]
    pub fn shader_group_handle_capture_replay_size(
        mut self,
        shader_group_handle_capture_replay_size: u32,
    ) -> Self {
        self.shader_group_handle_capture_replay_size = shader_group_handle_capture_replay_size;
        self
    }
    #[inline]
    pub fn max_ray_dispatch_invocation_count(
        mut self,
        max_ray_dispatch_invocation_count: u32,
    ) -> Self {
        self.max_ray_dispatch_invocation_count = max_ray_dispatch_invocation_count;
        self
    }
    #[inline]
    pub fn shader_group_handle_alignment(mut self, shader_group_handle_alignment: u32) -> Self {
        self.shader_group_handle_alignment = shader_group_handle_alignment;
        self
    }
    #[inline]
    pub fn max_ray_hit_attribute_size(mut self, max_ray_hit_attribute_size: u32) -> Self {
        self.max_ray_hit_attribute_size = max_ray_hit_attribute_size;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceRayTracingPropertiesNV.html>"]
pub struct PhysicalDeviceRayTracingPropertiesNV<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shader_group_handle_size: u32,
    pub max_recursion_depth: u32,
    pub max_shader_group_stride: u32,
    pub shader_group_base_alignment: u32,
    pub max_geometry_count: u64,
    pub max_instance_count: u64,
    pub max_triangle_count: u64,
    pub max_descriptor_set_acceleration_structures: u32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceRayTracingPropertiesNV<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            shader_group_handle_size: u32::default(),
            max_recursion_depth: u32::default(),
            max_shader_group_stride: u32::default(),
            shader_group_base_alignment: u32::default(),
            max_geometry_count: u64::default(),
            max_instance_count: u64::default(),
            max_triangle_count: u64::default(),
            max_descriptor_set_acceleration_structures: u32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceRayTracingPropertiesNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV;
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceRayTracingPropertiesNV<'_> {}
impl<'a> PhysicalDeviceRayTracingPropertiesNV<'a> {
    #[inline]
    pub fn shader_group_handle_size(mut self, shader_group_handle_size: u32) -> Self {
        self.shader_group_handle_size = shader_group_handle_size;
        self
    }
    #[inline]
    pub fn max_recursion_depth(mut self, max_recursion_depth: u32) -> Self {
        self.max_recursion_depth = max_recursion_depth;
        self
    }
    #[inline]
    pub fn max_shader_group_stride(mut self, max_shader_group_stride: u32) -> Self {
        self.max_shader_group_stride = max_shader_group_stride;
        self
    }
    #[inline]
    pub fn shader_group_base_alignment(mut self, shader_group_base_alignment: u32) -> Self {
        self.shader_group_base_alignment = shader_group_base_alignment;
        self
    }
    #[inline]
    pub fn max_geometry_count(mut self, max_geometry_count: u64) -> Self {
        self.max_geometry_count = max_geometry_count;
        self
    }
    #[inline]
    pub fn max_instance_count(mut self, max_instance_count: u64) -> Self {
        self.max_instance_count = max_instance_count;
        self
    }
    #[inline]
    pub fn max_triangle_count(mut self, max_triangle_count: u64) -> Self {
        self.max_triangle_count = max_triangle_count;
        self
    }
    #[inline]
    pub fn max_descriptor_set_acceleration_structures(
        mut self,
        max_descriptor_set_acceleration_structures: u32,
    ) -> Self {
        self.max_descriptor_set_acceleration_structures =
            max_descriptor_set_acceleration_structures;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkStridedDeviceAddressRegionKHR.html>"]
pub struct StridedDeviceAddressRegionKHR {
    pub device_address: DeviceAddress,
    pub stride: DeviceSize,
    pub size: DeviceSize,
}
impl StridedDeviceAddressRegionKHR {
    #[inline]
    pub fn device_address(mut self, device_address: DeviceAddress) -> Self {
        self.device_address = device_address;
        self
    }
    #[inline]
    pub fn stride(mut self, stride: DeviceSize) -> Self {
        self.stride = stride;
        self
    }
    #[inline]
    pub fn size(mut self, size: DeviceSize) -> Self {
        self.size = size;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkTraceRaysIndirectCommandKHR.html>"]
pub struct TraceRaysIndirectCommandKHR {
    pub width: u32,
    pub height: u32,
    pub depth: u32,
}
impl TraceRaysIndirectCommandKHR {
    #[inline]
    pub fn width(mut self, width: u32) -> Self {
        self.width = width;
        self
    }
    #[inline]
    pub fn height(mut self, height: u32) -> Self {
        self.height = height;
        self
    }
    #[inline]
    pub fn depth(mut self, depth: u32) -> Self {
        self.depth = depth;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkTraceRaysIndirectCommand2KHR.html>"]
pub struct TraceRaysIndirectCommand2KHR {
    pub raygen_shader_record_address: DeviceAddress,
    pub raygen_shader_record_size: DeviceSize,
    pub miss_shader_binding_table_address: DeviceAddress,
    pub miss_shader_binding_table_size: DeviceSize,
    pub miss_shader_binding_table_stride: DeviceSize,
    pub hit_shader_binding_table_address: DeviceAddress,
    pub hit_shader_binding_table_size: DeviceSize,
    pub hit_shader_binding_table_stride: DeviceSize,
    pub callable_shader_binding_table_address: DeviceAddress,
    pub callable_shader_binding_table_size: DeviceSize,
    pub callable_shader_binding_table_stride: DeviceSize,
    pub width: u32,
    pub height: u32,
    pub depth: u32,
}
impl TraceRaysIndirectCommand2KHR {
    #[inline]
    pub fn raygen_shader_record_address(
        mut self,
        raygen_shader_record_address: DeviceAddress,
    ) -> Self {
        self.raygen_shader_record_address = raygen_shader_record_address;
        self
    }
    #[inline]
    pub fn raygen_shader_record_size(mut self, raygen_shader_record_size: DeviceSize) -> Self {
        self.raygen_shader_record_size = raygen_shader_record_size;
        self
    }
    #[inline]
    pub fn miss_shader_binding_table_address(
        mut self,
        miss_shader_binding_table_address: DeviceAddress,
    ) -> Self {
        self.miss_shader_binding_table_address = miss_shader_binding_table_address;
        self
    }
    #[inline]
    pub fn miss_shader_binding_table_size(
        mut self,
        miss_shader_binding_table_size: DeviceSize,
    ) -> Self {
        self.miss_shader_binding_table_size = miss_shader_binding_table_size;
        self
    }
    #[inline]
    pub fn miss_shader_binding_table_stride(
        mut self,
        miss_shader_binding_table_stride: DeviceSize,
    ) -> Self {
        self.miss_shader_binding_table_stride = miss_shader_binding_table_stride;
        self
    }
    #[inline]
    pub fn hit_shader_binding_table_address(
        mut self,
        hit_shader_binding_table_address: DeviceAddress,
    ) -> Self {
        self.hit_shader_binding_table_address = hit_shader_binding_table_address;
        self
    }
    #[inline]
    pub fn hit_shader_binding_table_size(
        mut self,
        hit_shader_binding_table_size: DeviceSize,
    ) -> Self {
        self.hit_shader_binding_table_size = hit_shader_binding_table_size;
        self
    }
    #[inline]
    pub fn hit_shader_binding_table_stride(
        mut self,
        hit_shader_binding_table_stride: DeviceSize,
    ) -> Self {
        self.hit_shader_binding_table_stride = hit_shader_binding_table_stride;
        self
    }
    #[inline]
    pub fn callable_shader_binding_table_address(
        mut self,
        callable_shader_binding_table_address: DeviceAddress,
    ) -> Self {
        self.callable_shader_binding_table_address = callable_shader_binding_table_address;
        self
    }
    #[inline]
    pub fn callable_shader_binding_table_size(
        mut self,
        callable_shader_binding_table_size: DeviceSize,
    ) -> Self {
        self.callable_shader_binding_table_size = callable_shader_binding_table_size;
        self
    }
    #[inline]
    pub fn callable_shader_binding_table_stride(
        mut self,
        callable_shader_binding_table_stride: DeviceSize,
    ) -> Self {
        self.callable_shader_binding_table_stride = callable_shader_binding_table_stride;
        self
    }
    #[inline]
    pub fn width(mut self, width: u32) -> Self {
        self.width = width;
        self
    }
    #[inline]
    pub fn height(mut self, height: u32) -> Self {
        self.height = height;
        self
    }
    #[inline]
    pub fn depth(mut self, depth: u32) -> Self {
        self.depth = depth;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR.html>"]
pub struct PhysicalDeviceRayTracingMaintenance1FeaturesKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub ray_tracing_maintenance1: Bool32,
    pub ray_tracing_pipeline_trace_rays_indirect2: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceRayTracingMaintenance1FeaturesKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            ray_tracing_maintenance1: Bool32::default(),
            ray_tracing_pipeline_trace_rays_indirect2: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceRayTracingMaintenance1FeaturesKHR<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR;
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceRayTracingMaintenance1FeaturesKHR<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceRayTracingMaintenance1FeaturesKHR<'_> {}
impl<'a> PhysicalDeviceRayTracingMaintenance1FeaturesKHR<'a> {
    #[inline]
    pub fn ray_tracing_maintenance1(mut self, ray_tracing_maintenance1: bool) -> Self {
        self.ray_tracing_maintenance1 = ray_tracing_maintenance1.into();
        self
    }
    #[inline]
    pub fn ray_tracing_pipeline_trace_rays_indirect2(
        mut self,
        ray_tracing_pipeline_trace_rays_indirect2: bool,
    ) -> Self {
        self.ray_tracing_pipeline_trace_rays_indirect2 =
            ray_tracing_pipeline_trace_rays_indirect2.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDrmFormatModifierPropertiesListEXT.html>"]
pub struct DrmFormatModifierPropertiesListEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub drm_format_modifier_count: u32,
    pub p_drm_format_modifier_properties: *mut DrmFormatModifierPropertiesEXT,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for DrmFormatModifierPropertiesListEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            drm_format_modifier_count: u32::default(),
            p_drm_format_modifier_properties: ::std::ptr::null_mut(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for DrmFormatModifierPropertiesListEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT;
}
unsafe impl ExtendsFormatProperties2 for DrmFormatModifierPropertiesListEXT<'_> {}
impl<'a> DrmFormatModifierPropertiesListEXT<'a> {
    #[inline]
    pub fn drm_format_modifier_properties(
        mut self,
        drm_format_modifier_properties: &'a mut [DrmFormatModifierPropertiesEXT],
    ) -> Self {
        self.drm_format_modifier_count = drm_format_modifier_properties.len() as _;
        self.p_drm_format_modifier_properties = drm_format_modifier_properties.as_mut_ptr();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDrmFormatModifierPropertiesEXT.html>"]
pub struct DrmFormatModifierPropertiesEXT {
    pub drm_format_modifier: u64,
    pub drm_format_modifier_plane_count: u32,
    pub drm_format_modifier_tiling_features: FormatFeatureFlags,
}
impl DrmFormatModifierPropertiesEXT {
    #[inline]
    pub fn drm_format_modifier(mut self, drm_format_modifier: u64) -> Self {
        self.drm_format_modifier = drm_format_modifier;
        self
    }
    #[inline]
    pub fn drm_format_modifier_plane_count(mut self, drm_format_modifier_plane_count: u32) -> Self {
        self.drm_format_modifier_plane_count = drm_format_modifier_plane_count;
        self
    }
    #[inline]
    pub fn drm_format_modifier_tiling_features(
        mut self,
        drm_format_modifier_tiling_features: FormatFeatureFlags,
    ) -> Self {
        self.drm_format_modifier_tiling_features = drm_format_modifier_tiling_features;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceImageDrmFormatModifierInfoEXT.html>"]
pub struct PhysicalDeviceImageDrmFormatModifierInfoEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub drm_format_modifier: u64,
    pub sharing_mode: SharingMode,
    pub queue_family_index_count: u32,
    pub p_queue_family_indices: *const u32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceImageDrmFormatModifierInfoEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            drm_format_modifier: u64::default(),
            sharing_mode: SharingMode::default(),
            queue_family_index_count: u32::default(),
            p_queue_family_indices: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceImageDrmFormatModifierInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT;
}
unsafe impl ExtendsPhysicalDeviceImageFormatInfo2
    for PhysicalDeviceImageDrmFormatModifierInfoEXT<'_>
{
}
impl<'a> PhysicalDeviceImageDrmFormatModifierInfoEXT<'a> {
    #[inline]
    pub fn drm_format_modifier(mut self, drm_format_modifier: u64) -> Self {
        self.drm_format_modifier = drm_format_modifier;
        self
    }
    #[inline]
    pub fn sharing_mode(mut self, sharing_mode: SharingMode) -> Self {
        self.sharing_mode = sharing_mode;
        self
    }
    #[inline]
    pub fn queue_family_indices(mut self, queue_family_indices: &'a [u32]) -> Self {
        self.queue_family_index_count = queue_family_indices.len() as _;
        self.p_queue_family_indices = queue_family_indices.as_ptr();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageDrmFormatModifierListCreateInfoEXT.html>"]
pub struct ImageDrmFormatModifierListCreateInfoEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub drm_format_modifier_count: u32,
    pub p_drm_format_modifiers: *const u64,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for ImageDrmFormatModifierListCreateInfoEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            drm_format_modifier_count: u32::default(),
            p_drm_format_modifiers: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for ImageDrmFormatModifierListCreateInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT;
}
unsafe impl ExtendsImageCreateInfo for ImageDrmFormatModifierListCreateInfoEXT<'_> {}
impl<'a> ImageDrmFormatModifierListCreateInfoEXT<'a> {
    #[inline]
    pub fn drm_format_modifiers(mut self, drm_format_modifiers: &'a [u64]) -> Self {
        self.drm_format_modifier_count = drm_format_modifiers.len() as _;
        self.p_drm_format_modifiers = drm_format_modifiers.as_ptr();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageDrmFormatModifierExplicitCreateInfoEXT.html>"]
pub struct ImageDrmFormatModifierExplicitCreateInfoEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub drm_format_modifier: u64,
    pub drm_format_modifier_plane_count: u32,
    pub p_plane_layouts: *const SubresourceLayout,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for ImageDrmFormatModifierExplicitCreateInfoEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            drm_format_modifier: u64::default(),
            drm_format_modifier_plane_count: u32::default(),
            p_plane_layouts: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for ImageDrmFormatModifierExplicitCreateInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT;
}
unsafe impl ExtendsImageCreateInfo for ImageDrmFormatModifierExplicitCreateInfoEXT<'_> {}
impl<'a> ImageDrmFormatModifierExplicitCreateInfoEXT<'a> {
    #[inline]
    pub fn drm_format_modifier(mut self, drm_format_modifier: u64) -> Self {
        self.drm_format_modifier = drm_format_modifier;
        self
    }
    #[inline]
    pub fn plane_layouts(mut self, plane_layouts: &'a [SubresourceLayout]) -> Self {
        self.drm_format_modifier_plane_count = plane_layouts.len() as _;
        self.p_plane_layouts = plane_layouts.as_ptr();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageDrmFormatModifierPropertiesEXT.html>"]
pub struct ImageDrmFormatModifierPropertiesEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub drm_format_modifier: u64,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for ImageDrmFormatModifierPropertiesEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            drm_format_modifier: u64::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for ImageDrmFormatModifierPropertiesEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT;
}
impl<'a> ImageDrmFormatModifierPropertiesEXT<'a> {
    #[inline]
    pub fn drm_format_modifier(mut self, drm_format_modifier: u64) -> Self {
        self.drm_format_modifier = drm_format_modifier;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageStencilUsageCreateInfo.html>"]
pub struct ImageStencilUsageCreateInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub stencil_usage: ImageUsageFlags,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for ImageStencilUsageCreateInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            stencil_usage: ImageUsageFlags::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for ImageStencilUsageCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::IMAGE_STENCIL_USAGE_CREATE_INFO;
}
unsafe impl ExtendsImageCreateInfo for ImageStencilUsageCreateInfo<'_> {}
unsafe impl ExtendsPhysicalDeviceImageFormatInfo2 for ImageStencilUsageCreateInfo<'_> {}
impl<'a> ImageStencilUsageCreateInfo<'a> {
    #[inline]
    pub fn stencil_usage(mut self, stencil_usage: ImageUsageFlags) -> Self {
        self.stencil_usage = stencil_usage;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceMemoryOverallocationCreateInfoAMD.html>"]
pub struct DeviceMemoryOverallocationCreateInfoAMD<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub overallocation_behavior: MemoryOverallocationBehaviorAMD,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for DeviceMemoryOverallocationCreateInfoAMD<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            overallocation_behavior: MemoryOverallocationBehaviorAMD::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for DeviceMemoryOverallocationCreateInfoAMD<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD;
}
unsafe impl ExtendsDeviceCreateInfo for DeviceMemoryOverallocationCreateInfoAMD<'_> {}
impl<'a> DeviceMemoryOverallocationCreateInfoAMD<'a> {
    #[inline]
    pub fn overallocation_behavior(
        mut self,
        overallocation_behavior: MemoryOverallocationBehaviorAMD,
    ) -> Self {
        self.overallocation_behavior = overallocation_behavior;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFragmentDensityMapFeaturesEXT.html>"]
pub struct PhysicalDeviceFragmentDensityMapFeaturesEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub fragment_density_map: Bool32,
    pub fragment_density_map_dynamic: Bool32,
    pub fragment_density_map_non_subsampled_images: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceFragmentDensityMapFeaturesEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            fragment_density_map: Bool32::default(),
            fragment_density_map_dynamic: Bool32::default(),
            fragment_density_map_non_subsampled_images: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceFragmentDensityMapFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT;
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceFragmentDensityMapFeaturesEXT<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceFragmentDensityMapFeaturesEXT<'_> {}
impl<'a> PhysicalDeviceFragmentDensityMapFeaturesEXT<'a> {
    #[inline]
    pub fn fragment_density_map(mut self, fragment_density_map: bool) -> Self {
        self.fragment_density_map = fragment_density_map.into();
        self
    }
    #[inline]
    pub fn fragment_density_map_dynamic(mut self, fragment_density_map_dynamic: bool) -> Self {
        self.fragment_density_map_dynamic = fragment_density_map_dynamic.into();
        self
    }
    #[inline]
    pub fn fragment_density_map_non_subsampled_images(
        mut self,
        fragment_density_map_non_subsampled_images: bool,
    ) -> Self {
        self.fragment_density_map_non_subsampled_images =
            fragment_density_map_non_subsampled_images.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFragmentDensityMap2FeaturesEXT.html>"]
pub struct PhysicalDeviceFragmentDensityMap2FeaturesEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub fragment_density_map_deferred: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceFragmentDensityMap2FeaturesEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            fragment_density_map_deferred: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceFragmentDensityMap2FeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT;
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceFragmentDensityMap2FeaturesEXT<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceFragmentDensityMap2FeaturesEXT<'_> {}
impl<'a> PhysicalDeviceFragmentDensityMap2FeaturesEXT<'a> {
    #[inline]
    pub fn fragment_density_map_deferred(mut self, fragment_density_map_deferred: bool) -> Self {
        self.fragment_density_map_deferred = fragment_density_map_deferred.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM.html>"]
pub struct PhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub fragment_density_map_offset: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            fragment_density_map_offset: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_QCOM;
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM<'_>
{
}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM<'_> {}
impl<'a> PhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM<'a> {
    #[inline]
    pub fn fragment_density_map_offset(mut self, fragment_density_map_offset: bool) -> Self {
        self.fragment_density_map_offset = fragment_density_map_offset.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFragmentDensityMapPropertiesEXT.html>"]
pub struct PhysicalDeviceFragmentDensityMapPropertiesEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub min_fragment_density_texel_size: Extent2D,
    pub max_fragment_density_texel_size: Extent2D,
    pub fragment_density_invocations: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceFragmentDensityMapPropertiesEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            min_fragment_density_texel_size: Extent2D::default(),
            max_fragment_density_texel_size: Extent2D::default(),
            fragment_density_invocations: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceFragmentDensityMapPropertiesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT;
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceFragmentDensityMapPropertiesEXT<'_> {}
impl<'a> PhysicalDeviceFragmentDensityMapPropertiesEXT<'a> {
    #[inline]
    pub fn min_fragment_density_texel_size(
        mut self,
        min_fragment_density_texel_size: Extent2D,
    ) -> Self {
        self.min_fragment_density_texel_size = min_fragment_density_texel_size;
        self
    }
    #[inline]
    pub fn max_fragment_density_texel_size(
        mut self,
        max_fragment_density_texel_size: Extent2D,
    ) -> Self {
        self.max_fragment_density_texel_size = max_fragment_density_texel_size;
        self
    }
    #[inline]
    pub fn fragment_density_invocations(mut self, fragment_density_invocations: bool) -> Self {
        self.fragment_density_invocations = fragment_density_invocations.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFragmentDensityMap2PropertiesEXT.html>"]
pub struct PhysicalDeviceFragmentDensityMap2PropertiesEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub subsampled_loads: Bool32,
    pub subsampled_coarse_reconstruction_early_access: Bool32,
    pub max_subsampled_array_layers: u32,
    pub max_descriptor_set_subsampled_samplers: u32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceFragmentDensityMap2PropertiesEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            subsampled_loads: Bool32::default(),
            subsampled_coarse_reconstruction_early_access: Bool32::default(),
            max_subsampled_array_layers: u32::default(),
            max_descriptor_set_subsampled_samplers: u32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceFragmentDensityMap2PropertiesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT;
}
unsafe impl ExtendsPhysicalDeviceProperties2
    for PhysicalDeviceFragmentDensityMap2PropertiesEXT<'_>
{
}
impl<'a> PhysicalDeviceFragmentDensityMap2PropertiesEXT<'a> {
    #[inline]
    pub fn subsampled_loads(mut self, subsampled_loads: bool) -> Self {
        self.subsampled_loads = subsampled_loads.into();
        self
    }
    #[inline]
    pub fn subsampled_coarse_reconstruction_early_access(
        mut self,
        subsampled_coarse_reconstruction_early_access: bool,
    ) -> Self {
        self.subsampled_coarse_reconstruction_early_access =
            subsampled_coarse_reconstruction_early_access.into();
        self
    }
    #[inline]
    pub fn max_subsampled_array_layers(mut self, max_subsampled_array_layers: u32) -> Self {
        self.max_subsampled_array_layers = max_subsampled_array_layers;
        self
    }
    #[inline]
    pub fn max_descriptor_set_subsampled_samplers(
        mut self,
        max_descriptor_set_subsampled_samplers: u32,
    ) -> Self {
        self.max_descriptor_set_subsampled_samplers = max_descriptor_set_subsampled_samplers;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM.html>"]
pub struct PhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub fragment_density_offset_granularity: Extent2D,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            fragment_density_offset_granularity: Extent2D::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_QCOM;
}
unsafe impl ExtendsPhysicalDeviceProperties2
    for PhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM<'_>
{
}
impl<'a> PhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM<'a> {
    #[inline]
    pub fn fragment_density_offset_granularity(
        mut self,
        fragment_density_offset_granularity: Extent2D,
    ) -> Self {
        self.fragment_density_offset_granularity = fragment_density_offset_granularity;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderPassFragmentDensityMapCreateInfoEXT.html>"]
pub struct RenderPassFragmentDensityMapCreateInfoEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub fragment_density_map_attachment: AttachmentReference,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for RenderPassFragmentDensityMapCreateInfoEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            fragment_density_map_attachment: AttachmentReference::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for RenderPassFragmentDensityMapCreateInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT;
}
unsafe impl ExtendsRenderPassCreateInfo for RenderPassFragmentDensityMapCreateInfoEXT<'_> {}
unsafe impl ExtendsRenderPassCreateInfo2 for RenderPassFragmentDensityMapCreateInfoEXT<'_> {}
impl<'a> RenderPassFragmentDensityMapCreateInfoEXT<'a> {
    #[inline]
    pub fn fragment_density_map_attachment(
        mut self,
        fragment_density_map_attachment: AttachmentReference,
    ) -> Self {
        self.fragment_density_map_attachment = fragment_density_map_attachment;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSubpassFragmentDensityMapOffsetEndInfoQCOM.html>"]
pub struct SubpassFragmentDensityMapOffsetEndInfoQCOM<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub fragment_density_offset_count: u32,
    pub p_fragment_density_offsets: *const Offset2D,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for SubpassFragmentDensityMapOffsetEndInfoQCOM<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            fragment_density_offset_count: u32::default(),
            p_fragment_density_offsets: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for SubpassFragmentDensityMapOffsetEndInfoQCOM<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::SUBPASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_QCOM;
}
unsafe impl ExtendsSubpassEndInfo for SubpassFragmentDensityMapOffsetEndInfoQCOM<'_> {}
impl<'a> SubpassFragmentDensityMapOffsetEndInfoQCOM<'a> {
    #[inline]
    pub fn fragment_density_offsets(mut self, fragment_density_offsets: &'a [Offset2D]) -> Self {
        self.fragment_density_offset_count = fragment_density_offsets.len() as _;
        self.p_fragment_density_offsets = fragment_density_offsets.as_ptr();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceScalarBlockLayoutFeatures.html>"]
pub struct PhysicalDeviceScalarBlockLayoutFeatures<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub scalar_block_layout: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceScalarBlockLayoutFeatures<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            scalar_block_layout: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceScalarBlockLayoutFeatures<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES;
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceScalarBlockLayoutFeatures<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceScalarBlockLayoutFeatures<'_> {}
impl<'a> PhysicalDeviceScalarBlockLayoutFeatures<'a> {
    #[inline]
    pub fn scalar_block_layout(mut self, scalar_block_layout: bool) -> Self {
        self.scalar_block_layout = scalar_block_layout.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSurfaceProtectedCapabilitiesKHR.html>"]
pub struct SurfaceProtectedCapabilitiesKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub supports_protected: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for SurfaceProtectedCapabilitiesKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            supports_protected: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for SurfaceProtectedCapabilitiesKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::SURFACE_PROTECTED_CAPABILITIES_KHR;
}
unsafe impl ExtendsSurfaceCapabilities2KHR for SurfaceProtectedCapabilitiesKHR<'_> {}
impl<'a> SurfaceProtectedCapabilitiesKHR<'a> {
    #[inline]
    pub fn supports_protected(mut self, supports_protected: bool) -> Self {
        self.supports_protected = supports_protected.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceUniformBufferStandardLayoutFeatures.html>"]
pub struct PhysicalDeviceUniformBufferStandardLayoutFeatures<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub uniform_buffer_standard_layout: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceUniformBufferStandardLayoutFeatures<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            uniform_buffer_standard_layout: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceUniformBufferStandardLayoutFeatures<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES;
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceUniformBufferStandardLayoutFeatures<'_>
{
}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceUniformBufferStandardLayoutFeatures<'_> {}
impl<'a> PhysicalDeviceUniformBufferStandardLayoutFeatures<'a> {
    #[inline]
    pub fn uniform_buffer_standard_layout(mut self, uniform_buffer_standard_layout: bool) -> Self {
        self.uniform_buffer_standard_layout = uniform_buffer_standard_layout.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDepthClipEnableFeaturesEXT.html>"]
pub struct PhysicalDeviceDepthClipEnableFeaturesEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub depth_clip_enable: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceDepthClipEnableFeaturesEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            depth_clip_enable: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceDepthClipEnableFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT;
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceDepthClipEnableFeaturesEXT<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceDepthClipEnableFeaturesEXT<'_> {}
impl<'a> PhysicalDeviceDepthClipEnableFeaturesEXT<'a> {
    #[inline]
    pub fn depth_clip_enable(mut self, depth_clip_enable: bool) -> Self {
        self.depth_clip_enable = depth_clip_enable.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineRasterizationDepthClipStateCreateInfoEXT.html>"]
pub struct PipelineRasterizationDepthClipStateCreateInfoEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: PipelineRasterizationDepthClipStateCreateFlagsEXT,
    pub depth_clip_enable: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PipelineRasterizationDepthClipStateCreateInfoEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: PipelineRasterizationDepthClipStateCreateFlagsEXT::default(),
            depth_clip_enable: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PipelineRasterizationDepthClipStateCreateInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT;
}
unsafe impl ExtendsPipelineRasterizationStateCreateInfo
    for PipelineRasterizationDepthClipStateCreateInfoEXT<'_>
{
}
impl<'a> PipelineRasterizationDepthClipStateCreateInfoEXT<'a> {
    #[inline]
    pub fn flags(mut self, flags: PipelineRasterizationDepthClipStateCreateFlagsEXT) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn depth_clip_enable(mut self, depth_clip_enable: bool) -> Self {
        self.depth_clip_enable = depth_clip_enable.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMemoryBudgetPropertiesEXT.html>"]
pub struct PhysicalDeviceMemoryBudgetPropertiesEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub heap_budget: [DeviceSize; MAX_MEMORY_HEAPS],
    pub heap_usage: [DeviceSize; MAX_MEMORY_HEAPS],
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceMemoryBudgetPropertiesEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            heap_budget: unsafe { ::std::mem::zeroed() },
            heap_usage: unsafe { ::std::mem::zeroed() },
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceMemoryBudgetPropertiesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT;
}
unsafe impl ExtendsPhysicalDeviceMemoryProperties2 for PhysicalDeviceMemoryBudgetPropertiesEXT<'_> {}
impl<'a> PhysicalDeviceMemoryBudgetPropertiesEXT<'a> {
    #[inline]
    pub fn heap_budget(mut self, heap_budget: [DeviceSize; MAX_MEMORY_HEAPS]) -> Self {
        self.heap_budget = heap_budget;
        self
    }
    #[inline]
    pub fn heap_usage(mut self, heap_usage: [DeviceSize; MAX_MEMORY_HEAPS]) -> Self {
        self.heap_usage = heap_usage;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMemoryPriorityFeaturesEXT.html>"]
pub struct PhysicalDeviceMemoryPriorityFeaturesEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub memory_priority: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceMemoryPriorityFeaturesEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            memory_priority: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceMemoryPriorityFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT;
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceMemoryPriorityFeaturesEXT<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceMemoryPriorityFeaturesEXT<'_> {}
impl<'a> PhysicalDeviceMemoryPriorityFeaturesEXT<'a> {
    #[inline]
    pub fn memory_priority(mut self, memory_priority: bool) -> Self {
        self.memory_priority = memory_priority.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryPriorityAllocateInfoEXT.html>"]
pub struct MemoryPriorityAllocateInfoEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub priority: f32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for MemoryPriorityAllocateInfoEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            priority: f32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for MemoryPriorityAllocateInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::MEMORY_PRIORITY_ALLOCATE_INFO_EXT;
}
unsafe impl ExtendsMemoryAllocateInfo for MemoryPriorityAllocateInfoEXT<'_> {}
impl<'a> MemoryPriorityAllocateInfoEXT<'a> {
    #[inline]
    pub fn priority(mut self, priority: f32) -> Self {
        self.priority = priority;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT.html>"]
pub struct PhysicalDevicePageableDeviceLocalMemoryFeaturesEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub pageable_device_local_memory: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDevicePageableDeviceLocalMemoryFeaturesEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            pageable_device_local_memory: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDevicePageableDeviceLocalMemoryFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT;
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDevicePageableDeviceLocalMemoryFeaturesEXT<'_>
{
}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDevicePageableDeviceLocalMemoryFeaturesEXT<'_> {}
impl<'a> PhysicalDevicePageableDeviceLocalMemoryFeaturesEXT<'a> {
    #[inline]
    pub fn pageable_device_local_memory(mut self, pageable_device_local_memory: bool) -> Self {
        self.pageable_device_local_memory = pageable_device_local_memory.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceBufferDeviceAddressFeatures.html>"]
pub struct PhysicalDeviceBufferDeviceAddressFeatures<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub buffer_device_address: Bool32,
    pub buffer_device_address_capture_replay: Bool32,
    pub buffer_device_address_multi_device: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceBufferDeviceAddressFeatures<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            buffer_device_address: Bool32::default(),
            buffer_device_address_capture_replay: Bool32::default(),
            buffer_device_address_multi_device: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceBufferDeviceAddressFeatures<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES;
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceBufferDeviceAddressFeatures<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceBufferDeviceAddressFeatures<'_> {}
impl<'a> PhysicalDeviceBufferDeviceAddressFeatures<'a> {
    #[inline]
    pub fn buffer_device_address(mut self, buffer_device_address: bool) -> Self {
        self.buffer_device_address = buffer_device_address.into();
        self
    }
    #[inline]
    pub fn buffer_device_address_capture_replay(
        mut self,
        buffer_device_address_capture_replay: bool,
    ) -> Self {
        self.buffer_device_address_capture_replay = buffer_device_address_capture_replay.into();
        self
    }
    #[inline]
    pub fn buffer_device_address_multi_device(
        mut self,
        buffer_device_address_multi_device: bool,
    ) -> Self {
        self.buffer_device_address_multi_device = buffer_device_address_multi_device.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceBufferDeviceAddressFeaturesEXT.html>"]
pub struct PhysicalDeviceBufferDeviceAddressFeaturesEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub buffer_device_address: Bool32,
    pub buffer_device_address_capture_replay: Bool32,
    pub buffer_device_address_multi_device: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceBufferDeviceAddressFeaturesEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            buffer_device_address: Bool32::default(),
            buffer_device_address_capture_replay: Bool32::default(),
            buffer_device_address_multi_device: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceBufferDeviceAddressFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT;
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceBufferDeviceAddressFeaturesEXT<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceBufferDeviceAddressFeaturesEXT<'_> {}
impl<'a> PhysicalDeviceBufferDeviceAddressFeaturesEXT<'a> {
    #[inline]
    pub fn buffer_device_address(mut self, buffer_device_address: bool) -> Self {
        self.buffer_device_address = buffer_device_address.into();
        self
    }
    #[inline]
    pub fn buffer_device_address_capture_replay(
        mut self,
        buffer_device_address_capture_replay: bool,
    ) -> Self {
        self.buffer_device_address_capture_replay = buffer_device_address_capture_replay.into();
        self
    }
    #[inline]
    pub fn buffer_device_address_multi_device(
        mut self,
        buffer_device_address_multi_device: bool,
    ) -> Self {
        self.buffer_device_address_multi_device = buffer_device_address_multi_device.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferDeviceAddressInfo.html>"]
pub struct BufferDeviceAddressInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub buffer: Buffer,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for BufferDeviceAddressInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            buffer: Buffer::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for BufferDeviceAddressInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::BUFFER_DEVICE_ADDRESS_INFO;
}
impl<'a> BufferDeviceAddressInfo<'a> {
    #[inline]
    pub fn buffer(mut self, buffer: Buffer) -> Self {
        self.buffer = buffer;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferOpaqueCaptureAddressCreateInfo.html>"]
pub struct BufferOpaqueCaptureAddressCreateInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub opaque_capture_address: u64,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for BufferOpaqueCaptureAddressCreateInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            opaque_capture_address: u64::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for BufferOpaqueCaptureAddressCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO;
}
unsafe impl ExtendsBufferCreateInfo for BufferOpaqueCaptureAddressCreateInfo<'_> {}
impl<'a> BufferOpaqueCaptureAddressCreateInfo<'a> {
    #[inline]
    pub fn opaque_capture_address(mut self, opaque_capture_address: u64) -> Self {
        self.opaque_capture_address = opaque_capture_address;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferDeviceAddressCreateInfoEXT.html>"]
pub struct BufferDeviceAddressCreateInfoEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub device_address: DeviceAddress,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for BufferDeviceAddressCreateInfoEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            device_address: DeviceAddress::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for BufferDeviceAddressCreateInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT;
}
unsafe impl ExtendsBufferCreateInfo for BufferDeviceAddressCreateInfoEXT<'_> {}
impl<'a> BufferDeviceAddressCreateInfoEXT<'a> {
    #[inline]
    pub fn device_address(mut self, device_address: DeviceAddress) -> Self {
        self.device_address = device_address;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceImageViewImageFormatInfoEXT.html>"]
pub struct PhysicalDeviceImageViewImageFormatInfoEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub image_view_type: ImageViewType,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceImageViewImageFormatInfoEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            image_view_type: ImageViewType::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceImageViewImageFormatInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT;
}
unsafe impl ExtendsPhysicalDeviceImageFormatInfo2
    for PhysicalDeviceImageViewImageFormatInfoEXT<'_>
{
}
impl<'a> PhysicalDeviceImageViewImageFormatInfoEXT<'a> {
    #[inline]
    pub fn image_view_type(mut self, image_view_type: ImageViewType) -> Self {
        self.image_view_type = image_view_type;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFilterCubicImageViewImageFormatPropertiesEXT.html>"]
pub struct FilterCubicImageViewImageFormatPropertiesEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub filter_cubic: Bool32,
    pub filter_cubic_minmax: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for FilterCubicImageViewImageFormatPropertiesEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            filter_cubic: Bool32::default(),
            filter_cubic_minmax: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for FilterCubicImageViewImageFormatPropertiesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT;
}
unsafe impl ExtendsImageFormatProperties2 for FilterCubicImageViewImageFormatPropertiesEXT<'_> {}
impl<'a> FilterCubicImageViewImageFormatPropertiesEXT<'a> {
    #[inline]
    pub fn filter_cubic(mut self, filter_cubic: bool) -> Self {
        self.filter_cubic = filter_cubic.into();
        self
    }
    #[inline]
    pub fn filter_cubic_minmax(mut self, filter_cubic_minmax: bool) -> Self {
        self.filter_cubic_minmax = filter_cubic_minmax.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceImagelessFramebufferFeatures.html>"]
pub struct PhysicalDeviceImagelessFramebufferFeatures<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub imageless_framebuffer: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceImagelessFramebufferFeatures<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            imageless_framebuffer: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceImagelessFramebufferFeatures<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES;
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceImagelessFramebufferFeatures<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceImagelessFramebufferFeatures<'_> {}
impl<'a> PhysicalDeviceImagelessFramebufferFeatures<'a> {
    #[inline]
    pub fn imageless_framebuffer(mut self, imageless_framebuffer: bool) -> Self {
        self.imageless_framebuffer = imageless_framebuffer.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFramebufferAttachmentsCreateInfo.html>"]
pub struct FramebufferAttachmentsCreateInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub attachment_image_info_count: u32,
    pub p_attachment_image_infos: *const FramebufferAttachmentImageInfo<'a>,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for FramebufferAttachmentsCreateInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            attachment_image_info_count: u32::default(),
            p_attachment_image_infos: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for FramebufferAttachmentsCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::FRAMEBUFFER_ATTACHMENTS_CREATE_INFO;
}
unsafe impl ExtendsFramebufferCreateInfo for FramebufferAttachmentsCreateInfo<'_> {}
impl<'a> FramebufferAttachmentsCreateInfo<'a> {
    #[inline]
    pub fn attachment_image_infos(
        mut self,
        attachment_image_infos: &'a [FramebufferAttachmentImageInfo],
    ) -> Self {
        self.attachment_image_info_count = attachment_image_infos.len() as _;
        self.p_attachment_image_infos = attachment_image_infos.as_ptr();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFramebufferAttachmentImageInfo.html>"]
pub struct FramebufferAttachmentImageInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: ImageCreateFlags,
    pub usage: ImageUsageFlags,
    pub width: u32,
    pub height: u32,
    pub layer_count: u32,
    pub view_format_count: u32,
    pub p_view_formats: *const Format,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for FramebufferAttachmentImageInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: ImageCreateFlags::default(),
            usage: ImageUsageFlags::default(),
            width: u32::default(),
            height: u32::default(),
            layer_count: u32::default(),
            view_format_count: u32::default(),
            p_view_formats: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for FramebufferAttachmentImageInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::FRAMEBUFFER_ATTACHMENT_IMAGE_INFO;
}
impl<'a> FramebufferAttachmentImageInfo<'a> {
    #[inline]
    pub fn flags(mut self, flags: ImageCreateFlags) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn usage(mut self, usage: ImageUsageFlags) -> Self {
        self.usage = usage;
        self
    }
    #[inline]
    pub fn width(mut self, width: u32) -> Self {
        self.width = width;
        self
    }
    #[inline]
    pub fn height(mut self, height: u32) -> Self {
        self.height = height;
        self
    }
    #[inline]
    pub fn layer_count(mut self, layer_count: u32) -> Self {
        self.layer_count = layer_count;
        self
    }
    #[inline]
    pub fn view_formats(mut self, view_formats: &'a [Format]) -> Self {
        self.view_format_count = view_formats.len() as _;
        self.p_view_formats = view_formats.as_ptr();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderPassAttachmentBeginInfo.html>"]
pub struct RenderPassAttachmentBeginInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub attachment_count: u32,
    pub p_attachments: *const ImageView,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for RenderPassAttachmentBeginInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            attachment_count: u32::default(),
            p_attachments: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for RenderPassAttachmentBeginInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::RENDER_PASS_ATTACHMENT_BEGIN_INFO;
}
unsafe impl ExtendsRenderPassBeginInfo for RenderPassAttachmentBeginInfo<'_> {}
impl<'a> RenderPassAttachmentBeginInfo<'a> {
    #[inline]
    pub fn attachments(mut self, attachments: &'a [ImageView]) -> Self {
        self.attachment_count = attachments.len() as _;
        self.p_attachments = attachments.as_ptr();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceTextureCompressionASTCHDRFeatures.html>"]
pub struct PhysicalDeviceTextureCompressionASTCHDRFeatures<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub texture_compression_astc_hdr: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceTextureCompressionASTCHDRFeatures<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            texture_compression_astc_hdr: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceTextureCompressionASTCHDRFeatures<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES;
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceTextureCompressionASTCHDRFeatures<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceTextureCompressionASTCHDRFeatures<'_> {}
impl<'a> PhysicalDeviceTextureCompressionASTCHDRFeatures<'a> {
    #[inline]
    pub fn texture_compression_astc_hdr(mut self, texture_compression_astc_hdr: bool) -> Self {
        self.texture_compression_astc_hdr = texture_compression_astc_hdr.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceCooperativeMatrixFeaturesNV.html>"]
pub struct PhysicalDeviceCooperativeMatrixFeaturesNV<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub cooperative_matrix: Bool32,
    pub cooperative_matrix_robust_buffer_access: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceCooperativeMatrixFeaturesNV<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            cooperative_matrix: Bool32::default(),
            cooperative_matrix_robust_buffer_access: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceCooperativeMatrixFeaturesNV<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV;
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceCooperativeMatrixFeaturesNV<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceCooperativeMatrixFeaturesNV<'_> {}
impl<'a> PhysicalDeviceCooperativeMatrixFeaturesNV<'a> {
    #[inline]
    pub fn cooperative_matrix(mut self, cooperative_matrix: bool) -> Self {
        self.cooperative_matrix = cooperative_matrix.into();
        self
    }
    #[inline]
    pub fn cooperative_matrix_robust_buffer_access(
        mut self,
        cooperative_matrix_robust_buffer_access: bool,
    ) -> Self {
        self.cooperative_matrix_robust_buffer_access =
            cooperative_matrix_robust_buffer_access.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceCooperativeMatrixPropertiesNV.html>"]
pub struct PhysicalDeviceCooperativeMatrixPropertiesNV<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub cooperative_matrix_supported_stages: ShaderStageFlags,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceCooperativeMatrixPropertiesNV<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            cooperative_matrix_supported_stages: ShaderStageFlags::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceCooperativeMatrixPropertiesNV<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV;
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceCooperativeMatrixPropertiesNV<'_> {}
impl<'a> PhysicalDeviceCooperativeMatrixPropertiesNV<'a> {
    #[inline]
    pub fn cooperative_matrix_supported_stages(
        mut self,
        cooperative_matrix_supported_stages: ShaderStageFlags,
    ) -> Self {
        self.cooperative_matrix_supported_stages = cooperative_matrix_supported_stages;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCooperativeMatrixPropertiesNV.html>"]
pub struct CooperativeMatrixPropertiesNV<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub m_size: u32,
    pub n_size: u32,
    pub k_size: u32,
    pub a_type: ComponentTypeNV,
    pub b_type: ComponentTypeNV,
    pub c_type: ComponentTypeNV,
    pub d_type: ComponentTypeNV,
    pub scope: ScopeNV,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for CooperativeMatrixPropertiesNV<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            m_size: u32::default(),
            n_size: u32::default(),
            k_size: u32::default(),
            a_type: ComponentTypeNV::default(),
            b_type: ComponentTypeNV::default(),
            c_type: ComponentTypeNV::default(),
            d_type: ComponentTypeNV::default(),
            scope: ScopeNV::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for CooperativeMatrixPropertiesNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::COOPERATIVE_MATRIX_PROPERTIES_NV;
}
impl<'a> CooperativeMatrixPropertiesNV<'a> {
    #[inline]
    pub fn m_size(mut self, m_size: u32) -> Self {
        self.m_size = m_size;
        self
    }
    #[inline]
    pub fn n_size(mut self, n_size: u32) -> Self {
        self.n_size = n_size;
        self
    }
    #[inline]
    pub fn k_size(mut self, k_size: u32) -> Self {
        self.k_size = k_size;
        self
    }
    #[inline]
    pub fn a_type(mut self, a_type: ComponentTypeNV) -> Self {
        self.a_type = a_type;
        self
    }
    #[inline]
    pub fn b_type(mut self, b_type: ComponentTypeNV) -> Self {
        self.b_type = b_type;
        self
    }
    #[inline]
    pub fn c_type(mut self, c_type: ComponentTypeNV) -> Self {
        self.c_type = c_type;
        self
    }
    #[inline]
    pub fn d_type(mut self, d_type: ComponentTypeNV) -> Self {
        self.d_type = d_type;
        self
    }
    #[inline]
    pub fn scope(mut self, scope: ScopeNV) -> Self {
        self.scope = scope;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceYcbcrImageArraysFeaturesEXT.html>"]
pub struct PhysicalDeviceYcbcrImageArraysFeaturesEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub ycbcr_image_arrays: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceYcbcrImageArraysFeaturesEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            ycbcr_image_arrays: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceYcbcrImageArraysFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT;
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceYcbcrImageArraysFeaturesEXT<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceYcbcrImageArraysFeaturesEXT<'_> {}
impl<'a> PhysicalDeviceYcbcrImageArraysFeaturesEXT<'a> {
    #[inline]
    pub fn ycbcr_image_arrays(mut self, ycbcr_image_arrays: bool) -> Self {
        self.ycbcr_image_arrays = ycbcr_image_arrays.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageViewHandleInfoNVX.html>"]
pub struct ImageViewHandleInfoNVX<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub image_view: ImageView,
    pub descriptor_type: DescriptorType,
    pub sampler: Sampler,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for ImageViewHandleInfoNVX<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            image_view: ImageView::default(),
            descriptor_type: DescriptorType::default(),
            sampler: Sampler::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for ImageViewHandleInfoNVX<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::IMAGE_VIEW_HANDLE_INFO_NVX;
}
impl<'a> ImageViewHandleInfoNVX<'a> {
    #[inline]
    pub fn image_view(mut self, image_view: ImageView) -> Self {
        self.image_view = image_view;
        self
    }
    #[inline]
    pub fn descriptor_type(mut self, descriptor_type: DescriptorType) -> Self {
        self.descriptor_type = descriptor_type;
        self
    }
    #[inline]
    pub fn sampler(mut self, sampler: Sampler) -> Self {
        self.sampler = sampler;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageViewAddressPropertiesNVX.html>"]
pub struct ImageViewAddressPropertiesNVX<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub device_address: DeviceAddress,
    pub size: DeviceSize,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for ImageViewAddressPropertiesNVX<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            device_address: DeviceAddress::default(),
            size: DeviceSize::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for ImageViewAddressPropertiesNVX<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::IMAGE_VIEW_ADDRESS_PROPERTIES_NVX;
}
impl<'a> ImageViewAddressPropertiesNVX<'a> {
    #[inline]
    pub fn device_address(mut self, device_address: DeviceAddress) -> Self {
        self.device_address = device_address;
        self
    }
    #[inline]
    pub fn size(mut self, size: DeviceSize) -> Self {
        self.size = size;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPresentFrameTokenGGP.html>"]
pub struct PresentFrameTokenGGP<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub frame_token: GgpFrameToken,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PresentFrameTokenGGP<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            frame_token: GgpFrameToken::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PresentFrameTokenGGP<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PRESENT_FRAME_TOKEN_GGP;
}
unsafe impl ExtendsPresentInfoKHR for PresentFrameTokenGGP<'_> {}
impl<'a> PresentFrameTokenGGP<'a> {
    #[inline]
    pub fn frame_token(mut self, frame_token: GgpFrameToken) -> Self {
        self.frame_token = frame_token;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineCreationFeedback.html>"]
pub struct PipelineCreationFeedback {
    pub flags: PipelineCreationFeedbackFlags,
    pub duration: u64,
}
impl PipelineCreationFeedback {
    #[inline]
    pub fn flags(mut self, flags: PipelineCreationFeedbackFlags) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn duration(mut self, duration: u64) -> Self {
        self.duration = duration;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineCreationFeedbackCreateInfo.html>"]
pub struct PipelineCreationFeedbackCreateInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub p_pipeline_creation_feedback: *mut PipelineCreationFeedback,
    pub pipeline_stage_creation_feedback_count: u32,
    pub p_pipeline_stage_creation_feedbacks: *mut PipelineCreationFeedback,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PipelineCreationFeedbackCreateInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            p_pipeline_creation_feedback: ::std::ptr::null_mut(),
            pipeline_stage_creation_feedback_count: u32::default(),
            p_pipeline_stage_creation_feedbacks: ::std::ptr::null_mut(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PipelineCreationFeedbackCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PIPELINE_CREATION_FEEDBACK_CREATE_INFO;
}
unsafe impl ExtendsGraphicsPipelineCreateInfo for PipelineCreationFeedbackCreateInfo<'_> {}
unsafe impl ExtendsComputePipelineCreateInfo for PipelineCreationFeedbackCreateInfo<'_> {}
unsafe impl ExtendsRayTracingPipelineCreateInfoNV for PipelineCreationFeedbackCreateInfo<'_> {}
unsafe impl ExtendsRayTracingPipelineCreateInfoKHR for PipelineCreationFeedbackCreateInfo<'_> {}
impl<'a> PipelineCreationFeedbackCreateInfo<'a> {
    #[inline]
    pub fn pipeline_creation_feedback(
        mut self,
        pipeline_creation_feedback: &'a mut PipelineCreationFeedback,
    ) -> Self {
        self.p_pipeline_creation_feedback = pipeline_creation_feedback;
        self
    }
    #[inline]
    pub fn pipeline_stage_creation_feedbacks(
        mut self,
        pipeline_stage_creation_feedbacks: &'a mut [PipelineCreationFeedback],
    ) -> Self {
        self.pipeline_stage_creation_feedback_count = pipeline_stage_creation_feedbacks.len() as _;
        self.p_pipeline_stage_creation_feedbacks = pipeline_stage_creation_feedbacks.as_mut_ptr();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSurfaceFullScreenExclusiveInfoEXT.html>"]
pub struct SurfaceFullScreenExclusiveInfoEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub full_screen_exclusive: FullScreenExclusiveEXT,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for SurfaceFullScreenExclusiveInfoEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            full_screen_exclusive: FullScreenExclusiveEXT::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for SurfaceFullScreenExclusiveInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT;
}
unsafe impl ExtendsPhysicalDeviceSurfaceInfo2KHR for SurfaceFullScreenExclusiveInfoEXT<'_> {}
unsafe impl ExtendsSwapchainCreateInfoKHR for SurfaceFullScreenExclusiveInfoEXT<'_> {}
impl<'a> SurfaceFullScreenExclusiveInfoEXT<'a> {
    #[inline]
    pub fn full_screen_exclusive(mut self, full_screen_exclusive: FullScreenExclusiveEXT) -> Self {
        self.full_screen_exclusive = full_screen_exclusive;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSurfaceFullScreenExclusiveWin32InfoEXT.html>"]
pub struct SurfaceFullScreenExclusiveWin32InfoEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub hmonitor: HMONITOR,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for SurfaceFullScreenExclusiveWin32InfoEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            hmonitor: unsafe { ::std::mem::zeroed() },
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for SurfaceFullScreenExclusiveWin32InfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT;
}
unsafe impl ExtendsPhysicalDeviceSurfaceInfo2KHR for SurfaceFullScreenExclusiveWin32InfoEXT<'_> {}
unsafe impl ExtendsSwapchainCreateInfoKHR for SurfaceFullScreenExclusiveWin32InfoEXT<'_> {}
impl<'a> SurfaceFullScreenExclusiveWin32InfoEXT<'a> {
    #[inline]
    pub fn hmonitor(mut self, hmonitor: HMONITOR) -> Self {
        self.hmonitor = hmonitor;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSurfaceCapabilitiesFullScreenExclusiveEXT.html>"]
pub struct SurfaceCapabilitiesFullScreenExclusiveEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub full_screen_exclusive_supported: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for SurfaceCapabilitiesFullScreenExclusiveEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            full_screen_exclusive_supported: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for SurfaceCapabilitiesFullScreenExclusiveEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT;
}
unsafe impl ExtendsSurfaceCapabilities2KHR for SurfaceCapabilitiesFullScreenExclusiveEXT<'_> {}
impl<'a> SurfaceCapabilitiesFullScreenExclusiveEXT<'a> {
    #[inline]
    pub fn full_screen_exclusive_supported(
        mut self,
        full_screen_exclusive_supported: bool,
    ) -> Self {
        self.full_screen_exclusive_supported = full_screen_exclusive_supported.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePerformanceQueryFeaturesKHR.html>"]
pub struct PhysicalDevicePerformanceQueryFeaturesKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub performance_counter_query_pools: Bool32,
    pub performance_counter_multiple_query_pools: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDevicePerformanceQueryFeaturesKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            performance_counter_query_pools: Bool32::default(),
            performance_counter_multiple_query_pools: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDevicePerformanceQueryFeaturesKHR<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR;
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDevicePerformanceQueryFeaturesKHR<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDevicePerformanceQueryFeaturesKHR<'_> {}
impl<'a> PhysicalDevicePerformanceQueryFeaturesKHR<'a> {
    #[inline]
    pub fn performance_counter_query_pools(
        mut self,
        performance_counter_query_pools: bool,
    ) -> Self {
        self.performance_counter_query_pools = performance_counter_query_pools.into();
        self
    }
    #[inline]
    pub fn performance_counter_multiple_query_pools(
        mut self,
        performance_counter_multiple_query_pools: bool,
    ) -> Self {
        self.performance_counter_multiple_query_pools =
            performance_counter_multiple_query_pools.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePerformanceQueryPropertiesKHR.html>"]
pub struct PhysicalDevicePerformanceQueryPropertiesKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub allow_command_buffer_query_copies: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDevicePerformanceQueryPropertiesKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            allow_command_buffer_query_copies: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDevicePerformanceQueryPropertiesKHR<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR;
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDevicePerformanceQueryPropertiesKHR<'_> {}
impl<'a> PhysicalDevicePerformanceQueryPropertiesKHR<'a> {
    #[inline]
    pub fn allow_command_buffer_query_copies(
        mut self,
        allow_command_buffer_query_copies: bool,
    ) -> Self {
        self.allow_command_buffer_query_copies = allow_command_buffer_query_copies.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPerformanceCounterKHR.html>"]
pub struct PerformanceCounterKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub unit: PerformanceCounterUnitKHR,
    pub scope: PerformanceCounterScopeKHR,
    pub storage: PerformanceCounterStorageKHR,
    pub uuid: [u8; UUID_SIZE],
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PerformanceCounterKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            unit: PerformanceCounterUnitKHR::default(),
            scope: PerformanceCounterScopeKHR::default(),
            storage: PerformanceCounterStorageKHR::default(),
            uuid: unsafe { ::std::mem::zeroed() },
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PerformanceCounterKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PERFORMANCE_COUNTER_KHR;
}
impl<'a> PerformanceCounterKHR<'a> {
    #[inline]
    pub fn unit(mut self, unit: PerformanceCounterUnitKHR) -> Self {
        self.unit = unit;
        self
    }
    #[inline]
    pub fn scope(mut self, scope: PerformanceCounterScopeKHR) -> Self {
        self.scope = scope;
        self
    }
    #[inline]
    pub fn storage(mut self, storage: PerformanceCounterStorageKHR) -> Self {
        self.storage = storage;
        self
    }
    #[inline]
    pub fn uuid(mut self, uuid: [u8; UUID_SIZE]) -> Self {
        self.uuid = uuid;
        self
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPerformanceCounterDescriptionKHR.html>"]
pub struct PerformanceCounterDescriptionKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub flags: PerformanceCounterDescriptionFlagsKHR,
    pub name: [c_char; MAX_DESCRIPTION_SIZE],
    pub category: [c_char; MAX_DESCRIPTION_SIZE],
    pub description: [c_char; MAX_DESCRIPTION_SIZE],
    pub _marker: PhantomData<&'a ()>,
}
#[cfg(feature = "debug")]
impl fmt::Debug for PerformanceCounterDescriptionKHR<'_> {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PerformanceCounterDescriptionKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("name", &unsafe {
                ::std::ffi::CStr::from_ptr(self.name.as_ptr())
            })
            .field("category", &unsafe {
                ::std::ffi::CStr::from_ptr(self.category.as_ptr())
            })
            .field("description", &unsafe {
                ::std::ffi::CStr::from_ptr(self.description.as_ptr())
            })
            .finish()
    }
}
impl ::std::default::Default for PerformanceCounterDescriptionKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            flags: PerformanceCounterDescriptionFlagsKHR::default(),
            name: unsafe { ::std::mem::zeroed() },
            category: unsafe { ::std::mem::zeroed() },
            description: unsafe { ::std::mem::zeroed() },
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PerformanceCounterDescriptionKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PERFORMANCE_COUNTER_DESCRIPTION_KHR;
}
impl<'a> PerformanceCounterDescriptionKHR<'a> {
    #[inline]
    pub fn flags(mut self, flags: PerformanceCounterDescriptionFlagsKHR) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn name(mut self, name: [c_char; MAX_DESCRIPTION_SIZE]) -> Self {
        self.name = name;
        self
    }
    #[inline]
    pub fn category(mut self, category: [c_char; MAX_DESCRIPTION_SIZE]) -> Self {
        self.category = category;
        self
    }
    #[inline]
    pub fn description(mut self, description: [c_char; MAX_DESCRIPTION_SIZE]) -> Self {
        self.description = description;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkQueryPoolPerformanceCreateInfoKHR.html>"]
pub struct QueryPoolPerformanceCreateInfoKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub queue_family_index: u32,
    pub counter_index_count: u32,
    pub p_counter_indices: *const u32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for QueryPoolPerformanceCreateInfoKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            queue_family_index: u32::default(),
            counter_index_count: u32::default(),
            p_counter_indices: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for QueryPoolPerformanceCreateInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR;
}
unsafe impl ExtendsQueryPoolCreateInfo for QueryPoolPerformanceCreateInfoKHR<'_> {}
impl<'a> QueryPoolPerformanceCreateInfoKHR<'a> {
    #[inline]
    pub fn queue_family_index(mut self, queue_family_index: u32) -> Self {
        self.queue_family_index = queue_family_index;
        self
    }
    #[inline]
    pub fn counter_indices(mut self, counter_indices: &'a [u32]) -> Self {
        self.counter_index_count = counter_indices.len() as _;
        self.p_counter_indices = counter_indices.as_ptr();
        self
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPerformanceCounterResultKHR.html>"]
pub union PerformanceCounterResultKHR {
    pub int32: i32,
    pub int64: i64,
    pub uint32: u32,
    pub uint64: u64,
    pub float32: f32,
    pub float64: f64,
}
impl ::std::default::Default for PerformanceCounterResultKHR {
    #[inline]
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAcquireProfilingLockInfoKHR.html>"]
pub struct AcquireProfilingLockInfoKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: AcquireProfilingLockFlagsKHR,
    pub timeout: u64,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for AcquireProfilingLockInfoKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: AcquireProfilingLockFlagsKHR::default(),
            timeout: u64::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for AcquireProfilingLockInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ACQUIRE_PROFILING_LOCK_INFO_KHR;
}
impl<'a> AcquireProfilingLockInfoKHR<'a> {
    #[inline]
    pub fn flags(mut self, flags: AcquireProfilingLockFlagsKHR) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn timeout(mut self, timeout: u64) -> Self {
        self.timeout = timeout;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPerformanceQuerySubmitInfoKHR.html>"]
pub struct PerformanceQuerySubmitInfoKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub counter_pass_index: u32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PerformanceQuerySubmitInfoKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            counter_pass_index: u32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PerformanceQuerySubmitInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PERFORMANCE_QUERY_SUBMIT_INFO_KHR;
}
unsafe impl ExtendsSubmitInfo for PerformanceQuerySubmitInfoKHR<'_> {}
unsafe impl ExtendsSubmitInfo2 for PerformanceQuerySubmitInfoKHR<'_> {}
impl<'a> PerformanceQuerySubmitInfoKHR<'a> {
    #[inline]
    pub fn counter_pass_index(mut self, counter_pass_index: u32) -> Self {
        self.counter_pass_index = counter_pass_index;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkHeadlessSurfaceCreateInfoEXT.html>"]
pub struct HeadlessSurfaceCreateInfoEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: HeadlessSurfaceCreateFlagsEXT,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for HeadlessSurfaceCreateInfoEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: HeadlessSurfaceCreateFlagsEXT::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for HeadlessSurfaceCreateInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::HEADLESS_SURFACE_CREATE_INFO_EXT;
}
impl<'a> HeadlessSurfaceCreateInfoEXT<'a> {
    #[inline]
    pub fn flags(mut self, flags: HeadlessSurfaceCreateFlagsEXT) -> Self {
        self.flags = flags;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceCoverageReductionModeFeaturesNV.html>"]
pub struct PhysicalDeviceCoverageReductionModeFeaturesNV<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub coverage_reduction_mode: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceCoverageReductionModeFeaturesNV<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            coverage_reduction_mode: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceCoverageReductionModeFeaturesNV<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV;
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceCoverageReductionModeFeaturesNV<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceCoverageReductionModeFeaturesNV<'_> {}
impl<'a> PhysicalDeviceCoverageReductionModeFeaturesNV<'a> {
    #[inline]
    pub fn coverage_reduction_mode(mut self, coverage_reduction_mode: bool) -> Self {
        self.coverage_reduction_mode = coverage_reduction_mode.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineCoverageReductionStateCreateInfoNV.html>"]
pub struct PipelineCoverageReductionStateCreateInfoNV<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: PipelineCoverageReductionStateCreateFlagsNV,
    pub coverage_reduction_mode: CoverageReductionModeNV,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PipelineCoverageReductionStateCreateInfoNV<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: PipelineCoverageReductionStateCreateFlagsNV::default(),
            coverage_reduction_mode: CoverageReductionModeNV::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PipelineCoverageReductionStateCreateInfoNV<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV;
}
unsafe impl ExtendsPipelineMultisampleStateCreateInfo
    for PipelineCoverageReductionStateCreateInfoNV<'_>
{
}
impl<'a> PipelineCoverageReductionStateCreateInfoNV<'a> {
    #[inline]
    pub fn flags(mut self, flags: PipelineCoverageReductionStateCreateFlagsNV) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn coverage_reduction_mode(
        mut self,
        coverage_reduction_mode: CoverageReductionModeNV,
    ) -> Self {
        self.coverage_reduction_mode = coverage_reduction_mode;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFramebufferMixedSamplesCombinationNV.html>"]
pub struct FramebufferMixedSamplesCombinationNV<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub coverage_reduction_mode: CoverageReductionModeNV,
    pub rasterization_samples: SampleCountFlags,
    pub depth_stencil_samples: SampleCountFlags,
    pub color_samples: SampleCountFlags,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for FramebufferMixedSamplesCombinationNV<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            coverage_reduction_mode: CoverageReductionModeNV::default(),
            rasterization_samples: SampleCountFlags::default(),
            depth_stencil_samples: SampleCountFlags::default(),
            color_samples: SampleCountFlags::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for FramebufferMixedSamplesCombinationNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV;
}
impl<'a> FramebufferMixedSamplesCombinationNV<'a> {
    #[inline]
    pub fn coverage_reduction_mode(
        mut self,
        coverage_reduction_mode: CoverageReductionModeNV,
    ) -> Self {
        self.coverage_reduction_mode = coverage_reduction_mode;
        self
    }
    #[inline]
    pub fn rasterization_samples(mut self, rasterization_samples: SampleCountFlags) -> Self {
        self.rasterization_samples = rasterization_samples;
        self
    }
    #[inline]
    pub fn depth_stencil_samples(mut self, depth_stencil_samples: SampleCountFlags) -> Self {
        self.depth_stencil_samples = depth_stencil_samples;
        self
    }
    #[inline]
    pub fn color_samples(mut self, color_samples: SampleCountFlags) -> Self {
        self.color_samples = color_samples;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL.html>"]
pub struct PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shader_integer_functions2: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            shader_integer_functions2: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL;
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL<'_>
{
}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL<'_> {}
impl<'a> PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL<'a> {
    #[inline]
    pub fn shader_integer_functions2(mut self, shader_integer_functions2: bool) -> Self {
        self.shader_integer_functions2 = shader_integer_functions2.into();
        self
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPerformanceValueDataINTEL.html>"]
pub union PerformanceValueDataINTEL {
    pub value32: u32,
    pub value64: u64,
    pub value_float: f32,
    pub value_bool: Bool32,
    pub value_string: *const c_char,
}
impl ::std::default::Default for PerformanceValueDataINTEL {
    #[inline]
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPerformanceValueINTEL.html>"]
pub struct PerformanceValueINTEL {
    pub ty: PerformanceValueTypeINTEL,
    pub data: PerformanceValueDataINTEL,
}
#[cfg(feature = "debug")]
impl fmt::Debug for PerformanceValueINTEL {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PerformanceValueINTEL")
            .field("ty", &self.ty)
            .field("data", &"union")
            .finish()
    }
}
impl PerformanceValueINTEL {
    #[inline]
    pub fn ty(mut self, ty: PerformanceValueTypeINTEL) -> Self {
        self.ty = ty;
        self
    }
    #[inline]
    pub fn data(mut self, data: PerformanceValueDataINTEL) -> Self {
        self.data = data;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkInitializePerformanceApiInfoINTEL.html>"]
pub struct InitializePerformanceApiInfoINTEL<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub p_user_data: *mut c_void,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for InitializePerformanceApiInfoINTEL<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            p_user_data: ::std::ptr::null_mut(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for InitializePerformanceApiInfoINTEL<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::INITIALIZE_PERFORMANCE_API_INFO_INTEL;
}
impl<'a> InitializePerformanceApiInfoINTEL<'a> {
    #[inline]
    pub fn user_data(mut self, user_data: *mut c_void) -> Self {
        self.p_user_data = user_data;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkQueryPoolPerformanceQueryCreateInfoINTEL.html>"]
pub struct QueryPoolPerformanceQueryCreateInfoINTEL<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub performance_counters_sampling: QueryPoolSamplingModeINTEL,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for QueryPoolPerformanceQueryCreateInfoINTEL<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            performance_counters_sampling: QueryPoolSamplingModeINTEL::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for QueryPoolPerformanceQueryCreateInfoINTEL<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL;
}
unsafe impl ExtendsQueryPoolCreateInfo for QueryPoolPerformanceQueryCreateInfoINTEL<'_> {}
impl<'a> QueryPoolPerformanceQueryCreateInfoINTEL<'a> {
    #[inline]
    pub fn performance_counters_sampling(
        mut self,
        performance_counters_sampling: QueryPoolSamplingModeINTEL,
    ) -> Self {
        self.performance_counters_sampling = performance_counters_sampling;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPerformanceMarkerInfoINTEL.html>"]
pub struct PerformanceMarkerInfoINTEL<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub marker: u64,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PerformanceMarkerInfoINTEL<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            marker: u64::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PerformanceMarkerInfoINTEL<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PERFORMANCE_MARKER_INFO_INTEL;
}
impl<'a> PerformanceMarkerInfoINTEL<'a> {
    #[inline]
    pub fn marker(mut self, marker: u64) -> Self {
        self.marker = marker;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPerformanceStreamMarkerInfoINTEL.html>"]
pub struct PerformanceStreamMarkerInfoINTEL<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub marker: u32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PerformanceStreamMarkerInfoINTEL<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            marker: u32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PerformanceStreamMarkerInfoINTEL<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PERFORMANCE_STREAM_MARKER_INFO_INTEL;
}
impl<'a> PerformanceStreamMarkerInfoINTEL<'a> {
    #[inline]
    pub fn marker(mut self, marker: u32) -> Self {
        self.marker = marker;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPerformanceOverrideInfoINTEL.html>"]
pub struct PerformanceOverrideInfoINTEL<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub ty: PerformanceOverrideTypeINTEL,
    pub enable: Bool32,
    pub parameter: u64,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PerformanceOverrideInfoINTEL<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            ty: PerformanceOverrideTypeINTEL::default(),
            enable: Bool32::default(),
            parameter: u64::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PerformanceOverrideInfoINTEL<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PERFORMANCE_OVERRIDE_INFO_INTEL;
}
impl<'a> PerformanceOverrideInfoINTEL<'a> {
    #[inline]
    pub fn ty(mut self, ty: PerformanceOverrideTypeINTEL) -> Self {
        self.ty = ty;
        self
    }
    #[inline]
    pub fn enable(mut self, enable: bool) -> Self {
        self.enable = enable.into();
        self
    }
    #[inline]
    pub fn parameter(mut self, parameter: u64) -> Self {
        self.parameter = parameter;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPerformanceConfigurationAcquireInfoINTEL.html>"]
pub struct PerformanceConfigurationAcquireInfoINTEL<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub ty: PerformanceConfigurationTypeINTEL,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PerformanceConfigurationAcquireInfoINTEL<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            ty: PerformanceConfigurationTypeINTEL::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PerformanceConfigurationAcquireInfoINTEL<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL;
}
impl<'a> PerformanceConfigurationAcquireInfoINTEL<'a> {
    #[inline]
    pub fn ty(mut self, ty: PerformanceConfigurationTypeINTEL) -> Self {
        self.ty = ty;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderClockFeaturesKHR.html>"]
pub struct PhysicalDeviceShaderClockFeaturesKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shader_subgroup_clock: Bool32,
    pub shader_device_clock: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceShaderClockFeaturesKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            shader_subgroup_clock: Bool32::default(),
            shader_device_clock: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceShaderClockFeaturesKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR;
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceShaderClockFeaturesKHR<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceShaderClockFeaturesKHR<'_> {}
impl<'a> PhysicalDeviceShaderClockFeaturesKHR<'a> {
    #[inline]
    pub fn shader_subgroup_clock(mut self, shader_subgroup_clock: bool) -> Self {
        self.shader_subgroup_clock = shader_subgroup_clock.into();
        self
    }
    #[inline]
    pub fn shader_device_clock(mut self, shader_device_clock: bool) -> Self {
        self.shader_device_clock = shader_device_clock.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceIndexTypeUint8FeaturesEXT.html>"]
pub struct PhysicalDeviceIndexTypeUint8FeaturesEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub index_type_uint8: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceIndexTypeUint8FeaturesEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            index_type_uint8: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceIndexTypeUint8FeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT;
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceIndexTypeUint8FeaturesEXT<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceIndexTypeUint8FeaturesEXT<'_> {}
impl<'a> PhysicalDeviceIndexTypeUint8FeaturesEXT<'a> {
    #[inline]
    pub fn index_type_uint8(mut self, index_type_uint8: bool) -> Self {
        self.index_type_uint8 = index_type_uint8.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderSMBuiltinsPropertiesNV.html>"]
pub struct PhysicalDeviceShaderSMBuiltinsPropertiesNV<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shader_sm_count: u32,
    pub shader_warps_per_sm: u32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceShaderSMBuiltinsPropertiesNV<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            shader_sm_count: u32::default(),
            shader_warps_per_sm: u32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceShaderSMBuiltinsPropertiesNV<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV;
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceShaderSMBuiltinsPropertiesNV<'_> {}
impl<'a> PhysicalDeviceShaderSMBuiltinsPropertiesNV<'a> {
    #[inline]
    pub fn shader_sm_count(mut self, shader_sm_count: u32) -> Self {
        self.shader_sm_count = shader_sm_count;
        self
    }
    #[inline]
    pub fn shader_warps_per_sm(mut self, shader_warps_per_sm: u32) -> Self {
        self.shader_warps_per_sm = shader_warps_per_sm;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderSMBuiltinsFeaturesNV.html>"]
pub struct PhysicalDeviceShaderSMBuiltinsFeaturesNV<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shader_sm_builtins: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceShaderSMBuiltinsFeaturesNV<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            shader_sm_builtins: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceShaderSMBuiltinsFeaturesNV<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV;
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceShaderSMBuiltinsFeaturesNV<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceShaderSMBuiltinsFeaturesNV<'_> {}
impl<'a> PhysicalDeviceShaderSMBuiltinsFeaturesNV<'a> {
    #[inline]
    pub fn shader_sm_builtins(mut self, shader_sm_builtins: bool) -> Self {
        self.shader_sm_builtins = shader_sm_builtins.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT.html>"]
pub struct PhysicalDeviceFragmentShaderInterlockFeaturesEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub fragment_shader_sample_interlock: Bool32,
    pub fragment_shader_pixel_interlock: Bool32,
    pub fragment_shader_shading_rate_interlock: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceFragmentShaderInterlockFeaturesEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            fragment_shader_sample_interlock: Bool32::default(),
            fragment_shader_pixel_interlock: Bool32::default(),
            fragment_shader_shading_rate_interlock: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceFragmentShaderInterlockFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT;
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceFragmentShaderInterlockFeaturesEXT<'_>
{
}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceFragmentShaderInterlockFeaturesEXT<'_> {}
impl<'a> PhysicalDeviceFragmentShaderInterlockFeaturesEXT<'a> {
    #[inline]
    pub fn fragment_shader_sample_interlock(
        mut self,
        fragment_shader_sample_interlock: bool,
    ) -> Self {
        self.fragment_shader_sample_interlock = fragment_shader_sample_interlock.into();
        self
    }
    #[inline]
    pub fn fragment_shader_pixel_interlock(
        mut self,
        fragment_shader_pixel_interlock: bool,
    ) -> Self {
        self.fragment_shader_pixel_interlock = fragment_shader_pixel_interlock.into();
        self
    }
    #[inline]
    pub fn fragment_shader_shading_rate_interlock(
        mut self,
        fragment_shader_shading_rate_interlock: bool,
    ) -> Self {
        self.fragment_shader_shading_rate_interlock = fragment_shader_shading_rate_interlock.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures.html>"]
pub struct PhysicalDeviceSeparateDepthStencilLayoutsFeatures<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub separate_depth_stencil_layouts: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceSeparateDepthStencilLayoutsFeatures<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            separate_depth_stencil_layouts: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceSeparateDepthStencilLayoutsFeatures<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES;
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceSeparateDepthStencilLayoutsFeatures<'_>
{
}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceSeparateDepthStencilLayoutsFeatures<'_> {}
impl<'a> PhysicalDeviceSeparateDepthStencilLayoutsFeatures<'a> {
    #[inline]
    pub fn separate_depth_stencil_layouts(mut self, separate_depth_stencil_layouts: bool) -> Self {
        self.separate_depth_stencil_layouts = separate_depth_stencil_layouts.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAttachmentReferenceStencilLayout.html>"]
pub struct AttachmentReferenceStencilLayout<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub stencil_layout: ImageLayout,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for AttachmentReferenceStencilLayout<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            stencil_layout: ImageLayout::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for AttachmentReferenceStencilLayout<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ATTACHMENT_REFERENCE_STENCIL_LAYOUT;
}
unsafe impl ExtendsAttachmentReference2 for AttachmentReferenceStencilLayout<'_> {}
impl<'a> AttachmentReferenceStencilLayout<'a> {
    #[inline]
    pub fn stencil_layout(mut self, stencil_layout: ImageLayout) -> Self {
        self.stencil_layout = stencil_layout;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT.html>"]
pub struct PhysicalDevicePrimitiveTopologyListRestartFeaturesEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub primitive_topology_list_restart: Bool32,
    pub primitive_topology_patch_list_restart: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDevicePrimitiveTopologyListRestartFeaturesEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            primitive_topology_list_restart: Bool32::default(),
            primitive_topology_patch_list_restart: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDevicePrimitiveTopologyListRestartFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT;
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDevicePrimitiveTopologyListRestartFeaturesEXT<'_>
{
}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDevicePrimitiveTopologyListRestartFeaturesEXT<'_> {}
impl<'a> PhysicalDevicePrimitiveTopologyListRestartFeaturesEXT<'a> {
    #[inline]
    pub fn primitive_topology_list_restart(
        mut self,
        primitive_topology_list_restart: bool,
    ) -> Self {
        self.primitive_topology_list_restart = primitive_topology_list_restart.into();
        self
    }
    #[inline]
    pub fn primitive_topology_patch_list_restart(
        mut self,
        primitive_topology_patch_list_restart: bool,
    ) -> Self {
        self.primitive_topology_patch_list_restart = primitive_topology_patch_list_restart.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAttachmentDescriptionStencilLayout.html>"]
pub struct AttachmentDescriptionStencilLayout<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub stencil_initial_layout: ImageLayout,
    pub stencil_final_layout: ImageLayout,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for AttachmentDescriptionStencilLayout<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            stencil_initial_layout: ImageLayout::default(),
            stencil_final_layout: ImageLayout::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for AttachmentDescriptionStencilLayout<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT;
}
unsafe impl ExtendsAttachmentDescription2 for AttachmentDescriptionStencilLayout<'_> {}
impl<'a> AttachmentDescriptionStencilLayout<'a> {
    #[inline]
    pub fn stencil_initial_layout(mut self, stencil_initial_layout: ImageLayout) -> Self {
        self.stencil_initial_layout = stencil_initial_layout;
        self
    }
    #[inline]
    pub fn stencil_final_layout(mut self, stencil_final_layout: ImageLayout) -> Self {
        self.stencil_final_layout = stencil_final_layout;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR.html>"]
pub struct PhysicalDevicePipelineExecutablePropertiesFeaturesKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub pipeline_executable_info: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDevicePipelineExecutablePropertiesFeaturesKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            pipeline_executable_info: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDevicePipelineExecutablePropertiesFeaturesKHR<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR;
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDevicePipelineExecutablePropertiesFeaturesKHR<'_>
{
}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDevicePipelineExecutablePropertiesFeaturesKHR<'_> {}
impl<'a> PhysicalDevicePipelineExecutablePropertiesFeaturesKHR<'a> {
    #[inline]
    pub fn pipeline_executable_info(mut self, pipeline_executable_info: bool) -> Self {
        self.pipeline_executable_info = pipeline_executable_info.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineInfoKHR.html>"]
pub struct PipelineInfoKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub pipeline: Pipeline,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PipelineInfoKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            pipeline: Pipeline::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PipelineInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PIPELINE_INFO_KHR;
}
impl<'a> PipelineInfoKHR<'a> {
    #[inline]
    pub fn pipeline(mut self, pipeline: Pipeline) -> Self {
        self.pipeline = pipeline;
        self
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineExecutablePropertiesKHR.html>"]
pub struct PipelineExecutablePropertiesKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub stages: ShaderStageFlags,
    pub name: [c_char; MAX_DESCRIPTION_SIZE],
    pub description: [c_char; MAX_DESCRIPTION_SIZE],
    pub subgroup_size: u32,
    pub _marker: PhantomData<&'a ()>,
}
#[cfg(feature = "debug")]
impl fmt::Debug for PipelineExecutablePropertiesKHR<'_> {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineExecutablePropertiesKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("stages", &self.stages)
            .field("name", &unsafe {
                ::std::ffi::CStr::from_ptr(self.name.as_ptr())
            })
            .field("description", &unsafe {
                ::std::ffi::CStr::from_ptr(self.description.as_ptr())
            })
            .field("subgroup_size", &self.subgroup_size)
            .finish()
    }
}
impl ::std::default::Default for PipelineExecutablePropertiesKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            stages: ShaderStageFlags::default(),
            name: unsafe { ::std::mem::zeroed() },
            description: unsafe { ::std::mem::zeroed() },
            subgroup_size: u32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PipelineExecutablePropertiesKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PIPELINE_EXECUTABLE_PROPERTIES_KHR;
}
impl<'a> PipelineExecutablePropertiesKHR<'a> {
    #[inline]
    pub fn stages(mut self, stages: ShaderStageFlags) -> Self {
        self.stages = stages;
        self
    }
    #[inline]
    pub fn name(mut self, name: [c_char; MAX_DESCRIPTION_SIZE]) -> Self {
        self.name = name;
        self
    }
    #[inline]
    pub fn description(mut self, description: [c_char; MAX_DESCRIPTION_SIZE]) -> Self {
        self.description = description;
        self
    }
    #[inline]
    pub fn subgroup_size(mut self, subgroup_size: u32) -> Self {
        self.subgroup_size = subgroup_size;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineExecutableInfoKHR.html>"]
pub struct PipelineExecutableInfoKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub pipeline: Pipeline,
    pub executable_index: u32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PipelineExecutableInfoKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            pipeline: Pipeline::default(),
            executable_index: u32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PipelineExecutableInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PIPELINE_EXECUTABLE_INFO_KHR;
}
impl<'a> PipelineExecutableInfoKHR<'a> {
    #[inline]
    pub fn pipeline(mut self, pipeline: Pipeline) -> Self {
        self.pipeline = pipeline;
        self
    }
    #[inline]
    pub fn executable_index(mut self, executable_index: u32) -> Self {
        self.executable_index = executable_index;
        self
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineExecutableStatisticValueKHR.html>"]
pub union PipelineExecutableStatisticValueKHR {
    pub b32: Bool32,
    pub i64: i64,
    pub u64: u64,
    pub f64: f64,
}
impl ::std::default::Default for PipelineExecutableStatisticValueKHR {
    #[inline]
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineExecutableStatisticKHR.html>"]
pub struct PipelineExecutableStatisticKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub name: [c_char; MAX_DESCRIPTION_SIZE],
    pub description: [c_char; MAX_DESCRIPTION_SIZE],
    pub format: PipelineExecutableStatisticFormatKHR,
    pub value: PipelineExecutableStatisticValueKHR,
    pub _marker: PhantomData<&'a ()>,
}
#[cfg(feature = "debug")]
impl fmt::Debug for PipelineExecutableStatisticKHR<'_> {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineExecutableStatisticKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("name", &unsafe {
                ::std::ffi::CStr::from_ptr(self.name.as_ptr())
            })
            .field("description", &unsafe {
                ::std::ffi::CStr::from_ptr(self.description.as_ptr())
            })
            .field("format", &self.format)
            .field("value", &"union")
            .finish()
    }
}
impl ::std::default::Default for PipelineExecutableStatisticKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            name: unsafe { ::std::mem::zeroed() },
            description: unsafe { ::std::mem::zeroed() },
            format: PipelineExecutableStatisticFormatKHR::default(),
            value: PipelineExecutableStatisticValueKHR::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PipelineExecutableStatisticKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PIPELINE_EXECUTABLE_STATISTIC_KHR;
}
impl<'a> PipelineExecutableStatisticKHR<'a> {
    #[inline]
    pub fn name(mut self, name: [c_char; MAX_DESCRIPTION_SIZE]) -> Self {
        self.name = name;
        self
    }
    #[inline]
    pub fn description(mut self, description: [c_char; MAX_DESCRIPTION_SIZE]) -> Self {
        self.description = description;
        self
    }
    #[inline]
    pub fn format(mut self, format: PipelineExecutableStatisticFormatKHR) -> Self {
        self.format = format;
        self
    }
    #[inline]
    pub fn value(mut self, value: PipelineExecutableStatisticValueKHR) -> Self {
        self.value = value;
        self
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineExecutableInternalRepresentationKHR.html>"]
pub struct PipelineExecutableInternalRepresentationKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub name: [c_char; MAX_DESCRIPTION_SIZE],
    pub description: [c_char; MAX_DESCRIPTION_SIZE],
    pub is_text: Bool32,
    pub data_size: usize,
    pub p_data: *mut c_void,
    pub _marker: PhantomData<&'a ()>,
}
#[cfg(feature = "debug")]
impl fmt::Debug for PipelineExecutableInternalRepresentationKHR<'_> {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineExecutableInternalRepresentationKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("name", &unsafe {
                ::std::ffi::CStr::from_ptr(self.name.as_ptr())
            })
            .field("description", &unsafe {
                ::std::ffi::CStr::from_ptr(self.description.as_ptr())
            })
            .field("is_text", &self.is_text)
            .field("data_size", &self.data_size)
            .field("p_data", &self.p_data)
            .finish()
    }
}
impl ::std::default::Default for PipelineExecutableInternalRepresentationKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            name: unsafe { ::std::mem::zeroed() },
            description: unsafe { ::std::mem::zeroed() },
            is_text: Bool32::default(),
            data_size: usize::default(),
            p_data: ::std::ptr::null_mut(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PipelineExecutableInternalRepresentationKHR<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR;
}
impl<'a> PipelineExecutableInternalRepresentationKHR<'a> {
    #[inline]
    pub fn name(mut self, name: [c_char; MAX_DESCRIPTION_SIZE]) -> Self {
        self.name = name;
        self
    }
    #[inline]
    pub fn description(mut self, description: [c_char; MAX_DESCRIPTION_SIZE]) -> Self {
        self.description = description;
        self
    }
    #[inline]
    pub fn is_text(mut self, is_text: bool) -> Self {
        self.is_text = is_text.into();
        self
    }
    #[inline]
    pub fn data(mut self, data: &'a mut [u8]) -> Self {
        self.data_size = data.len();
        self.p_data = data.as_mut_ptr() as *mut c_void;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures.html>"]
pub struct PhysicalDeviceShaderDemoteToHelperInvocationFeatures<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shader_demote_to_helper_invocation: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceShaderDemoteToHelperInvocationFeatures<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            shader_demote_to_helper_invocation: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceShaderDemoteToHelperInvocationFeatures<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES;
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceShaderDemoteToHelperInvocationFeatures<'_>
{
}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceShaderDemoteToHelperInvocationFeatures<'_> {}
impl<'a> PhysicalDeviceShaderDemoteToHelperInvocationFeatures<'a> {
    #[inline]
    pub fn shader_demote_to_helper_invocation(
        mut self,
        shader_demote_to_helper_invocation: bool,
    ) -> Self {
        self.shader_demote_to_helper_invocation = shader_demote_to_helper_invocation.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT.html>"]
pub struct PhysicalDeviceTexelBufferAlignmentFeaturesEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub texel_buffer_alignment: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceTexelBufferAlignmentFeaturesEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            texel_buffer_alignment: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceTexelBufferAlignmentFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT;
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceTexelBufferAlignmentFeaturesEXT<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceTexelBufferAlignmentFeaturesEXT<'_> {}
impl<'a> PhysicalDeviceTexelBufferAlignmentFeaturesEXT<'a> {
    #[inline]
    pub fn texel_buffer_alignment(mut self, texel_buffer_alignment: bool) -> Self {
        self.texel_buffer_alignment = texel_buffer_alignment.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceTexelBufferAlignmentProperties.html>"]
pub struct PhysicalDeviceTexelBufferAlignmentProperties<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub storage_texel_buffer_offset_alignment_bytes: DeviceSize,
    pub storage_texel_buffer_offset_single_texel_alignment: Bool32,
    pub uniform_texel_buffer_offset_alignment_bytes: DeviceSize,
    pub uniform_texel_buffer_offset_single_texel_alignment: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceTexelBufferAlignmentProperties<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            storage_texel_buffer_offset_alignment_bytes: DeviceSize::default(),
            storage_texel_buffer_offset_single_texel_alignment: Bool32::default(),
            uniform_texel_buffer_offset_alignment_bytes: DeviceSize::default(),
            uniform_texel_buffer_offset_single_texel_alignment: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceTexelBufferAlignmentProperties<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES;
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceTexelBufferAlignmentProperties<'_> {}
impl<'a> PhysicalDeviceTexelBufferAlignmentProperties<'a> {
    #[inline]
    pub fn storage_texel_buffer_offset_alignment_bytes(
        mut self,
        storage_texel_buffer_offset_alignment_bytes: DeviceSize,
    ) -> Self {
        self.storage_texel_buffer_offset_alignment_bytes =
            storage_texel_buffer_offset_alignment_bytes;
        self
    }
    #[inline]
    pub fn storage_texel_buffer_offset_single_texel_alignment(
        mut self,
        storage_texel_buffer_offset_single_texel_alignment: bool,
    ) -> Self {
        self.storage_texel_buffer_offset_single_texel_alignment =
            storage_texel_buffer_offset_single_texel_alignment.into();
        self
    }
    #[inline]
    pub fn uniform_texel_buffer_offset_alignment_bytes(
        mut self,
        uniform_texel_buffer_offset_alignment_bytes: DeviceSize,
    ) -> Self {
        self.uniform_texel_buffer_offset_alignment_bytes =
            uniform_texel_buffer_offset_alignment_bytes;
        self
    }
    #[inline]
    pub fn uniform_texel_buffer_offset_single_texel_alignment(
        mut self,
        uniform_texel_buffer_offset_single_texel_alignment: bool,
    ) -> Self {
        self.uniform_texel_buffer_offset_single_texel_alignment =
            uniform_texel_buffer_offset_single_texel_alignment.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceSubgroupSizeControlFeatures.html>"]
pub struct PhysicalDeviceSubgroupSizeControlFeatures<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub subgroup_size_control: Bool32,
    pub compute_full_subgroups: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceSubgroupSizeControlFeatures<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            subgroup_size_control: Bool32::default(),
            compute_full_subgroups: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceSubgroupSizeControlFeatures<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES;
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceSubgroupSizeControlFeatures<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceSubgroupSizeControlFeatures<'_> {}
impl<'a> PhysicalDeviceSubgroupSizeControlFeatures<'a> {
    #[inline]
    pub fn subgroup_size_control(mut self, subgroup_size_control: bool) -> Self {
        self.subgroup_size_control = subgroup_size_control.into();
        self
    }
    #[inline]
    pub fn compute_full_subgroups(mut self, compute_full_subgroups: bool) -> Self {
        self.compute_full_subgroups = compute_full_subgroups.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceSubgroupSizeControlProperties.html>"]
pub struct PhysicalDeviceSubgroupSizeControlProperties<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub min_subgroup_size: u32,
    pub max_subgroup_size: u32,
    pub max_compute_workgroup_subgroups: u32,
    pub required_subgroup_size_stages: ShaderStageFlags,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceSubgroupSizeControlProperties<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            min_subgroup_size: u32::default(),
            max_subgroup_size: u32::default(),
            max_compute_workgroup_subgroups: u32::default(),
            required_subgroup_size_stages: ShaderStageFlags::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceSubgroupSizeControlProperties<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES;
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceSubgroupSizeControlProperties<'_> {}
impl<'a> PhysicalDeviceSubgroupSizeControlProperties<'a> {
    #[inline]
    pub fn min_subgroup_size(mut self, min_subgroup_size: u32) -> Self {
        self.min_subgroup_size = min_subgroup_size;
        self
    }
    #[inline]
    pub fn max_subgroup_size(mut self, max_subgroup_size: u32) -> Self {
        self.max_subgroup_size = max_subgroup_size;
        self
    }
    #[inline]
    pub fn max_compute_workgroup_subgroups(mut self, max_compute_workgroup_subgroups: u32) -> Self {
        self.max_compute_workgroup_subgroups = max_compute_workgroup_subgroups;
        self
    }
    #[inline]
    pub fn required_subgroup_size_stages(
        mut self,
        required_subgroup_size_stages: ShaderStageFlags,
    ) -> Self {
        self.required_subgroup_size_stages = required_subgroup_size_stages;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineShaderStageRequiredSubgroupSizeCreateInfo.html>"]
pub struct PipelineShaderStageRequiredSubgroupSizeCreateInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub required_subgroup_size: u32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PipelineShaderStageRequiredSubgroupSizeCreateInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            required_subgroup_size: u32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PipelineShaderStageRequiredSubgroupSizeCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO;
}
unsafe impl ExtendsPipelineShaderStageCreateInfo
    for PipelineShaderStageRequiredSubgroupSizeCreateInfo<'_>
{
}
impl<'a> PipelineShaderStageRequiredSubgroupSizeCreateInfo<'a> {
    #[inline]
    pub fn required_subgroup_size(mut self, required_subgroup_size: u32) -> Self {
        self.required_subgroup_size = required_subgroup_size;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSubpassShadingPipelineCreateInfoHUAWEI.html>"]
pub struct SubpassShadingPipelineCreateInfoHUAWEI<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub render_pass: RenderPass,
    pub subpass: u32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for SubpassShadingPipelineCreateInfoHUAWEI<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            render_pass: RenderPass::default(),
            subpass: u32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for SubpassShadingPipelineCreateInfoHUAWEI<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::SUBPASS_SHADING_PIPELINE_CREATE_INFO_HUAWEI;
}
unsafe impl ExtendsComputePipelineCreateInfo for SubpassShadingPipelineCreateInfoHUAWEI<'_> {}
impl<'a> SubpassShadingPipelineCreateInfoHUAWEI<'a> {
    #[inline]
    pub fn render_pass(mut self, render_pass: RenderPass) -> Self {
        self.render_pass = render_pass;
        self
    }
    #[inline]
    pub fn subpass(mut self, subpass: u32) -> Self {
        self.subpass = subpass;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceSubpassShadingPropertiesHUAWEI.html>"]
pub struct PhysicalDeviceSubpassShadingPropertiesHUAWEI<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub max_subpass_shading_workgroup_size_aspect_ratio: u32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceSubpassShadingPropertiesHUAWEI<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            max_subpass_shading_workgroup_size_aspect_ratio: u32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceSubpassShadingPropertiesHUAWEI<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI;
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceSubpassShadingPropertiesHUAWEI<'_> {}
impl<'a> PhysicalDeviceSubpassShadingPropertiesHUAWEI<'a> {
    #[inline]
    pub fn max_subpass_shading_workgroup_size_aspect_ratio(
        mut self,
        max_subpass_shading_workgroup_size_aspect_ratio: u32,
    ) -> Self {
        self.max_subpass_shading_workgroup_size_aspect_ratio =
            max_subpass_shading_workgroup_size_aspect_ratio;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryOpaqueCaptureAddressAllocateInfo.html>"]
pub struct MemoryOpaqueCaptureAddressAllocateInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub opaque_capture_address: u64,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for MemoryOpaqueCaptureAddressAllocateInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            opaque_capture_address: u64::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for MemoryOpaqueCaptureAddressAllocateInfo<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO;
}
unsafe impl ExtendsMemoryAllocateInfo for MemoryOpaqueCaptureAddressAllocateInfo<'_> {}
impl<'a> MemoryOpaqueCaptureAddressAllocateInfo<'a> {
    #[inline]
    pub fn opaque_capture_address(mut self, opaque_capture_address: u64) -> Self {
        self.opaque_capture_address = opaque_capture_address;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceMemoryOpaqueCaptureAddressInfo.html>"]
pub struct DeviceMemoryOpaqueCaptureAddressInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub memory: DeviceMemory,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for DeviceMemoryOpaqueCaptureAddressInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            memory: DeviceMemory::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for DeviceMemoryOpaqueCaptureAddressInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO;
}
impl<'a> DeviceMemoryOpaqueCaptureAddressInfo<'a> {
    #[inline]
    pub fn memory(mut self, memory: DeviceMemory) -> Self {
        self.memory = memory;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceLineRasterizationFeaturesEXT.html>"]
pub struct PhysicalDeviceLineRasterizationFeaturesEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub rectangular_lines: Bool32,
    pub bresenham_lines: Bool32,
    pub smooth_lines: Bool32,
    pub stippled_rectangular_lines: Bool32,
    pub stippled_bresenham_lines: Bool32,
    pub stippled_smooth_lines: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceLineRasterizationFeaturesEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            rectangular_lines: Bool32::default(),
            bresenham_lines: Bool32::default(),
            smooth_lines: Bool32::default(),
            stippled_rectangular_lines: Bool32::default(),
            stippled_bresenham_lines: Bool32::default(),
            stippled_smooth_lines: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceLineRasterizationFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT;
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceLineRasterizationFeaturesEXT<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceLineRasterizationFeaturesEXT<'_> {}
impl<'a> PhysicalDeviceLineRasterizationFeaturesEXT<'a> {
    #[inline]
    pub fn rectangular_lines(mut self, rectangular_lines: bool) -> Self {
        self.rectangular_lines = rectangular_lines.into();
        self
    }
    #[inline]
    pub fn bresenham_lines(mut self, bresenham_lines: bool) -> Self {
        self.bresenham_lines = bresenham_lines.into();
        self
    }
    #[inline]
    pub fn smooth_lines(mut self, smooth_lines: bool) -> Self {
        self.smooth_lines = smooth_lines.into();
        self
    }
    #[inline]
    pub fn stippled_rectangular_lines(mut self, stippled_rectangular_lines: bool) -> Self {
        self.stippled_rectangular_lines = stippled_rectangular_lines.into();
        self
    }
    #[inline]
    pub fn stippled_bresenham_lines(mut self, stippled_bresenham_lines: bool) -> Self {
        self.stippled_bresenham_lines = stippled_bresenham_lines.into();
        self
    }
    #[inline]
    pub fn stippled_smooth_lines(mut self, stippled_smooth_lines: bool) -> Self {
        self.stippled_smooth_lines = stippled_smooth_lines.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceLineRasterizationPropertiesEXT.html>"]
pub struct PhysicalDeviceLineRasterizationPropertiesEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub line_sub_pixel_precision_bits: u32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceLineRasterizationPropertiesEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            line_sub_pixel_precision_bits: u32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceLineRasterizationPropertiesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT;
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceLineRasterizationPropertiesEXT<'_> {}
impl<'a> PhysicalDeviceLineRasterizationPropertiesEXT<'a> {
    #[inline]
    pub fn line_sub_pixel_precision_bits(mut self, line_sub_pixel_precision_bits: u32) -> Self {
        self.line_sub_pixel_precision_bits = line_sub_pixel_precision_bits;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineRasterizationLineStateCreateInfoEXT.html>"]
pub struct PipelineRasterizationLineStateCreateInfoEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub line_rasterization_mode: LineRasterizationModeEXT,
    pub stippled_line_enable: Bool32,
    pub line_stipple_factor: u32,
    pub line_stipple_pattern: u16,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PipelineRasterizationLineStateCreateInfoEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            line_rasterization_mode: LineRasterizationModeEXT::default(),
            stippled_line_enable: Bool32::default(),
            line_stipple_factor: u32::default(),
            line_stipple_pattern: u16::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PipelineRasterizationLineStateCreateInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT;
}
unsafe impl ExtendsPipelineRasterizationStateCreateInfo
    for PipelineRasterizationLineStateCreateInfoEXT<'_>
{
}
impl<'a> PipelineRasterizationLineStateCreateInfoEXT<'a> {
    #[inline]
    pub fn line_rasterization_mode(
        mut self,
        line_rasterization_mode: LineRasterizationModeEXT,
    ) -> Self {
        self.line_rasterization_mode = line_rasterization_mode;
        self
    }
    #[inline]
    pub fn stippled_line_enable(mut self, stippled_line_enable: bool) -> Self {
        self.stippled_line_enable = stippled_line_enable.into();
        self
    }
    #[inline]
    pub fn line_stipple_factor(mut self, line_stipple_factor: u32) -> Self {
        self.line_stipple_factor = line_stipple_factor;
        self
    }
    #[inline]
    pub fn line_stipple_pattern(mut self, line_stipple_pattern: u16) -> Self {
        self.line_stipple_pattern = line_stipple_pattern;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePipelineCreationCacheControlFeatures.html>"]
pub struct PhysicalDevicePipelineCreationCacheControlFeatures<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub pipeline_creation_cache_control: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDevicePipelineCreationCacheControlFeatures<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            pipeline_creation_cache_control: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDevicePipelineCreationCacheControlFeatures<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES;
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDevicePipelineCreationCacheControlFeatures<'_>
{
}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDevicePipelineCreationCacheControlFeatures<'_> {}
impl<'a> PhysicalDevicePipelineCreationCacheControlFeatures<'a> {
    #[inline]
    pub fn pipeline_creation_cache_control(
        mut self,
        pipeline_creation_cache_control: bool,
    ) -> Self {
        self.pipeline_creation_cache_control = pipeline_creation_cache_control.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan11Features.html>"]
pub struct PhysicalDeviceVulkan11Features<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub storage_buffer16_bit_access: Bool32,
    pub uniform_and_storage_buffer16_bit_access: Bool32,
    pub storage_push_constant16: Bool32,
    pub storage_input_output16: Bool32,
    pub multiview: Bool32,
    pub multiview_geometry_shader: Bool32,
    pub multiview_tessellation_shader: Bool32,
    pub variable_pointers_storage_buffer: Bool32,
    pub variable_pointers: Bool32,
    pub protected_memory: Bool32,
    pub sampler_ycbcr_conversion: Bool32,
    pub shader_draw_parameters: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceVulkan11Features<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            storage_buffer16_bit_access: Bool32::default(),
            uniform_and_storage_buffer16_bit_access: Bool32::default(),
            storage_push_constant16: Bool32::default(),
            storage_input_output16: Bool32::default(),
            multiview: Bool32::default(),
            multiview_geometry_shader: Bool32::default(),
            multiview_tessellation_shader: Bool32::default(),
            variable_pointers_storage_buffer: Bool32::default(),
            variable_pointers: Bool32::default(),
            protected_memory: Bool32::default(),
            sampler_ycbcr_conversion: Bool32::default(),
            shader_draw_parameters: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceVulkan11Features<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_VULKAN_1_1_FEATURES;
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceVulkan11Features<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceVulkan11Features<'_> {}
impl<'a> PhysicalDeviceVulkan11Features<'a> {
    #[inline]
    pub fn storage_buffer16_bit_access(mut self, storage_buffer16_bit_access: bool) -> Self {
        self.storage_buffer16_bit_access = storage_buffer16_bit_access.into();
        self
    }
    #[inline]
    pub fn uniform_and_storage_buffer16_bit_access(
        mut self,
        uniform_and_storage_buffer16_bit_access: bool,
    ) -> Self {
        self.uniform_and_storage_buffer16_bit_access =
            uniform_and_storage_buffer16_bit_access.into();
        self
    }
    #[inline]
    pub fn storage_push_constant16(mut self, storage_push_constant16: bool) -> Self {
        self.storage_push_constant16 = storage_push_constant16.into();
        self
    }
    #[inline]
    pub fn storage_input_output16(mut self, storage_input_output16: bool) -> Self {
        self.storage_input_output16 = storage_input_output16.into();
        self
    }
    #[inline]
    pub fn multiview(mut self, multiview: bool) -> Self {
        self.multiview = multiview.into();
        self
    }
    #[inline]
    pub fn multiview_geometry_shader(mut self, multiview_geometry_shader: bool) -> Self {
        self.multiview_geometry_shader = multiview_geometry_shader.into();
        self
    }
    #[inline]
    pub fn multiview_tessellation_shader(mut self, multiview_tessellation_shader: bool) -> Self {
        self.multiview_tessellation_shader = multiview_tessellation_shader.into();
        self
    }
    #[inline]
    pub fn variable_pointers_storage_buffer(
        mut self,
        variable_pointers_storage_buffer: bool,
    ) -> Self {
        self.variable_pointers_storage_buffer = variable_pointers_storage_buffer.into();
        self
    }
    #[inline]
    pub fn variable_pointers(mut self, variable_pointers: bool) -> Self {
        self.variable_pointers = variable_pointers.into();
        self
    }
    #[inline]
    pub fn protected_memory(mut self, protected_memory: bool) -> Self {
        self.protected_memory = protected_memory.into();
        self
    }
    #[inline]
    pub fn sampler_ycbcr_conversion(mut self, sampler_ycbcr_conversion: bool) -> Self {
        self.sampler_ycbcr_conversion = sampler_ycbcr_conversion.into();
        self
    }
    #[inline]
    pub fn shader_draw_parameters(mut self, shader_draw_parameters: bool) -> Self {
        self.shader_draw_parameters = shader_draw_parameters.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan11Properties.html>"]
pub struct PhysicalDeviceVulkan11Properties<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub device_uuid: [u8; UUID_SIZE],
    pub driver_uuid: [u8; UUID_SIZE],
    pub device_luid: [u8; LUID_SIZE],
    pub device_node_mask: u32,
    pub device_luid_valid: Bool32,
    pub subgroup_size: u32,
    pub subgroup_supported_stages: ShaderStageFlags,
    pub subgroup_supported_operations: SubgroupFeatureFlags,
    pub subgroup_quad_operations_in_all_stages: Bool32,
    pub point_clipping_behavior: PointClippingBehavior,
    pub max_multiview_view_count: u32,
    pub max_multiview_instance_index: u32,
    pub protected_no_fault: Bool32,
    pub max_per_set_descriptors: u32,
    pub max_memory_allocation_size: DeviceSize,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceVulkan11Properties<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            device_uuid: unsafe { ::std::mem::zeroed() },
            driver_uuid: unsafe { ::std::mem::zeroed() },
            device_luid: unsafe { ::std::mem::zeroed() },
            device_node_mask: u32::default(),
            device_luid_valid: Bool32::default(),
            subgroup_size: u32::default(),
            subgroup_supported_stages: ShaderStageFlags::default(),
            subgroup_supported_operations: SubgroupFeatureFlags::default(),
            subgroup_quad_operations_in_all_stages: Bool32::default(),
            point_clipping_behavior: PointClippingBehavior::default(),
            max_multiview_view_count: u32::default(),
            max_multiview_instance_index: u32::default(),
            protected_no_fault: Bool32::default(),
            max_per_set_descriptors: u32::default(),
            max_memory_allocation_size: DeviceSize::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceVulkan11Properties<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES;
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceVulkan11Properties<'_> {}
impl<'a> PhysicalDeviceVulkan11Properties<'a> {
    #[inline]
    pub fn device_uuid(mut self, device_uuid: [u8; UUID_SIZE]) -> Self {
        self.device_uuid = device_uuid;
        self
    }
    #[inline]
    pub fn driver_uuid(mut self, driver_uuid: [u8; UUID_SIZE]) -> Self {
        self.driver_uuid = driver_uuid;
        self
    }
    #[inline]
    pub fn device_luid(mut self, device_luid: [u8; LUID_SIZE]) -> Self {
        self.device_luid = device_luid;
        self
    }
    #[inline]
    pub fn device_node_mask(mut self, device_node_mask: u32) -> Self {
        self.device_node_mask = device_node_mask;
        self
    }
    #[inline]
    pub fn device_luid_valid(mut self, device_luid_valid: bool) -> Self {
        self.device_luid_valid = device_luid_valid.into();
        self
    }
    #[inline]
    pub fn subgroup_size(mut self, subgroup_size: u32) -> Self {
        self.subgroup_size = subgroup_size;
        self
    }
    #[inline]
    pub fn subgroup_supported_stages(
        mut self,
        subgroup_supported_stages: ShaderStageFlags,
    ) -> Self {
        self.subgroup_supported_stages = subgroup_supported_stages;
        self
    }
    #[inline]
    pub fn subgroup_supported_operations(
        mut self,
        subgroup_supported_operations: SubgroupFeatureFlags,
    ) -> Self {
        self.subgroup_supported_operations = subgroup_supported_operations;
        self
    }
    #[inline]
    pub fn subgroup_quad_operations_in_all_stages(
        mut self,
        subgroup_quad_operations_in_all_stages: bool,
    ) -> Self {
        self.subgroup_quad_operations_in_all_stages = subgroup_quad_operations_in_all_stages.into();
        self
    }
    #[inline]
    pub fn point_clipping_behavior(
        mut self,
        point_clipping_behavior: PointClippingBehavior,
    ) -> Self {
        self.point_clipping_behavior = point_clipping_behavior;
        self
    }
    #[inline]
    pub fn max_multiview_view_count(mut self, max_multiview_view_count: u32) -> Self {
        self.max_multiview_view_count = max_multiview_view_count;
        self
    }
    #[inline]
    pub fn max_multiview_instance_index(mut self, max_multiview_instance_index: u32) -> Self {
        self.max_multiview_instance_index = max_multiview_instance_index;
        self
    }
    #[inline]
    pub fn protected_no_fault(mut self, protected_no_fault: bool) -> Self {
        self.protected_no_fault = protected_no_fault.into();
        self
    }
    #[inline]
    pub fn max_per_set_descriptors(mut self, max_per_set_descriptors: u32) -> Self {
        self.max_per_set_descriptors = max_per_set_descriptors;
        self
    }
    #[inline]
    pub fn max_memory_allocation_size(mut self, max_memory_allocation_size: DeviceSize) -> Self {
        self.max_memory_allocation_size = max_memory_allocation_size;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan12Features.html>"]
pub struct PhysicalDeviceVulkan12Features<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub sampler_mirror_clamp_to_edge: Bool32,
    pub draw_indirect_count: Bool32,
    pub storage_buffer8_bit_access: Bool32,
    pub uniform_and_storage_buffer8_bit_access: Bool32,
    pub storage_push_constant8: Bool32,
    pub shader_buffer_int64_atomics: Bool32,
    pub shader_shared_int64_atomics: Bool32,
    pub shader_float16: Bool32,
    pub shader_int8: Bool32,
    pub descriptor_indexing: Bool32,
    pub shader_input_attachment_array_dynamic_indexing: Bool32,
    pub shader_uniform_texel_buffer_array_dynamic_indexing: Bool32,
    pub shader_storage_texel_buffer_array_dynamic_indexing: Bool32,
    pub shader_uniform_buffer_array_non_uniform_indexing: Bool32,
    pub shader_sampled_image_array_non_uniform_indexing: Bool32,
    pub shader_storage_buffer_array_non_uniform_indexing: Bool32,
    pub shader_storage_image_array_non_uniform_indexing: Bool32,
    pub shader_input_attachment_array_non_uniform_indexing: Bool32,
    pub shader_uniform_texel_buffer_array_non_uniform_indexing: Bool32,
    pub shader_storage_texel_buffer_array_non_uniform_indexing: Bool32,
    pub descriptor_binding_uniform_buffer_update_after_bind: Bool32,
    pub descriptor_binding_sampled_image_update_after_bind: Bool32,
    pub descriptor_binding_storage_image_update_after_bind: Bool32,
    pub descriptor_binding_storage_buffer_update_after_bind: Bool32,
    pub descriptor_binding_uniform_texel_buffer_update_after_bind: Bool32,
    pub descriptor_binding_storage_texel_buffer_update_after_bind: Bool32,
    pub descriptor_binding_update_unused_while_pending: Bool32,
    pub descriptor_binding_partially_bound: Bool32,
    pub descriptor_binding_variable_descriptor_count: Bool32,
    pub runtime_descriptor_array: Bool32,
    pub sampler_filter_minmax: Bool32,
    pub scalar_block_layout: Bool32,
    pub imageless_framebuffer: Bool32,
    pub uniform_buffer_standard_layout: Bool32,
    pub shader_subgroup_extended_types: Bool32,
    pub separate_depth_stencil_layouts: Bool32,
    pub host_query_reset: Bool32,
    pub timeline_semaphore: Bool32,
    pub buffer_device_address: Bool32,
    pub buffer_device_address_capture_replay: Bool32,
    pub buffer_device_address_multi_device: Bool32,
    pub vulkan_memory_model: Bool32,
    pub vulkan_memory_model_device_scope: Bool32,
    pub vulkan_memory_model_availability_visibility_chains: Bool32,
    pub shader_output_viewport_index: Bool32,
    pub shader_output_layer: Bool32,
    pub subgroup_broadcast_dynamic_id: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceVulkan12Features<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            sampler_mirror_clamp_to_edge: Bool32::default(),
            draw_indirect_count: Bool32::default(),
            storage_buffer8_bit_access: Bool32::default(),
            uniform_and_storage_buffer8_bit_access: Bool32::default(),
            storage_push_constant8: Bool32::default(),
            shader_buffer_int64_atomics: Bool32::default(),
            shader_shared_int64_atomics: Bool32::default(),
            shader_float16: Bool32::default(),
            shader_int8: Bool32::default(),
            descriptor_indexing: Bool32::default(),
            shader_input_attachment_array_dynamic_indexing: Bool32::default(),
            shader_uniform_texel_buffer_array_dynamic_indexing: Bool32::default(),
            shader_storage_texel_buffer_array_dynamic_indexing: Bool32::default(),
            shader_uniform_buffer_array_non_uniform_indexing: Bool32::default(),
            shader_sampled_image_array_non_uniform_indexing: Bool32::default(),
            shader_storage_buffer_array_non_uniform_indexing: Bool32::default(),
            shader_storage_image_array_non_uniform_indexing: Bool32::default(),
            shader_input_attachment_array_non_uniform_indexing: Bool32::default(),
            shader_uniform_texel_buffer_array_non_uniform_indexing: Bool32::default(),
            shader_storage_texel_buffer_array_non_uniform_indexing: Bool32::default(),
            descriptor_binding_uniform_buffer_update_after_bind: Bool32::default(),
            descriptor_binding_sampled_image_update_after_bind: Bool32::default(),
            descriptor_binding_storage_image_update_after_bind: Bool32::default(),
            descriptor_binding_storage_buffer_update_after_bind: Bool32::default(),
            descriptor_binding_uniform_texel_buffer_update_after_bind: Bool32::default(),
            descriptor_binding_storage_texel_buffer_update_after_bind: Bool32::default(),
            descriptor_binding_update_unused_while_pending: Bool32::default(),
            descriptor_binding_partially_bound: Bool32::default(),
            descriptor_binding_variable_descriptor_count: Bool32::default(),
            runtime_descriptor_array: Bool32::default(),
            sampler_filter_minmax: Bool32::default(),
            scalar_block_layout: Bool32::default(),
            imageless_framebuffer: Bool32::default(),
            uniform_buffer_standard_layout: Bool32::default(),
            shader_subgroup_extended_types: Bool32::default(),
            separate_depth_stencil_layouts: Bool32::default(),
            host_query_reset: Bool32::default(),
            timeline_semaphore: Bool32::default(),
            buffer_device_address: Bool32::default(),
            buffer_device_address_capture_replay: Bool32::default(),
            buffer_device_address_multi_device: Bool32::default(),
            vulkan_memory_model: Bool32::default(),
            vulkan_memory_model_device_scope: Bool32::default(),
            vulkan_memory_model_availability_visibility_chains: Bool32::default(),
            shader_output_viewport_index: Bool32::default(),
            shader_output_layer: Bool32::default(),
            subgroup_broadcast_dynamic_id: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceVulkan12Features<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_VULKAN_1_2_FEATURES;
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceVulkan12Features<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceVulkan12Features<'_> {}
impl<'a> PhysicalDeviceVulkan12Features<'a> {
    #[inline]
    pub fn sampler_mirror_clamp_to_edge(mut self, sampler_mirror_clamp_to_edge: bool) -> Self {
        self.sampler_mirror_clamp_to_edge = sampler_mirror_clamp_to_edge.into();
        self
    }
    #[inline]
    pub fn draw_indirect_count(mut self, draw_indirect_count: bool) -> Self {
        self.draw_indirect_count = draw_indirect_count.into();
        self
    }
    #[inline]
    pub fn storage_buffer8_bit_access(mut self, storage_buffer8_bit_access: bool) -> Self {
        self.storage_buffer8_bit_access = storage_buffer8_bit_access.into();
        self
    }
    #[inline]
    pub fn uniform_and_storage_buffer8_bit_access(
        mut self,
        uniform_and_storage_buffer8_bit_access: bool,
    ) -> Self {
        self.uniform_and_storage_buffer8_bit_access = uniform_and_storage_buffer8_bit_access.into();
        self
    }
    #[inline]
    pub fn storage_push_constant8(mut self, storage_push_constant8: bool) -> Self {
        self.storage_push_constant8 = storage_push_constant8.into();
        self
    }
    #[inline]
    pub fn shader_buffer_int64_atomics(mut self, shader_buffer_int64_atomics: bool) -> Self {
        self.shader_buffer_int64_atomics = shader_buffer_int64_atomics.into();
        self
    }
    #[inline]
    pub fn shader_shared_int64_atomics(mut self, shader_shared_int64_atomics: bool) -> Self {
        self.shader_shared_int64_atomics = shader_shared_int64_atomics.into();
        self
    }
    #[inline]
    pub fn shader_float16(mut self, shader_float16: bool) -> Self {
        self.shader_float16 = shader_float16.into();
        self
    }
    #[inline]
    pub fn shader_int8(mut self, shader_int8: bool) -> Self {
        self.shader_int8 = shader_int8.into();
        self
    }
    #[inline]
    pub fn descriptor_indexing(mut self, descriptor_indexing: bool) -> Self {
        self.descriptor_indexing = descriptor_indexing.into();
        self
    }
    #[inline]
    pub fn shader_input_attachment_array_dynamic_indexing(
        mut self,
        shader_input_attachment_array_dynamic_indexing: bool,
    ) -> Self {
        self.shader_input_attachment_array_dynamic_indexing =
            shader_input_attachment_array_dynamic_indexing.into();
        self
    }
    #[inline]
    pub fn shader_uniform_texel_buffer_array_dynamic_indexing(
        mut self,
        shader_uniform_texel_buffer_array_dynamic_indexing: bool,
    ) -> Self {
        self.shader_uniform_texel_buffer_array_dynamic_indexing =
            shader_uniform_texel_buffer_array_dynamic_indexing.into();
        self
    }
    #[inline]
    pub fn shader_storage_texel_buffer_array_dynamic_indexing(
        mut self,
        shader_storage_texel_buffer_array_dynamic_indexing: bool,
    ) -> Self {
        self.shader_storage_texel_buffer_array_dynamic_indexing =
            shader_storage_texel_buffer_array_dynamic_indexing.into();
        self
    }
    #[inline]
    pub fn shader_uniform_buffer_array_non_uniform_indexing(
        mut self,
        shader_uniform_buffer_array_non_uniform_indexing: bool,
    ) -> Self {
        self.shader_uniform_buffer_array_non_uniform_indexing =
            shader_uniform_buffer_array_non_uniform_indexing.into();
        self
    }
    #[inline]
    pub fn shader_sampled_image_array_non_uniform_indexing(
        mut self,
        shader_sampled_image_array_non_uniform_indexing: bool,
    ) -> Self {
        self.shader_sampled_image_array_non_uniform_indexing =
            shader_sampled_image_array_non_uniform_indexing.into();
        self
    }
    #[inline]
    pub fn shader_storage_buffer_array_non_uniform_indexing(
        mut self,
        shader_storage_buffer_array_non_uniform_indexing: bool,
    ) -> Self {
        self.shader_storage_buffer_array_non_uniform_indexing =
            shader_storage_buffer_array_non_uniform_indexing.into();
        self
    }
    #[inline]
    pub fn shader_storage_image_array_non_uniform_indexing(
        mut self,
        shader_storage_image_array_non_uniform_indexing: bool,
    ) -> Self {
        self.shader_storage_image_array_non_uniform_indexing =
            shader_storage_image_array_non_uniform_indexing.into();
        self
    }
    #[inline]
    pub fn shader_input_attachment_array_non_uniform_indexing(
        mut self,
        shader_input_attachment_array_non_uniform_indexing: bool,
    ) -> Self {
        self.shader_input_attachment_array_non_uniform_indexing =
            shader_input_attachment_array_non_uniform_indexing.into();
        self
    }
    #[inline]
    pub fn shader_uniform_texel_buffer_array_non_uniform_indexing(
        mut self,
        shader_uniform_texel_buffer_array_non_uniform_indexing: bool,
    ) -> Self {
        self.shader_uniform_texel_buffer_array_non_uniform_indexing =
            shader_uniform_texel_buffer_array_non_uniform_indexing.into();
        self
    }
    #[inline]
    pub fn shader_storage_texel_buffer_array_non_uniform_indexing(
        mut self,
        shader_storage_texel_buffer_array_non_uniform_indexing: bool,
    ) -> Self {
        self.shader_storage_texel_buffer_array_non_uniform_indexing =
            shader_storage_texel_buffer_array_non_uniform_indexing.into();
        self
    }
    #[inline]
    pub fn descriptor_binding_uniform_buffer_update_after_bind(
        mut self,
        descriptor_binding_uniform_buffer_update_after_bind: bool,
    ) -> Self {
        self.descriptor_binding_uniform_buffer_update_after_bind =
            descriptor_binding_uniform_buffer_update_after_bind.into();
        self
    }
    #[inline]
    pub fn descriptor_binding_sampled_image_update_after_bind(
        mut self,
        descriptor_binding_sampled_image_update_after_bind: bool,
    ) -> Self {
        self.descriptor_binding_sampled_image_update_after_bind =
            descriptor_binding_sampled_image_update_after_bind.into();
        self
    }
    #[inline]
    pub fn descriptor_binding_storage_image_update_after_bind(
        mut self,
        descriptor_binding_storage_image_update_after_bind: bool,
    ) -> Self {
        self.descriptor_binding_storage_image_update_after_bind =
            descriptor_binding_storage_image_update_after_bind.into();
        self
    }
    #[inline]
    pub fn descriptor_binding_storage_buffer_update_after_bind(
        mut self,
        descriptor_binding_storage_buffer_update_after_bind: bool,
    ) -> Self {
        self.descriptor_binding_storage_buffer_update_after_bind =
            descriptor_binding_storage_buffer_update_after_bind.into();
        self
    }
    #[inline]
    pub fn descriptor_binding_uniform_texel_buffer_update_after_bind(
        mut self,
        descriptor_binding_uniform_texel_buffer_update_after_bind: bool,
    ) -> Self {
        self.descriptor_binding_uniform_texel_buffer_update_after_bind =
            descriptor_binding_uniform_texel_buffer_update_after_bind.into();
        self
    }
    #[inline]
    pub fn descriptor_binding_storage_texel_buffer_update_after_bind(
        mut self,
        descriptor_binding_storage_texel_buffer_update_after_bind: bool,
    ) -> Self {
        self.descriptor_binding_storage_texel_buffer_update_after_bind =
            descriptor_binding_storage_texel_buffer_update_after_bind.into();
        self
    }
    #[inline]
    pub fn descriptor_binding_update_unused_while_pending(
        mut self,
        descriptor_binding_update_unused_while_pending: bool,
    ) -> Self {
        self.descriptor_binding_update_unused_while_pending =
            descriptor_binding_update_unused_while_pending.into();
        self
    }
    #[inline]
    pub fn descriptor_binding_partially_bound(
        mut self,
        descriptor_binding_partially_bound: bool,
    ) -> Self {
        self.descriptor_binding_partially_bound = descriptor_binding_partially_bound.into();
        self
    }
    #[inline]
    pub fn descriptor_binding_variable_descriptor_count(
        mut self,
        descriptor_binding_variable_descriptor_count: bool,
    ) -> Self {
        self.descriptor_binding_variable_descriptor_count =
            descriptor_binding_variable_descriptor_count.into();
        self
    }
    #[inline]
    pub fn runtime_descriptor_array(mut self, runtime_descriptor_array: bool) -> Self {
        self.runtime_descriptor_array = runtime_descriptor_array.into();
        self
    }
    #[inline]
    pub fn sampler_filter_minmax(mut self, sampler_filter_minmax: bool) -> Self {
        self.sampler_filter_minmax = sampler_filter_minmax.into();
        self
    }
    #[inline]
    pub fn scalar_block_layout(mut self, scalar_block_layout: bool) -> Self {
        self.scalar_block_layout = scalar_block_layout.into();
        self
    }
    #[inline]
    pub fn imageless_framebuffer(mut self, imageless_framebuffer: bool) -> Self {
        self.imageless_framebuffer = imageless_framebuffer.into();
        self
    }
    #[inline]
    pub fn uniform_buffer_standard_layout(mut self, uniform_buffer_standard_layout: bool) -> Self {
        self.uniform_buffer_standard_layout = uniform_buffer_standard_layout.into();
        self
    }
    #[inline]
    pub fn shader_subgroup_extended_types(mut self, shader_subgroup_extended_types: bool) -> Self {
        self.shader_subgroup_extended_types = shader_subgroup_extended_types.into();
        self
    }
    #[inline]
    pub fn separate_depth_stencil_layouts(mut self, separate_depth_stencil_layouts: bool) -> Self {
        self.separate_depth_stencil_layouts = separate_depth_stencil_layouts.into();
        self
    }
    #[inline]
    pub fn host_query_reset(mut self, host_query_reset: bool) -> Self {
        self.host_query_reset = host_query_reset.into();
        self
    }
    #[inline]
    pub fn timeline_semaphore(mut self, timeline_semaphore: bool) -> Self {
        self.timeline_semaphore = timeline_semaphore.into();
        self
    }
    #[inline]
    pub fn buffer_device_address(mut self, buffer_device_address: bool) -> Self {
        self.buffer_device_address = buffer_device_address.into();
        self
    }
    #[inline]
    pub fn buffer_device_address_capture_replay(
        mut self,
        buffer_device_address_capture_replay: bool,
    ) -> Self {
        self.buffer_device_address_capture_replay = buffer_device_address_capture_replay.into();
        self
    }
    #[inline]
    pub fn buffer_device_address_multi_device(
        mut self,
        buffer_device_address_multi_device: bool,
    ) -> Self {
        self.buffer_device_address_multi_device = buffer_device_address_multi_device.into();
        self
    }
    #[inline]
    pub fn vulkan_memory_model(mut self, vulkan_memory_model: bool) -> Self {
        self.vulkan_memory_model = vulkan_memory_model.into();
        self
    }
    #[inline]
    pub fn vulkan_memory_model_device_scope(
        mut self,
        vulkan_memory_model_device_scope: bool,
    ) -> Self {
        self.vulkan_memory_model_device_scope = vulkan_memory_model_device_scope.into();
        self
    }
    #[inline]
    pub fn vulkan_memory_model_availability_visibility_chains(
        mut self,
        vulkan_memory_model_availability_visibility_chains: bool,
    ) -> Self {
        self.vulkan_memory_model_availability_visibility_chains =
            vulkan_memory_model_availability_visibility_chains.into();
        self
    }
    #[inline]
    pub fn shader_output_viewport_index(mut self, shader_output_viewport_index: bool) -> Self {
        self.shader_output_viewport_index = shader_output_viewport_index.into();
        self
    }
    #[inline]
    pub fn shader_output_layer(mut self, shader_output_layer: bool) -> Self {
        self.shader_output_layer = shader_output_layer.into();
        self
    }
    #[inline]
    pub fn subgroup_broadcast_dynamic_id(mut self, subgroup_broadcast_dynamic_id: bool) -> Self {
        self.subgroup_broadcast_dynamic_id = subgroup_broadcast_dynamic_id.into();
        self
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan12Properties.html>"]
pub struct PhysicalDeviceVulkan12Properties<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub driver_id: DriverId,
    pub driver_name: [c_char; MAX_DRIVER_NAME_SIZE],
    pub driver_info: [c_char; MAX_DRIVER_INFO_SIZE],
    pub conformance_version: ConformanceVersion,
    pub denorm_behavior_independence: ShaderFloatControlsIndependence,
    pub rounding_mode_independence: ShaderFloatControlsIndependence,
    pub shader_signed_zero_inf_nan_preserve_float16: Bool32,
    pub shader_signed_zero_inf_nan_preserve_float32: Bool32,
    pub shader_signed_zero_inf_nan_preserve_float64: Bool32,
    pub shader_denorm_preserve_float16: Bool32,
    pub shader_denorm_preserve_float32: Bool32,
    pub shader_denorm_preserve_float64: Bool32,
    pub shader_denorm_flush_to_zero_float16: Bool32,
    pub shader_denorm_flush_to_zero_float32: Bool32,
    pub shader_denorm_flush_to_zero_float64: Bool32,
    pub shader_rounding_mode_rte_float16: Bool32,
    pub shader_rounding_mode_rte_float32: Bool32,
    pub shader_rounding_mode_rte_float64: Bool32,
    pub shader_rounding_mode_rtz_float16: Bool32,
    pub shader_rounding_mode_rtz_float32: Bool32,
    pub shader_rounding_mode_rtz_float64: Bool32,
    pub max_update_after_bind_descriptors_in_all_pools: u32,
    pub shader_uniform_buffer_array_non_uniform_indexing_native: Bool32,
    pub shader_sampled_image_array_non_uniform_indexing_native: Bool32,
    pub shader_storage_buffer_array_non_uniform_indexing_native: Bool32,
    pub shader_storage_image_array_non_uniform_indexing_native: Bool32,
    pub shader_input_attachment_array_non_uniform_indexing_native: Bool32,
    pub robust_buffer_access_update_after_bind: Bool32,
    pub quad_divergent_implicit_lod: Bool32,
    pub max_per_stage_descriptor_update_after_bind_samplers: u32,
    pub max_per_stage_descriptor_update_after_bind_uniform_buffers: u32,
    pub max_per_stage_descriptor_update_after_bind_storage_buffers: u32,
    pub max_per_stage_descriptor_update_after_bind_sampled_images: u32,
    pub max_per_stage_descriptor_update_after_bind_storage_images: u32,
    pub max_per_stage_descriptor_update_after_bind_input_attachments: u32,
    pub max_per_stage_update_after_bind_resources: u32,
    pub max_descriptor_set_update_after_bind_samplers: u32,
    pub max_descriptor_set_update_after_bind_uniform_buffers: u32,
    pub max_descriptor_set_update_after_bind_uniform_buffers_dynamic: u32,
    pub max_descriptor_set_update_after_bind_storage_buffers: u32,
    pub max_descriptor_set_update_after_bind_storage_buffers_dynamic: u32,
    pub max_descriptor_set_update_after_bind_sampled_images: u32,
    pub max_descriptor_set_update_after_bind_storage_images: u32,
    pub max_descriptor_set_update_after_bind_input_attachments: u32,
    pub supported_depth_resolve_modes: ResolveModeFlags,
    pub supported_stencil_resolve_modes: ResolveModeFlags,
    pub independent_resolve_none: Bool32,
    pub independent_resolve: Bool32,
    pub filter_minmax_single_component_formats: Bool32,
    pub filter_minmax_image_component_mapping: Bool32,
    pub max_timeline_semaphore_value_difference: u64,
    pub framebuffer_integer_color_sample_counts: SampleCountFlags,
    pub _marker: PhantomData<&'a ()>,
}
#[cfg(feature = "debug")]
impl fmt::Debug for PhysicalDeviceVulkan12Properties<'_> {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceVulkan12Properties")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("driver_id", &self.driver_id)
            .field("driver_name", &unsafe {
                ::std::ffi::CStr::from_ptr(self.driver_name.as_ptr())
            })
            .field("driver_info", &unsafe {
                ::std::ffi::CStr::from_ptr(self.driver_info.as_ptr())
            })
            .field("conformance_version", &self.conformance_version)
            .field(
                "denorm_behavior_independence",
                &self.denorm_behavior_independence,
            )
            .field(
                "rounding_mode_independence",
                &self.rounding_mode_independence,
            )
            .field(
                "shader_signed_zero_inf_nan_preserve_float16",
                &self.shader_signed_zero_inf_nan_preserve_float16,
            )
            .field(
                "shader_signed_zero_inf_nan_preserve_float32",
                &self.shader_signed_zero_inf_nan_preserve_float32,
            )
            .field(
                "shader_signed_zero_inf_nan_preserve_float64",
                &self.shader_signed_zero_inf_nan_preserve_float64,
            )
            .field(
                "shader_denorm_preserve_float16",
                &self.shader_denorm_preserve_float16,
            )
            .field(
                "shader_denorm_preserve_float32",
                &self.shader_denorm_preserve_float32,
            )
            .field(
                "shader_denorm_preserve_float64",
                &self.shader_denorm_preserve_float64,
            )
            .field(
                "shader_denorm_flush_to_zero_float16",
                &self.shader_denorm_flush_to_zero_float16,
            )
            .field(
                "shader_denorm_flush_to_zero_float32",
                &self.shader_denorm_flush_to_zero_float32,
            )
            .field(
                "shader_denorm_flush_to_zero_float64",
                &self.shader_denorm_flush_to_zero_float64,
            )
            .field(
                "shader_rounding_mode_rte_float16",
                &self.shader_rounding_mode_rte_float16,
            )
            .field(
                "shader_rounding_mode_rte_float32",
                &self.shader_rounding_mode_rte_float32,
            )
            .field(
                "shader_rounding_mode_rte_float64",
                &self.shader_rounding_mode_rte_float64,
            )
            .field(
                "shader_rounding_mode_rtz_float16",
                &self.shader_rounding_mode_rtz_float16,
            )
            .field(
                "shader_rounding_mode_rtz_float32",
                &self.shader_rounding_mode_rtz_float32,
            )
            .field(
                "shader_rounding_mode_rtz_float64",
                &self.shader_rounding_mode_rtz_float64,
            )
            .field(
                "max_update_after_bind_descriptors_in_all_pools",
                &self.max_update_after_bind_descriptors_in_all_pools,
            )
            .field(
                "shader_uniform_buffer_array_non_uniform_indexing_native",
                &self.shader_uniform_buffer_array_non_uniform_indexing_native,
            )
            .field(
                "shader_sampled_image_array_non_uniform_indexing_native",
                &self.shader_sampled_image_array_non_uniform_indexing_native,
            )
            .field(
                "shader_storage_buffer_array_non_uniform_indexing_native",
                &self.shader_storage_buffer_array_non_uniform_indexing_native,
            )
            .field(
                "shader_storage_image_array_non_uniform_indexing_native",
                &self.shader_storage_image_array_non_uniform_indexing_native,
            )
            .field(
                "shader_input_attachment_array_non_uniform_indexing_native",
                &self.shader_input_attachment_array_non_uniform_indexing_native,
            )
            .field(
                "robust_buffer_access_update_after_bind",
                &self.robust_buffer_access_update_after_bind,
            )
            .field(
                "quad_divergent_implicit_lod",
                &self.quad_divergent_implicit_lod,
            )
            .field(
                "max_per_stage_descriptor_update_after_bind_samplers",
                &self.max_per_stage_descriptor_update_after_bind_samplers,
            )
            .field(
                "max_per_stage_descriptor_update_after_bind_uniform_buffers",
                &self.max_per_stage_descriptor_update_after_bind_uniform_buffers,
            )
            .field(
                "max_per_stage_descriptor_update_after_bind_storage_buffers",
                &self.max_per_stage_descriptor_update_after_bind_storage_buffers,
            )
            .field(
                "max_per_stage_descriptor_update_after_bind_sampled_images",
                &self.max_per_stage_descriptor_update_after_bind_sampled_images,
            )
            .field(
                "max_per_stage_descriptor_update_after_bind_storage_images",
                &self.max_per_stage_descriptor_update_after_bind_storage_images,
            )
            .field(
                "max_per_stage_descriptor_update_after_bind_input_attachments",
                &self.max_per_stage_descriptor_update_after_bind_input_attachments,
            )
            .field(
                "max_per_stage_update_after_bind_resources",
                &self.max_per_stage_update_after_bind_resources,
            )
            .field(
                "max_descriptor_set_update_after_bind_samplers",
                &self.max_descriptor_set_update_after_bind_samplers,
            )
            .field(
                "max_descriptor_set_update_after_bind_uniform_buffers",
                &self.max_descriptor_set_update_after_bind_uniform_buffers,
            )
            .field(
                "max_descriptor_set_update_after_bind_uniform_buffers_dynamic",
                &self.max_descriptor_set_update_after_bind_uniform_buffers_dynamic,
            )
            .field(
                "max_descriptor_set_update_after_bind_storage_buffers",
                &self.max_descriptor_set_update_after_bind_storage_buffers,
            )
            .field(
                "max_descriptor_set_update_after_bind_storage_buffers_dynamic",
                &self.max_descriptor_set_update_after_bind_storage_buffers_dynamic,
            )
            .field(
                "max_descriptor_set_update_after_bind_sampled_images",
                &self.max_descriptor_set_update_after_bind_sampled_images,
            )
            .field(
                "max_descriptor_set_update_after_bind_storage_images",
                &self.max_descriptor_set_update_after_bind_storage_images,
            )
            .field(
                "max_descriptor_set_update_after_bind_input_attachments",
                &self.max_descriptor_set_update_after_bind_input_attachments,
            )
            .field(
                "supported_depth_resolve_modes",
                &self.supported_depth_resolve_modes,
            )
            .field(
                "supported_stencil_resolve_modes",
                &self.supported_stencil_resolve_modes,
            )
            .field("independent_resolve_none", &self.independent_resolve_none)
            .field("independent_resolve", &self.independent_resolve)
            .field(
                "filter_minmax_single_component_formats",
                &self.filter_minmax_single_component_formats,
            )
            .field(
                "filter_minmax_image_component_mapping",
                &self.filter_minmax_image_component_mapping,
            )
            .field(
                "max_timeline_semaphore_value_difference",
                &self.max_timeline_semaphore_value_difference,
            )
            .field(
                "framebuffer_integer_color_sample_counts",
                &self.framebuffer_integer_color_sample_counts,
            )
            .finish()
    }
}
impl ::std::default::Default for PhysicalDeviceVulkan12Properties<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            driver_id: DriverId::default(),
            driver_name: unsafe { ::std::mem::zeroed() },
            driver_info: unsafe { ::std::mem::zeroed() },
            conformance_version: ConformanceVersion::default(),
            denorm_behavior_independence: ShaderFloatControlsIndependence::default(),
            rounding_mode_independence: ShaderFloatControlsIndependence::default(),
            shader_signed_zero_inf_nan_preserve_float16: Bool32::default(),
            shader_signed_zero_inf_nan_preserve_float32: Bool32::default(),
            shader_signed_zero_inf_nan_preserve_float64: Bool32::default(),
            shader_denorm_preserve_float16: Bool32::default(),
            shader_denorm_preserve_float32: Bool32::default(),
            shader_denorm_preserve_float64: Bool32::default(),
            shader_denorm_flush_to_zero_float16: Bool32::default(),
            shader_denorm_flush_to_zero_float32: Bool32::default(),
            shader_denorm_flush_to_zero_float64: Bool32::default(),
            shader_rounding_mode_rte_float16: Bool32::default(),
            shader_rounding_mode_rte_float32: Bool32::default(),
            shader_rounding_mode_rte_float64: Bool32::default(),
            shader_rounding_mode_rtz_float16: Bool32::default(),
            shader_rounding_mode_rtz_float32: Bool32::default(),
            shader_rounding_mode_rtz_float64: Bool32::default(),
            max_update_after_bind_descriptors_in_all_pools: u32::default(),
            shader_uniform_buffer_array_non_uniform_indexing_native: Bool32::default(),
            shader_sampled_image_array_non_uniform_indexing_native: Bool32::default(),
            shader_storage_buffer_array_non_uniform_indexing_native: Bool32::default(),
            shader_storage_image_array_non_uniform_indexing_native: Bool32::default(),
            shader_input_attachment_array_non_uniform_indexing_native: Bool32::default(),
            robust_buffer_access_update_after_bind: Bool32::default(),
            quad_divergent_implicit_lod: Bool32::default(),
            max_per_stage_descriptor_update_after_bind_samplers: u32::default(),
            max_per_stage_descriptor_update_after_bind_uniform_buffers: u32::default(),
            max_per_stage_descriptor_update_after_bind_storage_buffers: u32::default(),
            max_per_stage_descriptor_update_after_bind_sampled_images: u32::default(),
            max_per_stage_descriptor_update_after_bind_storage_images: u32::default(),
            max_per_stage_descriptor_update_after_bind_input_attachments: u32::default(),
            max_per_stage_update_after_bind_resources: u32::default(),
            max_descriptor_set_update_after_bind_samplers: u32::default(),
            max_descriptor_set_update_after_bind_uniform_buffers: u32::default(),
            max_descriptor_set_update_after_bind_uniform_buffers_dynamic: u32::default(),
            max_descriptor_set_update_after_bind_storage_buffers: u32::default(),
            max_descriptor_set_update_after_bind_storage_buffers_dynamic: u32::default(),
            max_descriptor_set_update_after_bind_sampled_images: u32::default(),
            max_descriptor_set_update_after_bind_storage_images: u32::default(),
            max_descriptor_set_update_after_bind_input_attachments: u32::default(),
            supported_depth_resolve_modes: ResolveModeFlags::default(),
            supported_stencil_resolve_modes: ResolveModeFlags::default(),
            independent_resolve_none: Bool32::default(),
            independent_resolve: Bool32::default(),
            filter_minmax_single_component_formats: Bool32::default(),
            filter_minmax_image_component_mapping: Bool32::default(),
            max_timeline_semaphore_value_difference: u64::default(),
            framebuffer_integer_color_sample_counts: SampleCountFlags::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceVulkan12Properties<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES;
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceVulkan12Properties<'_> {}
impl<'a> PhysicalDeviceVulkan12Properties<'a> {
    #[inline]
    pub fn driver_id(mut self, driver_id: DriverId) -> Self {
        self.driver_id = driver_id;
        self
    }
    #[inline]
    pub fn driver_name(mut self, driver_name: [c_char; MAX_DRIVER_NAME_SIZE]) -> Self {
        self.driver_name = driver_name;
        self
    }
    #[inline]
    pub fn driver_info(mut self, driver_info: [c_char; MAX_DRIVER_INFO_SIZE]) -> Self {
        self.driver_info = driver_info;
        self
    }
    #[inline]
    pub fn conformance_version(mut self, conformance_version: ConformanceVersion) -> Self {
        self.conformance_version = conformance_version;
        self
    }
    #[inline]
    pub fn denorm_behavior_independence(
        mut self,
        denorm_behavior_independence: ShaderFloatControlsIndependence,
    ) -> Self {
        self.denorm_behavior_independence = denorm_behavior_independence;
        self
    }
    #[inline]
    pub fn rounding_mode_independence(
        mut self,
        rounding_mode_independence: ShaderFloatControlsIndependence,
    ) -> Self {
        self.rounding_mode_independence = rounding_mode_independence;
        self
    }
    #[inline]
    pub fn shader_signed_zero_inf_nan_preserve_float16(
        mut self,
        shader_signed_zero_inf_nan_preserve_float16: bool,
    ) -> Self {
        self.shader_signed_zero_inf_nan_preserve_float16 =
            shader_signed_zero_inf_nan_preserve_float16.into();
        self
    }
    #[inline]
    pub fn shader_signed_zero_inf_nan_preserve_float32(
        mut self,
        shader_signed_zero_inf_nan_preserve_float32: bool,
    ) -> Self {
        self.shader_signed_zero_inf_nan_preserve_float32 =
            shader_signed_zero_inf_nan_preserve_float32.into();
        self
    }
    #[inline]
    pub fn shader_signed_zero_inf_nan_preserve_float64(
        mut self,
        shader_signed_zero_inf_nan_preserve_float64: bool,
    ) -> Self {
        self.shader_signed_zero_inf_nan_preserve_float64 =
            shader_signed_zero_inf_nan_preserve_float64.into();
        self
    }
    #[inline]
    pub fn shader_denorm_preserve_float16(mut self, shader_denorm_preserve_float16: bool) -> Self {
        self.shader_denorm_preserve_float16 = shader_denorm_preserve_float16.into();
        self
    }
    #[inline]
    pub fn shader_denorm_preserve_float32(mut self, shader_denorm_preserve_float32: bool) -> Self {
        self.shader_denorm_preserve_float32 = shader_denorm_preserve_float32.into();
        self
    }
    #[inline]
    pub fn shader_denorm_preserve_float64(mut self, shader_denorm_preserve_float64: bool) -> Self {
        self.shader_denorm_preserve_float64 = shader_denorm_preserve_float64.into();
        self
    }
    #[inline]
    pub fn shader_denorm_flush_to_zero_float16(
        mut self,
        shader_denorm_flush_to_zero_float16: bool,
    ) -> Self {
        self.shader_denorm_flush_to_zero_float16 = shader_denorm_flush_to_zero_float16.into();
        self
    }
    #[inline]
    pub fn shader_denorm_flush_to_zero_float32(
        mut self,
        shader_denorm_flush_to_zero_float32: bool,
    ) -> Self {
        self.shader_denorm_flush_to_zero_float32 = shader_denorm_flush_to_zero_float32.into();
        self
    }
    #[inline]
    pub fn shader_denorm_flush_to_zero_float64(
        mut self,
        shader_denorm_flush_to_zero_float64: bool,
    ) -> Self {
        self.shader_denorm_flush_to_zero_float64 = shader_denorm_flush_to_zero_float64.into();
        self
    }
    #[inline]
    pub fn shader_rounding_mode_rte_float16(
        mut self,
        shader_rounding_mode_rte_float16: bool,
    ) -> Self {
        self.shader_rounding_mode_rte_float16 = shader_rounding_mode_rte_float16.into();
        self
    }
    #[inline]
    pub fn shader_rounding_mode_rte_float32(
        mut self,
        shader_rounding_mode_rte_float32: bool,
    ) -> Self {
        self.shader_rounding_mode_rte_float32 = shader_rounding_mode_rte_float32.into();
        self
    }
    #[inline]
    pub fn shader_rounding_mode_rte_float64(
        mut self,
        shader_rounding_mode_rte_float64: bool,
    ) -> Self {
        self.shader_rounding_mode_rte_float64 = shader_rounding_mode_rte_float64.into();
        self
    }
    #[inline]
    pub fn shader_rounding_mode_rtz_float16(
        mut self,
        shader_rounding_mode_rtz_float16: bool,
    ) -> Self {
        self.shader_rounding_mode_rtz_float16 = shader_rounding_mode_rtz_float16.into();
        self
    }
    #[inline]
    pub fn shader_rounding_mode_rtz_float32(
        mut self,
        shader_rounding_mode_rtz_float32: bool,
    ) -> Self {
        self.shader_rounding_mode_rtz_float32 = shader_rounding_mode_rtz_float32.into();
        self
    }
    #[inline]
    pub fn shader_rounding_mode_rtz_float64(
        mut self,
        shader_rounding_mode_rtz_float64: bool,
    ) -> Self {
        self.shader_rounding_mode_rtz_float64 = shader_rounding_mode_rtz_float64.into();
        self
    }
    #[inline]
    pub fn max_update_after_bind_descriptors_in_all_pools(
        mut self,
        max_update_after_bind_descriptors_in_all_pools: u32,
    ) -> Self {
        self.max_update_after_bind_descriptors_in_all_pools =
            max_update_after_bind_descriptors_in_all_pools;
        self
    }
    #[inline]
    pub fn shader_uniform_buffer_array_non_uniform_indexing_native(
        mut self,
        shader_uniform_buffer_array_non_uniform_indexing_native: bool,
    ) -> Self {
        self.shader_uniform_buffer_array_non_uniform_indexing_native =
            shader_uniform_buffer_array_non_uniform_indexing_native.into();
        self
    }
    #[inline]
    pub fn shader_sampled_image_array_non_uniform_indexing_native(
        mut self,
        shader_sampled_image_array_non_uniform_indexing_native: bool,
    ) -> Self {
        self.shader_sampled_image_array_non_uniform_indexing_native =
            shader_sampled_image_array_non_uniform_indexing_native.into();
        self
    }
    #[inline]
    pub fn shader_storage_buffer_array_non_uniform_indexing_native(
        mut self,
        shader_storage_buffer_array_non_uniform_indexing_native: bool,
    ) -> Self {
        self.shader_storage_buffer_array_non_uniform_indexing_native =
            shader_storage_buffer_array_non_uniform_indexing_native.into();
        self
    }
    #[inline]
    pub fn shader_storage_image_array_non_uniform_indexing_native(
        mut self,
        shader_storage_image_array_non_uniform_indexing_native: bool,
    ) -> Self {
        self.shader_storage_image_array_non_uniform_indexing_native =
            shader_storage_image_array_non_uniform_indexing_native.into();
        self
    }
    #[inline]
    pub fn shader_input_attachment_array_non_uniform_indexing_native(
        mut self,
        shader_input_attachment_array_non_uniform_indexing_native: bool,
    ) -> Self {
        self.shader_input_attachment_array_non_uniform_indexing_native =
            shader_input_attachment_array_non_uniform_indexing_native.into();
        self
    }
    #[inline]
    pub fn robust_buffer_access_update_after_bind(
        mut self,
        robust_buffer_access_update_after_bind: bool,
    ) -> Self {
        self.robust_buffer_access_update_after_bind = robust_buffer_access_update_after_bind.into();
        self
    }
    #[inline]
    pub fn quad_divergent_implicit_lod(mut self, quad_divergent_implicit_lod: bool) -> Self {
        self.quad_divergent_implicit_lod = quad_divergent_implicit_lod.into();
        self
    }
    #[inline]
    pub fn max_per_stage_descriptor_update_after_bind_samplers(
        mut self,
        max_per_stage_descriptor_update_after_bind_samplers: u32,
    ) -> Self {
        self.max_per_stage_descriptor_update_after_bind_samplers =
            max_per_stage_descriptor_update_after_bind_samplers;
        self
    }
    #[inline]
    pub fn max_per_stage_descriptor_update_after_bind_uniform_buffers(
        mut self,
        max_per_stage_descriptor_update_after_bind_uniform_buffers: u32,
    ) -> Self {
        self.max_per_stage_descriptor_update_after_bind_uniform_buffers =
            max_per_stage_descriptor_update_after_bind_uniform_buffers;
        self
    }
    #[inline]
    pub fn max_per_stage_descriptor_update_after_bind_storage_buffers(
        mut self,
        max_per_stage_descriptor_update_after_bind_storage_buffers: u32,
    ) -> Self {
        self.max_per_stage_descriptor_update_after_bind_storage_buffers =
            max_per_stage_descriptor_update_after_bind_storage_buffers;
        self
    }
    #[inline]
    pub fn max_per_stage_descriptor_update_after_bind_sampled_images(
        mut self,
        max_per_stage_descriptor_update_after_bind_sampled_images: u32,
    ) -> Self {
        self.max_per_stage_descriptor_update_after_bind_sampled_images =
            max_per_stage_descriptor_update_after_bind_sampled_images;
        self
    }
    #[inline]
    pub fn max_per_stage_descriptor_update_after_bind_storage_images(
        mut self,
        max_per_stage_descriptor_update_after_bind_storage_images: u32,
    ) -> Self {
        self.max_per_stage_descriptor_update_after_bind_storage_images =
            max_per_stage_descriptor_update_after_bind_storage_images;
        self
    }
    #[inline]
    pub fn max_per_stage_descriptor_update_after_bind_input_attachments(
        mut self,
        max_per_stage_descriptor_update_after_bind_input_attachments: u32,
    ) -> Self {
        self.max_per_stage_descriptor_update_after_bind_input_attachments =
            max_per_stage_descriptor_update_after_bind_input_attachments;
        self
    }
    #[inline]
    pub fn max_per_stage_update_after_bind_resources(
        mut self,
        max_per_stage_update_after_bind_resources: u32,
    ) -> Self {
        self.max_per_stage_update_after_bind_resources = max_per_stage_update_after_bind_resources;
        self
    }
    #[inline]
    pub fn max_descriptor_set_update_after_bind_samplers(
        mut self,
        max_descriptor_set_update_after_bind_samplers: u32,
    ) -> Self {
        self.max_descriptor_set_update_after_bind_samplers =
            max_descriptor_set_update_after_bind_samplers;
        self
    }
    #[inline]
    pub fn max_descriptor_set_update_after_bind_uniform_buffers(
        mut self,
        max_descriptor_set_update_after_bind_uniform_buffers: u32,
    ) -> Self {
        self.max_descriptor_set_update_after_bind_uniform_buffers =
            max_descriptor_set_update_after_bind_uniform_buffers;
        self
    }
    #[inline]
    pub fn max_descriptor_set_update_after_bind_uniform_buffers_dynamic(
        mut self,
        max_descriptor_set_update_after_bind_uniform_buffers_dynamic: u32,
    ) -> Self {
        self.max_descriptor_set_update_after_bind_uniform_buffers_dynamic =
            max_descriptor_set_update_after_bind_uniform_buffers_dynamic;
        self
    }
    #[inline]
    pub fn max_descriptor_set_update_after_bind_storage_buffers(
        mut self,
        max_descriptor_set_update_after_bind_storage_buffers: u32,
    ) -> Self {
        self.max_descriptor_set_update_after_bind_storage_buffers =
            max_descriptor_set_update_after_bind_storage_buffers;
        self
    }
    #[inline]
    pub fn max_descriptor_set_update_after_bind_storage_buffers_dynamic(
        mut self,
        max_descriptor_set_update_after_bind_storage_buffers_dynamic: u32,
    ) -> Self {
        self.max_descriptor_set_update_after_bind_storage_buffers_dynamic =
            max_descriptor_set_update_after_bind_storage_buffers_dynamic;
        self
    }
    #[inline]
    pub fn max_descriptor_set_update_after_bind_sampled_images(
        mut self,
        max_descriptor_set_update_after_bind_sampled_images: u32,
    ) -> Self {
        self.max_descriptor_set_update_after_bind_sampled_images =
            max_descriptor_set_update_after_bind_sampled_images;
        self
    }
    #[inline]
    pub fn max_descriptor_set_update_after_bind_storage_images(
        mut self,
        max_descriptor_set_update_after_bind_storage_images: u32,
    ) -> Self {
        self.max_descriptor_set_update_after_bind_storage_images =
            max_descriptor_set_update_after_bind_storage_images;
        self
    }
    #[inline]
    pub fn max_descriptor_set_update_after_bind_input_attachments(
        mut self,
        max_descriptor_set_update_after_bind_input_attachments: u32,
    ) -> Self {
        self.max_descriptor_set_update_after_bind_input_attachments =
            max_descriptor_set_update_after_bind_input_attachments;
        self
    }
    #[inline]
    pub fn supported_depth_resolve_modes(
        mut self,
        supported_depth_resolve_modes: ResolveModeFlags,
    ) -> Self {
        self.supported_depth_resolve_modes = supported_depth_resolve_modes;
        self
    }
    #[inline]
    pub fn supported_stencil_resolve_modes(
        mut self,
        supported_stencil_resolve_modes: ResolveModeFlags,
    ) -> Self {
        self.supported_stencil_resolve_modes = supported_stencil_resolve_modes;
        self
    }
    #[inline]
    pub fn independent_resolve_none(mut self, independent_resolve_none: bool) -> Self {
        self.independent_resolve_none = independent_resolve_none.into();
        self
    }
    #[inline]
    pub fn independent_resolve(mut self, independent_resolve: bool) -> Self {
        self.independent_resolve = independent_resolve.into();
        self
    }
    #[inline]
    pub fn filter_minmax_single_component_formats(
        mut self,
        filter_minmax_single_component_formats: bool,
    ) -> Self {
        self.filter_minmax_single_component_formats = filter_minmax_single_component_formats.into();
        self
    }
    #[inline]
    pub fn filter_minmax_image_component_mapping(
        mut self,
        filter_minmax_image_component_mapping: bool,
    ) -> Self {
        self.filter_minmax_image_component_mapping = filter_minmax_image_component_mapping.into();
        self
    }
    #[inline]
    pub fn max_timeline_semaphore_value_difference(
        mut self,
        max_timeline_semaphore_value_difference: u64,
    ) -> Self {
        self.max_timeline_semaphore_value_difference = max_timeline_semaphore_value_difference;
        self
    }
    #[inline]
    pub fn framebuffer_integer_color_sample_counts(
        mut self,
        framebuffer_integer_color_sample_counts: SampleCountFlags,
    ) -> Self {
        self.framebuffer_integer_color_sample_counts = framebuffer_integer_color_sample_counts;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan13Features.html>"]
pub struct PhysicalDeviceVulkan13Features<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub robust_image_access: Bool32,
    pub inline_uniform_block: Bool32,
    pub descriptor_binding_inline_uniform_block_update_after_bind: Bool32,
    pub pipeline_creation_cache_control: Bool32,
    pub private_data: Bool32,
    pub shader_demote_to_helper_invocation: Bool32,
    pub shader_terminate_invocation: Bool32,
    pub subgroup_size_control: Bool32,
    pub compute_full_subgroups: Bool32,
    pub synchronization2: Bool32,
    pub texture_compression_astc_hdr: Bool32,
    pub shader_zero_initialize_workgroup_memory: Bool32,
    pub dynamic_rendering: Bool32,
    pub shader_integer_dot_product: Bool32,
    pub maintenance4: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceVulkan13Features<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            robust_image_access: Bool32::default(),
            inline_uniform_block: Bool32::default(),
            descriptor_binding_inline_uniform_block_update_after_bind: Bool32::default(),
            pipeline_creation_cache_control: Bool32::default(),
            private_data: Bool32::default(),
            shader_demote_to_helper_invocation: Bool32::default(),
            shader_terminate_invocation: Bool32::default(),
            subgroup_size_control: Bool32::default(),
            compute_full_subgroups: Bool32::default(),
            synchronization2: Bool32::default(),
            texture_compression_astc_hdr: Bool32::default(),
            shader_zero_initialize_workgroup_memory: Bool32::default(),
            dynamic_rendering: Bool32::default(),
            shader_integer_dot_product: Bool32::default(),
            maintenance4: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceVulkan13Features<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_VULKAN_1_3_FEATURES;
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceVulkan13Features<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceVulkan13Features<'_> {}
impl<'a> PhysicalDeviceVulkan13Features<'a> {
    #[inline]
    pub fn robust_image_access(mut self, robust_image_access: bool) -> Self {
        self.robust_image_access = robust_image_access.into();
        self
    }
    #[inline]
    pub fn inline_uniform_block(mut self, inline_uniform_block: bool) -> Self {
        self.inline_uniform_block = inline_uniform_block.into();
        self
    }
    #[inline]
    pub fn descriptor_binding_inline_uniform_block_update_after_bind(
        mut self,
        descriptor_binding_inline_uniform_block_update_after_bind: bool,
    ) -> Self {
        self.descriptor_binding_inline_uniform_block_update_after_bind =
            descriptor_binding_inline_uniform_block_update_after_bind.into();
        self
    }
    #[inline]
    pub fn pipeline_creation_cache_control(
        mut self,
        pipeline_creation_cache_control: bool,
    ) -> Self {
        self.pipeline_creation_cache_control = pipeline_creation_cache_control.into();
        self
    }
    #[inline]
    pub fn private_data(mut self, private_data: bool) -> Self {
        self.private_data = private_data.into();
        self
    }
    #[inline]
    pub fn shader_demote_to_helper_invocation(
        mut self,
        shader_demote_to_helper_invocation: bool,
    ) -> Self {
        self.shader_demote_to_helper_invocation = shader_demote_to_helper_invocation.into();
        self
    }
    #[inline]
    pub fn shader_terminate_invocation(mut self, shader_terminate_invocation: bool) -> Self {
        self.shader_terminate_invocation = shader_terminate_invocation.into();
        self
    }
    #[inline]
    pub fn subgroup_size_control(mut self, subgroup_size_control: bool) -> Self {
        self.subgroup_size_control = subgroup_size_control.into();
        self
    }
    #[inline]
    pub fn compute_full_subgroups(mut self, compute_full_subgroups: bool) -> Self {
        self.compute_full_subgroups = compute_full_subgroups.into();
        self
    }
    #[inline]
    pub fn synchronization2(mut self, synchronization2: bool) -> Self {
        self.synchronization2 = synchronization2.into();
        self
    }
    #[inline]
    pub fn texture_compression_astc_hdr(mut self, texture_compression_astc_hdr: bool) -> Self {
        self.texture_compression_astc_hdr = texture_compression_astc_hdr.into();
        self
    }
    #[inline]
    pub fn shader_zero_initialize_workgroup_memory(
        mut self,
        shader_zero_initialize_workgroup_memory: bool,
    ) -> Self {
        self.shader_zero_initialize_workgroup_memory =
            shader_zero_initialize_workgroup_memory.into();
        self
    }
    #[inline]
    pub fn dynamic_rendering(mut self, dynamic_rendering: bool) -> Self {
        self.dynamic_rendering = dynamic_rendering.into();
        self
    }
    #[inline]
    pub fn shader_integer_dot_product(mut self, shader_integer_dot_product: bool) -> Self {
        self.shader_integer_dot_product = shader_integer_dot_product.into();
        self
    }
    #[inline]
    pub fn maintenance4(mut self, maintenance4: bool) -> Self {
        self.maintenance4 = maintenance4.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan13Properties.html>"]
pub struct PhysicalDeviceVulkan13Properties<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub min_subgroup_size: u32,
    pub max_subgroup_size: u32,
    pub max_compute_workgroup_subgroups: u32,
    pub required_subgroup_size_stages: ShaderStageFlags,
    pub max_inline_uniform_block_size: u32,
    pub max_per_stage_descriptor_inline_uniform_blocks: u32,
    pub max_per_stage_descriptor_update_after_bind_inline_uniform_blocks: u32,
    pub max_descriptor_set_inline_uniform_blocks: u32,
    pub max_descriptor_set_update_after_bind_inline_uniform_blocks: u32,
    pub max_inline_uniform_total_size: u32,
    pub integer_dot_product8_bit_unsigned_accelerated: Bool32,
    pub integer_dot_product8_bit_signed_accelerated: Bool32,
    pub integer_dot_product8_bit_mixed_signedness_accelerated: Bool32,
    pub integer_dot_product4x8_bit_packed_unsigned_accelerated: Bool32,
    pub integer_dot_product4x8_bit_packed_signed_accelerated: Bool32,
    pub integer_dot_product4x8_bit_packed_mixed_signedness_accelerated: Bool32,
    pub integer_dot_product16_bit_unsigned_accelerated: Bool32,
    pub integer_dot_product16_bit_signed_accelerated: Bool32,
    pub integer_dot_product16_bit_mixed_signedness_accelerated: Bool32,
    pub integer_dot_product32_bit_unsigned_accelerated: Bool32,
    pub integer_dot_product32_bit_signed_accelerated: Bool32,
    pub integer_dot_product32_bit_mixed_signedness_accelerated: Bool32,
    pub integer_dot_product64_bit_unsigned_accelerated: Bool32,
    pub integer_dot_product64_bit_signed_accelerated: Bool32,
    pub integer_dot_product64_bit_mixed_signedness_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating8_bit_signed_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated:
        Bool32,
    pub integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating16_bit_signed_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating32_bit_signed_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating64_bit_signed_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated: Bool32,
    pub storage_texel_buffer_offset_alignment_bytes: DeviceSize,
    pub storage_texel_buffer_offset_single_texel_alignment: Bool32,
    pub uniform_texel_buffer_offset_alignment_bytes: DeviceSize,
    pub uniform_texel_buffer_offset_single_texel_alignment: Bool32,
    pub max_buffer_size: DeviceSize,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceVulkan13Properties<'_> {
    #[inline]
    fn default() -> Self {
        Self { s_type : Self :: STRUCTURE_TYPE , p_next : :: std :: ptr :: null_mut () , min_subgroup_size : u32 :: default () , max_subgroup_size : u32 :: default () , max_compute_workgroup_subgroups : u32 :: default () , required_subgroup_size_stages : ShaderStageFlags :: default () , max_inline_uniform_block_size : u32 :: default () , max_per_stage_descriptor_inline_uniform_blocks : u32 :: default () , max_per_stage_descriptor_update_after_bind_inline_uniform_blocks : u32 :: default () , max_descriptor_set_inline_uniform_blocks : u32 :: default () , max_descriptor_set_update_after_bind_inline_uniform_blocks : u32 :: default () , max_inline_uniform_total_size : u32 :: default () , integer_dot_product8_bit_unsigned_accelerated : Bool32 :: default () , integer_dot_product8_bit_signed_accelerated : Bool32 :: default () , integer_dot_product8_bit_mixed_signedness_accelerated : Bool32 :: default () , integer_dot_product4x8_bit_packed_unsigned_accelerated : Bool32 :: default () , integer_dot_product4x8_bit_packed_signed_accelerated : Bool32 :: default () , integer_dot_product4x8_bit_packed_mixed_signedness_accelerated : Bool32 :: default () , integer_dot_product16_bit_unsigned_accelerated : Bool32 :: default () , integer_dot_product16_bit_signed_accelerated : Bool32 :: default () , integer_dot_product16_bit_mixed_signedness_accelerated : Bool32 :: default () , integer_dot_product32_bit_unsigned_accelerated : Bool32 :: default () , integer_dot_product32_bit_signed_accelerated : Bool32 :: default () , integer_dot_product32_bit_mixed_signedness_accelerated : Bool32 :: default () , integer_dot_product64_bit_unsigned_accelerated : Bool32 :: default () , integer_dot_product64_bit_signed_accelerated : Bool32 :: default () , integer_dot_product64_bit_mixed_signedness_accelerated : Bool32 :: default () , integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated : Bool32 :: default () , integer_dot_product_accumulating_saturating8_bit_signed_accelerated : Bool32 :: default () , integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated : Bool32 :: default () , integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated : Bool32 :: default () , integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated : Bool32 :: default () , integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated : Bool32 :: default () , integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated : Bool32 :: default () , integer_dot_product_accumulating_saturating16_bit_signed_accelerated : Bool32 :: default () , integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated : Bool32 :: default () , integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated : Bool32 :: default () , integer_dot_product_accumulating_saturating32_bit_signed_accelerated : Bool32 :: default () , integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated : Bool32 :: default () , integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated : Bool32 :: default () , integer_dot_product_accumulating_saturating64_bit_signed_accelerated : Bool32 :: default () , integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated : Bool32 :: default () , storage_texel_buffer_offset_alignment_bytes : DeviceSize :: default () , storage_texel_buffer_offset_single_texel_alignment : Bool32 :: default () , uniform_texel_buffer_offset_alignment_bytes : DeviceSize :: default () , uniform_texel_buffer_offset_single_texel_alignment : Bool32 :: default () , max_buffer_size : DeviceSize :: default () , _marker : PhantomData , }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceVulkan13Properties<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES;
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceVulkan13Properties<'_> {}
impl<'a> PhysicalDeviceVulkan13Properties<'a> {
    #[inline]
    pub fn min_subgroup_size(mut self, min_subgroup_size: u32) -> Self {
        self.min_subgroup_size = min_subgroup_size;
        self
    }
    #[inline]
    pub fn max_subgroup_size(mut self, max_subgroup_size: u32) -> Self {
        self.max_subgroup_size = max_subgroup_size;
        self
    }
    #[inline]
    pub fn max_compute_workgroup_subgroups(mut self, max_compute_workgroup_subgroups: u32) -> Self {
        self.max_compute_workgroup_subgroups = max_compute_workgroup_subgroups;
        self
    }
    #[inline]
    pub fn required_subgroup_size_stages(
        mut self,
        required_subgroup_size_stages: ShaderStageFlags,
    ) -> Self {
        self.required_subgroup_size_stages = required_subgroup_size_stages;
        self
    }
    #[inline]
    pub fn max_inline_uniform_block_size(mut self, max_inline_uniform_block_size: u32) -> Self {
        self.max_inline_uniform_block_size = max_inline_uniform_block_size;
        self
    }
    #[inline]
    pub fn max_per_stage_descriptor_inline_uniform_blocks(
        mut self,
        max_per_stage_descriptor_inline_uniform_blocks: u32,
    ) -> Self {
        self.max_per_stage_descriptor_inline_uniform_blocks =
            max_per_stage_descriptor_inline_uniform_blocks;
        self
    }
    #[inline]
    pub fn max_per_stage_descriptor_update_after_bind_inline_uniform_blocks(
        mut self,
        max_per_stage_descriptor_update_after_bind_inline_uniform_blocks: u32,
    ) -> Self {
        self.max_per_stage_descriptor_update_after_bind_inline_uniform_blocks =
            max_per_stage_descriptor_update_after_bind_inline_uniform_blocks;
        self
    }
    #[inline]
    pub fn max_descriptor_set_inline_uniform_blocks(
        mut self,
        max_descriptor_set_inline_uniform_blocks: u32,
    ) -> Self {
        self.max_descriptor_set_inline_uniform_blocks = max_descriptor_set_inline_uniform_blocks;
        self
    }
    #[inline]
    pub fn max_descriptor_set_update_after_bind_inline_uniform_blocks(
        mut self,
        max_descriptor_set_update_after_bind_inline_uniform_blocks: u32,
    ) -> Self {
        self.max_descriptor_set_update_after_bind_inline_uniform_blocks =
            max_descriptor_set_update_after_bind_inline_uniform_blocks;
        self
    }
    #[inline]
    pub fn max_inline_uniform_total_size(mut self, max_inline_uniform_total_size: u32) -> Self {
        self.max_inline_uniform_total_size = max_inline_uniform_total_size;
        self
    }
    #[inline]
    pub fn integer_dot_product8_bit_unsigned_accelerated(
        mut self,
        integer_dot_product8_bit_unsigned_accelerated: bool,
    ) -> Self {
        self.integer_dot_product8_bit_unsigned_accelerated =
            integer_dot_product8_bit_unsigned_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product8_bit_signed_accelerated(
        mut self,
        integer_dot_product8_bit_signed_accelerated: bool,
    ) -> Self {
        self.integer_dot_product8_bit_signed_accelerated =
            integer_dot_product8_bit_signed_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product8_bit_mixed_signedness_accelerated(
        mut self,
        integer_dot_product8_bit_mixed_signedness_accelerated: bool,
    ) -> Self {
        self.integer_dot_product8_bit_mixed_signedness_accelerated =
            integer_dot_product8_bit_mixed_signedness_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product4x8_bit_packed_unsigned_accelerated(
        mut self,
        integer_dot_product4x8_bit_packed_unsigned_accelerated: bool,
    ) -> Self {
        self.integer_dot_product4x8_bit_packed_unsigned_accelerated =
            integer_dot_product4x8_bit_packed_unsigned_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product4x8_bit_packed_signed_accelerated(
        mut self,
        integer_dot_product4x8_bit_packed_signed_accelerated: bool,
    ) -> Self {
        self.integer_dot_product4x8_bit_packed_signed_accelerated =
            integer_dot_product4x8_bit_packed_signed_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product4x8_bit_packed_mixed_signedness_accelerated(
        mut self,
        integer_dot_product4x8_bit_packed_mixed_signedness_accelerated: bool,
    ) -> Self {
        self.integer_dot_product4x8_bit_packed_mixed_signedness_accelerated =
            integer_dot_product4x8_bit_packed_mixed_signedness_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product16_bit_unsigned_accelerated(
        mut self,
        integer_dot_product16_bit_unsigned_accelerated: bool,
    ) -> Self {
        self.integer_dot_product16_bit_unsigned_accelerated =
            integer_dot_product16_bit_unsigned_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product16_bit_signed_accelerated(
        mut self,
        integer_dot_product16_bit_signed_accelerated: bool,
    ) -> Self {
        self.integer_dot_product16_bit_signed_accelerated =
            integer_dot_product16_bit_signed_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product16_bit_mixed_signedness_accelerated(
        mut self,
        integer_dot_product16_bit_mixed_signedness_accelerated: bool,
    ) -> Self {
        self.integer_dot_product16_bit_mixed_signedness_accelerated =
            integer_dot_product16_bit_mixed_signedness_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product32_bit_unsigned_accelerated(
        mut self,
        integer_dot_product32_bit_unsigned_accelerated: bool,
    ) -> Self {
        self.integer_dot_product32_bit_unsigned_accelerated =
            integer_dot_product32_bit_unsigned_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product32_bit_signed_accelerated(
        mut self,
        integer_dot_product32_bit_signed_accelerated: bool,
    ) -> Self {
        self.integer_dot_product32_bit_signed_accelerated =
            integer_dot_product32_bit_signed_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product32_bit_mixed_signedness_accelerated(
        mut self,
        integer_dot_product32_bit_mixed_signedness_accelerated: bool,
    ) -> Self {
        self.integer_dot_product32_bit_mixed_signedness_accelerated =
            integer_dot_product32_bit_mixed_signedness_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product64_bit_unsigned_accelerated(
        mut self,
        integer_dot_product64_bit_unsigned_accelerated: bool,
    ) -> Self {
        self.integer_dot_product64_bit_unsigned_accelerated =
            integer_dot_product64_bit_unsigned_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product64_bit_signed_accelerated(
        mut self,
        integer_dot_product64_bit_signed_accelerated: bool,
    ) -> Self {
        self.integer_dot_product64_bit_signed_accelerated =
            integer_dot_product64_bit_signed_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product64_bit_mixed_signedness_accelerated(
        mut self,
        integer_dot_product64_bit_mixed_signedness_accelerated: bool,
    ) -> Self {
        self.integer_dot_product64_bit_mixed_signedness_accelerated =
            integer_dot_product64_bit_mixed_signedness_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated(
        mut self,
        integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated: bool,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated =
            integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product_accumulating_saturating8_bit_signed_accelerated(
        mut self,
        integer_dot_product_accumulating_saturating8_bit_signed_accelerated: bool,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating8_bit_signed_accelerated =
            integer_dot_product_accumulating_saturating8_bit_signed_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated(
        mut self,
        integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated: bool,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated =
            integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated(
        mut self,
        integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated: bool,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated =
            integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated(
        mut self,
        integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated: bool,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated =
            integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated(
        mut self,
        integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated : bool,
    ) -> Self {
        self . integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated = integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated . into () ;
        self
    }
    #[inline]
    pub fn integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated(
        mut self,
        integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated: bool,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated =
            integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product_accumulating_saturating16_bit_signed_accelerated(
        mut self,
        integer_dot_product_accumulating_saturating16_bit_signed_accelerated: bool,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating16_bit_signed_accelerated =
            integer_dot_product_accumulating_saturating16_bit_signed_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated(
        mut self,
        integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated: bool,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated =
            integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated(
        mut self,
        integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated: bool,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated =
            integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product_accumulating_saturating32_bit_signed_accelerated(
        mut self,
        integer_dot_product_accumulating_saturating32_bit_signed_accelerated: bool,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating32_bit_signed_accelerated =
            integer_dot_product_accumulating_saturating32_bit_signed_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated(
        mut self,
        integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated: bool,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated =
            integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated(
        mut self,
        integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated: bool,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated =
            integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product_accumulating_saturating64_bit_signed_accelerated(
        mut self,
        integer_dot_product_accumulating_saturating64_bit_signed_accelerated: bool,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating64_bit_signed_accelerated =
            integer_dot_product_accumulating_saturating64_bit_signed_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated(
        mut self,
        integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated: bool,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated =
            integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated.into();
        self
    }
    #[inline]
    pub fn storage_texel_buffer_offset_alignment_bytes(
        mut self,
        storage_texel_buffer_offset_alignment_bytes: DeviceSize,
    ) -> Self {
        self.storage_texel_buffer_offset_alignment_bytes =
            storage_texel_buffer_offset_alignment_bytes;
        self
    }
    #[inline]
    pub fn storage_texel_buffer_offset_single_texel_alignment(
        mut self,
        storage_texel_buffer_offset_single_texel_alignment: bool,
    ) -> Self {
        self.storage_texel_buffer_offset_single_texel_alignment =
            storage_texel_buffer_offset_single_texel_alignment.into();
        self
    }
    #[inline]
    pub fn uniform_texel_buffer_offset_alignment_bytes(
        mut self,
        uniform_texel_buffer_offset_alignment_bytes: DeviceSize,
    ) -> Self {
        self.uniform_texel_buffer_offset_alignment_bytes =
            uniform_texel_buffer_offset_alignment_bytes;
        self
    }
    #[inline]
    pub fn uniform_texel_buffer_offset_single_texel_alignment(
        mut self,
        uniform_texel_buffer_offset_single_texel_alignment: bool,
    ) -> Self {
        self.uniform_texel_buffer_offset_single_texel_alignment =
            uniform_texel_buffer_offset_single_texel_alignment.into();
        self
    }
    #[inline]
    pub fn max_buffer_size(mut self, max_buffer_size: DeviceSize) -> Self {
        self.max_buffer_size = max_buffer_size;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineCompilerControlCreateInfoAMD.html>"]
pub struct PipelineCompilerControlCreateInfoAMD<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub compiler_control_flags: PipelineCompilerControlFlagsAMD,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PipelineCompilerControlCreateInfoAMD<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            compiler_control_flags: PipelineCompilerControlFlagsAMD::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PipelineCompilerControlCreateInfoAMD<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD;
}
unsafe impl ExtendsGraphicsPipelineCreateInfo for PipelineCompilerControlCreateInfoAMD<'_> {}
unsafe impl ExtendsComputePipelineCreateInfo for PipelineCompilerControlCreateInfoAMD<'_> {}
impl<'a> PipelineCompilerControlCreateInfoAMD<'a> {
    #[inline]
    pub fn compiler_control_flags(
        mut self,
        compiler_control_flags: PipelineCompilerControlFlagsAMD,
    ) -> Self {
        self.compiler_control_flags = compiler_control_flags;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceCoherentMemoryFeaturesAMD.html>"]
pub struct PhysicalDeviceCoherentMemoryFeaturesAMD<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub device_coherent_memory: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceCoherentMemoryFeaturesAMD<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            device_coherent_memory: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceCoherentMemoryFeaturesAMD<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD;
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceCoherentMemoryFeaturesAMD<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceCoherentMemoryFeaturesAMD<'_> {}
impl<'a> PhysicalDeviceCoherentMemoryFeaturesAMD<'a> {
    #[inline]
    pub fn device_coherent_memory(mut self, device_coherent_memory: bool) -> Self {
        self.device_coherent_memory = device_coherent_memory.into();
        self
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceToolProperties.html>"]
pub struct PhysicalDeviceToolProperties<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub name: [c_char; MAX_EXTENSION_NAME_SIZE],
    pub version: [c_char; MAX_EXTENSION_NAME_SIZE],
    pub purposes: ToolPurposeFlags,
    pub description: [c_char; MAX_DESCRIPTION_SIZE],
    pub layer: [c_char; MAX_EXTENSION_NAME_SIZE],
    pub _marker: PhantomData<&'a ()>,
}
#[cfg(feature = "debug")]
impl fmt::Debug for PhysicalDeviceToolProperties<'_> {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceToolProperties")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("name", &unsafe {
                ::std::ffi::CStr::from_ptr(self.name.as_ptr())
            })
            .field("version", &unsafe {
                ::std::ffi::CStr::from_ptr(self.version.as_ptr())
            })
            .field("purposes", &self.purposes)
            .field("description", &unsafe {
                ::std::ffi::CStr::from_ptr(self.description.as_ptr())
            })
            .field("layer", &unsafe {
                ::std::ffi::CStr::from_ptr(self.layer.as_ptr())
            })
            .finish()
    }
}
impl ::std::default::Default for PhysicalDeviceToolProperties<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            name: unsafe { ::std::mem::zeroed() },
            version: unsafe { ::std::mem::zeroed() },
            purposes: ToolPurposeFlags::default(),
            description: unsafe { ::std::mem::zeroed() },
            layer: unsafe { ::std::mem::zeroed() },
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceToolProperties<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_TOOL_PROPERTIES;
}
impl<'a> PhysicalDeviceToolProperties<'a> {
    #[inline]
    pub fn name(mut self, name: [c_char; MAX_EXTENSION_NAME_SIZE]) -> Self {
        self.name = name;
        self
    }
    #[inline]
    pub fn version(mut self, version: [c_char; MAX_EXTENSION_NAME_SIZE]) -> Self {
        self.version = version;
        self
    }
    #[inline]
    pub fn purposes(mut self, purposes: ToolPurposeFlags) -> Self {
        self.purposes = purposes;
        self
    }
    #[inline]
    pub fn description(mut self, description: [c_char; MAX_DESCRIPTION_SIZE]) -> Self {
        self.description = description;
        self
    }
    #[inline]
    pub fn layer(mut self, layer: [c_char; MAX_EXTENSION_NAME_SIZE]) -> Self {
        self.layer = layer;
        self
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSamplerCustomBorderColorCreateInfoEXT.html>"]
pub struct SamplerCustomBorderColorCreateInfoEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub custom_border_color: ClearColorValue,
    pub format: Format,
    pub _marker: PhantomData<&'a ()>,
}
#[cfg(feature = "debug")]
impl fmt::Debug for SamplerCustomBorderColorCreateInfoEXT<'_> {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SamplerCustomBorderColorCreateInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("custom_border_color", &"union")
            .field("format", &self.format)
            .finish()
    }
}
impl ::std::default::Default for SamplerCustomBorderColorCreateInfoEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            custom_border_color: ClearColorValue::default(),
            format: Format::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for SamplerCustomBorderColorCreateInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT;
}
unsafe impl ExtendsSamplerCreateInfo for SamplerCustomBorderColorCreateInfoEXT<'_> {}
impl<'a> SamplerCustomBorderColorCreateInfoEXT<'a> {
    #[inline]
    pub fn custom_border_color(mut self, custom_border_color: ClearColorValue) -> Self {
        self.custom_border_color = custom_border_color;
        self
    }
    #[inline]
    pub fn format(mut self, format: Format) -> Self {
        self.format = format;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceCustomBorderColorPropertiesEXT.html>"]
pub struct PhysicalDeviceCustomBorderColorPropertiesEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub max_custom_border_color_samplers: u32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceCustomBorderColorPropertiesEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            max_custom_border_color_samplers: u32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceCustomBorderColorPropertiesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT;
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceCustomBorderColorPropertiesEXT<'_> {}
impl<'a> PhysicalDeviceCustomBorderColorPropertiesEXT<'a> {
    #[inline]
    pub fn max_custom_border_color_samplers(
        mut self,
        max_custom_border_color_samplers: u32,
    ) -> Self {
        self.max_custom_border_color_samplers = max_custom_border_color_samplers;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceCustomBorderColorFeaturesEXT.html>"]
pub struct PhysicalDeviceCustomBorderColorFeaturesEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub custom_border_colors: Bool32,
    pub custom_border_color_without_format: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceCustomBorderColorFeaturesEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            custom_border_colors: Bool32::default(),
            custom_border_color_without_format: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceCustomBorderColorFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT;
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceCustomBorderColorFeaturesEXT<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceCustomBorderColorFeaturesEXT<'_> {}
impl<'a> PhysicalDeviceCustomBorderColorFeaturesEXT<'a> {
    #[inline]
    pub fn custom_border_colors(mut self, custom_border_colors: bool) -> Self {
        self.custom_border_colors = custom_border_colors.into();
        self
    }
    #[inline]
    pub fn custom_border_color_without_format(
        mut self,
        custom_border_color_without_format: bool,
    ) -> Self {
        self.custom_border_color_without_format = custom_border_color_without_format.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSamplerBorderColorComponentMappingCreateInfoEXT.html>"]
pub struct SamplerBorderColorComponentMappingCreateInfoEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub components: ComponentMapping,
    pub srgb: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for SamplerBorderColorComponentMappingCreateInfoEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            components: ComponentMapping::default(),
            srgb: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for SamplerBorderColorComponentMappingCreateInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT;
}
unsafe impl ExtendsSamplerCreateInfo for SamplerBorderColorComponentMappingCreateInfoEXT<'_> {}
impl<'a> SamplerBorderColorComponentMappingCreateInfoEXT<'a> {
    #[inline]
    pub fn components(mut self, components: ComponentMapping) -> Self {
        self.components = components;
        self
    }
    #[inline]
    pub fn srgb(mut self, srgb: bool) -> Self {
        self.srgb = srgb.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceBorderColorSwizzleFeaturesEXT.html>"]
pub struct PhysicalDeviceBorderColorSwizzleFeaturesEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub border_color_swizzle: Bool32,
    pub border_color_swizzle_from_image: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceBorderColorSwizzleFeaturesEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            border_color_swizzle: Bool32::default(),
            border_color_swizzle_from_image: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceBorderColorSwizzleFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT;
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceBorderColorSwizzleFeaturesEXT<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceBorderColorSwizzleFeaturesEXT<'_> {}
impl<'a> PhysicalDeviceBorderColorSwizzleFeaturesEXT<'a> {
    #[inline]
    pub fn border_color_swizzle(mut self, border_color_swizzle: bool) -> Self {
        self.border_color_swizzle = border_color_swizzle.into();
        self
    }
    #[inline]
    pub fn border_color_swizzle_from_image(
        mut self,
        border_color_swizzle_from_image: bool,
    ) -> Self {
        self.border_color_swizzle_from_image = border_color_swizzle_from_image.into();
        self
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceOrHostAddressKHR.html>"]
pub union DeviceOrHostAddressKHR {
    pub device_address: DeviceAddress,
    pub host_address: *mut c_void,
}
impl ::std::default::Default for DeviceOrHostAddressKHR {
    #[inline]
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceOrHostAddressConstKHR.html>"]
pub union DeviceOrHostAddressConstKHR {
    pub device_address: DeviceAddress,
    pub host_address: *const c_void,
}
impl ::std::default::Default for DeviceOrHostAddressConstKHR {
    #[inline]
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAccelerationStructureGeometryTrianglesDataKHR.html>"]
pub struct AccelerationStructureGeometryTrianglesDataKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub vertex_format: Format,
    pub vertex_data: DeviceOrHostAddressConstKHR,
    pub vertex_stride: DeviceSize,
    pub max_vertex: u32,
    pub index_type: IndexType,
    pub index_data: DeviceOrHostAddressConstKHR,
    pub transform_data: DeviceOrHostAddressConstKHR,
    pub _marker: PhantomData<&'a ()>,
}
#[cfg(feature = "debug")]
impl fmt::Debug for AccelerationStructureGeometryTrianglesDataKHR<'_> {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("AccelerationStructureGeometryTrianglesDataKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("vertex_format", &self.vertex_format)
            .field("vertex_data", &"union")
            .field("vertex_stride", &self.vertex_stride)
            .field("max_vertex", &self.max_vertex)
            .field("index_type", &self.index_type)
            .field("index_data", &"union")
            .field("transform_data", &"union")
            .finish()
    }
}
impl ::std::default::Default for AccelerationStructureGeometryTrianglesDataKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            vertex_format: Format::default(),
            vertex_data: DeviceOrHostAddressConstKHR::default(),
            vertex_stride: DeviceSize::default(),
            max_vertex: u32::default(),
            index_type: IndexType::default(),
            index_data: DeviceOrHostAddressConstKHR::default(),
            transform_data: DeviceOrHostAddressConstKHR::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for AccelerationStructureGeometryTrianglesDataKHR<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR;
}
pub unsafe trait ExtendsAccelerationStructureGeometryTrianglesDataKHR {}
impl<'a> AccelerationStructureGeometryTrianglesDataKHR<'a> {
    #[inline]
    pub fn vertex_format(mut self, vertex_format: Format) -> Self {
        self.vertex_format = vertex_format;
        self
    }
    #[inline]
    pub fn vertex_data(mut self, vertex_data: DeviceOrHostAddressConstKHR) -> Self {
        self.vertex_data = vertex_data;
        self
    }
    #[inline]
    pub fn vertex_stride(mut self, vertex_stride: DeviceSize) -> Self {
        self.vertex_stride = vertex_stride;
        self
    }
    #[inline]
    pub fn max_vertex(mut self, max_vertex: u32) -> Self {
        self.max_vertex = max_vertex;
        self
    }
    #[inline]
    pub fn index_type(mut self, index_type: IndexType) -> Self {
        self.index_type = index_type;
        self
    }
    #[inline]
    pub fn index_data(mut self, index_data: DeviceOrHostAddressConstKHR) -> Self {
        self.index_data = index_data;
        self
    }
    #[inline]
    pub fn transform_data(mut self, transform_data: DeviceOrHostAddressConstKHR) -> Self {
        self.transform_data = transform_data;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `x.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsAccelerationStructureGeometryTrianglesDataKHR>(
        mut self,
        next: &'a mut T,
    ) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.p_next as _;
            self.p_next = next_ptr;
        }
        self
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAccelerationStructureGeometryAabbsDataKHR.html>"]
pub struct AccelerationStructureGeometryAabbsDataKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub data: DeviceOrHostAddressConstKHR,
    pub stride: DeviceSize,
    pub _marker: PhantomData<&'a ()>,
}
#[cfg(feature = "debug")]
impl fmt::Debug for AccelerationStructureGeometryAabbsDataKHR<'_> {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("AccelerationStructureGeometryAabbsDataKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("data", &"union")
            .field("stride", &self.stride)
            .finish()
    }
}
impl ::std::default::Default for AccelerationStructureGeometryAabbsDataKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            data: DeviceOrHostAddressConstKHR::default(),
            stride: DeviceSize::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for AccelerationStructureGeometryAabbsDataKHR<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR;
}
impl<'a> AccelerationStructureGeometryAabbsDataKHR<'a> {
    #[inline]
    pub fn data(mut self, data: DeviceOrHostAddressConstKHR) -> Self {
        self.data = data;
        self
    }
    #[inline]
    pub fn stride(mut self, stride: DeviceSize) -> Self {
        self.stride = stride;
        self
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAccelerationStructureGeometryInstancesDataKHR.html>"]
pub struct AccelerationStructureGeometryInstancesDataKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub array_of_pointers: Bool32,
    pub data: DeviceOrHostAddressConstKHR,
    pub _marker: PhantomData<&'a ()>,
}
#[cfg(feature = "debug")]
impl fmt::Debug for AccelerationStructureGeometryInstancesDataKHR<'_> {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("AccelerationStructureGeometryInstancesDataKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("array_of_pointers", &self.array_of_pointers)
            .field("data", &"union")
            .finish()
    }
}
impl ::std::default::Default for AccelerationStructureGeometryInstancesDataKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            array_of_pointers: Bool32::default(),
            data: DeviceOrHostAddressConstKHR::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for AccelerationStructureGeometryInstancesDataKHR<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR;
}
impl<'a> AccelerationStructureGeometryInstancesDataKHR<'a> {
    #[inline]
    pub fn array_of_pointers(mut self, array_of_pointers: bool) -> Self {
        self.array_of_pointers = array_of_pointers.into();
        self
    }
    #[inline]
    pub fn data(mut self, data: DeviceOrHostAddressConstKHR) -> Self {
        self.data = data;
        self
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAccelerationStructureGeometryDataKHR.html>"]
pub union AccelerationStructureGeometryDataKHR<'a> {
    pub triangles: AccelerationStructureGeometryTrianglesDataKHR<'a>,
    pub aabbs: AccelerationStructureGeometryAabbsDataKHR<'a>,
    pub instances: AccelerationStructureGeometryInstancesDataKHR<'a>,
}
impl<'a> ::std::default::Default for AccelerationStructureGeometryDataKHR<'a> {
    #[inline]
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAccelerationStructureGeometryKHR.html>"]
pub struct AccelerationStructureGeometryKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub geometry_type: GeometryTypeKHR,
    pub geometry: AccelerationStructureGeometryDataKHR<'a>,
    pub flags: GeometryFlagsKHR,
    pub _marker: PhantomData<&'a ()>,
}
#[cfg(feature = "debug")]
impl fmt::Debug for AccelerationStructureGeometryKHR<'_> {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("AccelerationStructureGeometryKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("geometry_type", &self.geometry_type)
            .field("geometry", &"union")
            .field("flags", &self.flags)
            .finish()
    }
}
impl ::std::default::Default for AccelerationStructureGeometryKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            geometry_type: GeometryTypeKHR::default(),
            geometry: AccelerationStructureGeometryDataKHR::default(),
            flags: GeometryFlagsKHR::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for AccelerationStructureGeometryKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ACCELERATION_STRUCTURE_GEOMETRY_KHR;
}
impl<'a> AccelerationStructureGeometryKHR<'a> {
    #[inline]
    pub fn geometry_type(mut self, geometry_type: GeometryTypeKHR) -> Self {
        self.geometry_type = geometry_type;
        self
    }
    #[inline]
    pub fn geometry(mut self, geometry: AccelerationStructureGeometryDataKHR<'a>) -> Self {
        self.geometry = geometry;
        self
    }
    #[inline]
    pub fn flags(mut self, flags: GeometryFlagsKHR) -> Self {
        self.flags = flags;
        self
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAccelerationStructureBuildGeometryInfoKHR.html>"]
pub struct AccelerationStructureBuildGeometryInfoKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub ty: AccelerationStructureTypeKHR,
    pub flags: BuildAccelerationStructureFlagsKHR,
    pub mode: BuildAccelerationStructureModeKHR,
    pub src_acceleration_structure: AccelerationStructureKHR,
    pub dst_acceleration_structure: AccelerationStructureKHR,
    pub geometry_count: u32,
    pub p_geometries: *const AccelerationStructureGeometryKHR<'a>,
    pub pp_geometries: *const *const AccelerationStructureGeometryKHR<'a>,
    pub scratch_data: DeviceOrHostAddressKHR,
    pub _marker: PhantomData<&'a ()>,
}
#[cfg(feature = "debug")]
impl fmt::Debug for AccelerationStructureBuildGeometryInfoKHR<'_> {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("AccelerationStructureBuildGeometryInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("ty", &self.ty)
            .field("flags", &self.flags)
            .field("mode", &self.mode)
            .field(
                "src_acceleration_structure",
                &self.src_acceleration_structure,
            )
            .field(
                "dst_acceleration_structure",
                &self.dst_acceleration_structure,
            )
            .field("geometry_count", &self.geometry_count)
            .field("p_geometries", &self.p_geometries)
            .field("pp_geometries", &self.pp_geometries)
            .field("scratch_data", &"union")
            .finish()
    }
}
impl ::std::default::Default for AccelerationStructureBuildGeometryInfoKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            ty: AccelerationStructureTypeKHR::default(),
            flags: BuildAccelerationStructureFlagsKHR::default(),
            mode: BuildAccelerationStructureModeKHR::default(),
            src_acceleration_structure: AccelerationStructureKHR::default(),
            dst_acceleration_structure: AccelerationStructureKHR::default(),
            geometry_count: u32::default(),
            p_geometries: ::std::ptr::null(),
            pp_geometries: ::std::ptr::null(),
            scratch_data: DeviceOrHostAddressKHR::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for AccelerationStructureBuildGeometryInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR;
}
impl<'a> AccelerationStructureBuildGeometryInfoKHR<'a> {
    #[inline]
    pub fn ty(mut self, ty: AccelerationStructureTypeKHR) -> Self {
        self.ty = ty;
        self
    }
    #[inline]
    pub fn flags(mut self, flags: BuildAccelerationStructureFlagsKHR) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn mode(mut self, mode: BuildAccelerationStructureModeKHR) -> Self {
        self.mode = mode;
        self
    }
    #[inline]
    pub fn src_acceleration_structure(
        mut self,
        src_acceleration_structure: AccelerationStructureKHR,
    ) -> Self {
        self.src_acceleration_structure = src_acceleration_structure;
        self
    }
    #[inline]
    pub fn dst_acceleration_structure(
        mut self,
        dst_acceleration_structure: AccelerationStructureKHR,
    ) -> Self {
        self.dst_acceleration_structure = dst_acceleration_structure;
        self
    }
    #[inline]
    pub fn geometries(mut self, geometries: &'a [AccelerationStructureGeometryKHR]) -> Self {
        self.geometry_count = geometries.len() as _;
        self.p_geometries = geometries.as_ptr();
        self
    }
    #[inline]
    pub fn geometries_ptrs(
        mut self,
        geometries: &'a [&'a AccelerationStructureGeometryKHR<'a>],
    ) -> Self {
        self.geometry_count = geometries.len() as _;
        self.pp_geometries = geometries.as_ptr() as *const *const _;
        self
    }
    #[inline]
    pub fn scratch_data(mut self, scratch_data: DeviceOrHostAddressKHR) -> Self {
        self.scratch_data = scratch_data;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAccelerationStructureBuildRangeInfoKHR.html>"]
pub struct AccelerationStructureBuildRangeInfoKHR {
    pub primitive_count: u32,
    pub primitive_offset: u32,
    pub first_vertex: u32,
    pub transform_offset: u32,
}
impl AccelerationStructureBuildRangeInfoKHR {
    #[inline]
    pub fn primitive_count(mut self, primitive_count: u32) -> Self {
        self.primitive_count = primitive_count;
        self
    }
    #[inline]
    pub fn primitive_offset(mut self, primitive_offset: u32) -> Self {
        self.primitive_offset = primitive_offset;
        self
    }
    #[inline]
    pub fn first_vertex(mut self, first_vertex: u32) -> Self {
        self.first_vertex = first_vertex;
        self
    }
    #[inline]
    pub fn transform_offset(mut self, transform_offset: u32) -> Self {
        self.transform_offset = transform_offset;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAccelerationStructureCreateInfoKHR.html>"]
pub struct AccelerationStructureCreateInfoKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub create_flags: AccelerationStructureCreateFlagsKHR,
    pub buffer: Buffer,
    pub offset: DeviceSize,
    pub size: DeviceSize,
    pub ty: AccelerationStructureTypeKHR,
    pub device_address: DeviceAddress,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for AccelerationStructureCreateInfoKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            create_flags: AccelerationStructureCreateFlagsKHR::default(),
            buffer: Buffer::default(),
            offset: DeviceSize::default(),
            size: DeviceSize::default(),
            ty: AccelerationStructureTypeKHR::default(),
            device_address: DeviceAddress::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for AccelerationStructureCreateInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ACCELERATION_STRUCTURE_CREATE_INFO_KHR;
}
pub unsafe trait ExtendsAccelerationStructureCreateInfoKHR {}
impl<'a> AccelerationStructureCreateInfoKHR<'a> {
    #[inline]
    pub fn create_flags(mut self, create_flags: AccelerationStructureCreateFlagsKHR) -> Self {
        self.create_flags = create_flags;
        self
    }
    #[inline]
    pub fn buffer(mut self, buffer: Buffer) -> Self {
        self.buffer = buffer;
        self
    }
    #[inline]
    pub fn offset(mut self, offset: DeviceSize) -> Self {
        self.offset = offset;
        self
    }
    #[inline]
    pub fn size(mut self, size: DeviceSize) -> Self {
        self.size = size;
        self
    }
    #[inline]
    pub fn ty(mut self, ty: AccelerationStructureTypeKHR) -> Self {
        self.ty = ty;
        self
    }
    #[inline]
    pub fn device_address(mut self, device_address: DeviceAddress) -> Self {
        self.device_address = device_address;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `x.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsAccelerationStructureCreateInfoKHR>(
        mut self,
        next: &'a mut T,
    ) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.p_next as _;
            self.p_next = next_ptr;
        }
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAabbPositionsKHR.html>"]
pub struct AabbPositionsKHR {
    pub min_x: f32,
    pub min_y: f32,
    pub min_z: f32,
    pub max_x: f32,
    pub max_y: f32,
    pub max_z: f32,
}
impl AabbPositionsKHR {
    #[inline]
    pub fn min_x(mut self, min_x: f32) -> Self {
        self.min_x = min_x;
        self
    }
    #[inline]
    pub fn min_y(mut self, min_y: f32) -> Self {
        self.min_y = min_y;
        self
    }
    #[inline]
    pub fn min_z(mut self, min_z: f32) -> Self {
        self.min_z = min_z;
        self
    }
    #[inline]
    pub fn max_x(mut self, max_x: f32) -> Self {
        self.max_x = max_x;
        self
    }
    #[inline]
    pub fn max_y(mut self, max_y: f32) -> Self {
        self.max_y = max_y;
        self
    }
    #[inline]
    pub fn max_z(mut self, max_z: f32) -> Self {
        self.max_z = max_z;
        self
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TransformMatrixKHR {
    pub matrix: [f32; 12],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union AccelerationStructureReferenceKHR {
    pub device_handle: DeviceAddress,
    pub host_handle: AccelerationStructureKHR,
}
#[repr(C)]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAccelerationStructureInstanceKHR.html>"]
pub struct AccelerationStructureInstanceKHR {
    pub transform: TransformMatrixKHR,
    #[doc = r" Use [`Packed24_8::new(instance_custom_index, mask)`][Packed24_8::new()] to construct this field"]
    pub instance_custom_index_and_mask: Packed24_8,
    #[doc = r" Use [`Packed24_8::new(instance_shader_binding_table_record_offset, flags)`][Packed24_8::new()] to construct this field"]
    pub instance_shader_binding_table_record_offset_and_flags: Packed24_8,
    pub acceleration_structure_reference: AccelerationStructureReferenceKHR,
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAccelerationStructureDeviceAddressInfoKHR.html>"]
pub struct AccelerationStructureDeviceAddressInfoKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub acceleration_structure: AccelerationStructureKHR,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for AccelerationStructureDeviceAddressInfoKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            acceleration_structure: AccelerationStructureKHR::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for AccelerationStructureDeviceAddressInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR;
}
impl<'a> AccelerationStructureDeviceAddressInfoKHR<'a> {
    #[inline]
    pub fn acceleration_structure(
        mut self,
        acceleration_structure: AccelerationStructureKHR,
    ) -> Self {
        self.acceleration_structure = acceleration_structure;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAccelerationStructureVersionInfoKHR.html>"]
pub struct AccelerationStructureVersionInfoKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub p_version_data: *const [u8; 2 * UUID_SIZE],
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for AccelerationStructureVersionInfoKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            p_version_data: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for AccelerationStructureVersionInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ACCELERATION_STRUCTURE_VERSION_INFO_KHR;
}
impl<'a> AccelerationStructureVersionInfoKHR<'a> {
    #[inline]
    pub fn version_data(mut self, version_data: &'a [u8; 2 * UUID_SIZE]) -> Self {
        self.p_version_data = version_data;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCopyAccelerationStructureInfoKHR.html>"]
pub struct CopyAccelerationStructureInfoKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub src: AccelerationStructureKHR,
    pub dst: AccelerationStructureKHR,
    pub mode: CopyAccelerationStructureModeKHR,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for CopyAccelerationStructureInfoKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            src: AccelerationStructureKHR::default(),
            dst: AccelerationStructureKHR::default(),
            mode: CopyAccelerationStructureModeKHR::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for CopyAccelerationStructureInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::COPY_ACCELERATION_STRUCTURE_INFO_KHR;
}
impl<'a> CopyAccelerationStructureInfoKHR<'a> {
    #[inline]
    pub fn src(mut self, src: AccelerationStructureKHR) -> Self {
        self.src = src;
        self
    }
    #[inline]
    pub fn dst(mut self, dst: AccelerationStructureKHR) -> Self {
        self.dst = dst;
        self
    }
    #[inline]
    pub fn mode(mut self, mode: CopyAccelerationStructureModeKHR) -> Self {
        self.mode = mode;
        self
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCopyAccelerationStructureToMemoryInfoKHR.html>"]
pub struct CopyAccelerationStructureToMemoryInfoKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub src: AccelerationStructureKHR,
    pub dst: DeviceOrHostAddressKHR,
    pub mode: CopyAccelerationStructureModeKHR,
    pub _marker: PhantomData<&'a ()>,
}
#[cfg(feature = "debug")]
impl fmt::Debug for CopyAccelerationStructureToMemoryInfoKHR<'_> {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("CopyAccelerationStructureToMemoryInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("src", &self.src)
            .field("dst", &"union")
            .field("mode", &self.mode)
            .finish()
    }
}
impl ::std::default::Default for CopyAccelerationStructureToMemoryInfoKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            src: AccelerationStructureKHR::default(),
            dst: DeviceOrHostAddressKHR::default(),
            mode: CopyAccelerationStructureModeKHR::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for CopyAccelerationStructureToMemoryInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR;
}
impl<'a> CopyAccelerationStructureToMemoryInfoKHR<'a> {
    #[inline]
    pub fn src(mut self, src: AccelerationStructureKHR) -> Self {
        self.src = src;
        self
    }
    #[inline]
    pub fn dst(mut self, dst: DeviceOrHostAddressKHR) -> Self {
        self.dst = dst;
        self
    }
    #[inline]
    pub fn mode(mut self, mode: CopyAccelerationStructureModeKHR) -> Self {
        self.mode = mode;
        self
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCopyMemoryToAccelerationStructureInfoKHR.html>"]
pub struct CopyMemoryToAccelerationStructureInfoKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub src: DeviceOrHostAddressConstKHR,
    pub dst: AccelerationStructureKHR,
    pub mode: CopyAccelerationStructureModeKHR,
    pub _marker: PhantomData<&'a ()>,
}
#[cfg(feature = "debug")]
impl fmt::Debug for CopyMemoryToAccelerationStructureInfoKHR<'_> {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("CopyMemoryToAccelerationStructureInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("src", &"union")
            .field("dst", &self.dst)
            .field("mode", &self.mode)
            .finish()
    }
}
impl ::std::default::Default for CopyMemoryToAccelerationStructureInfoKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            src: DeviceOrHostAddressConstKHR::default(),
            dst: AccelerationStructureKHR::default(),
            mode: CopyAccelerationStructureModeKHR::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for CopyMemoryToAccelerationStructureInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR;
}
impl<'a> CopyMemoryToAccelerationStructureInfoKHR<'a> {
    #[inline]
    pub fn src(mut self, src: DeviceOrHostAddressConstKHR) -> Self {
        self.src = src;
        self
    }
    #[inline]
    pub fn dst(mut self, dst: AccelerationStructureKHR) -> Self {
        self.dst = dst;
        self
    }
    #[inline]
    pub fn mode(mut self, mode: CopyAccelerationStructureModeKHR) -> Self {
        self.mode = mode;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRayTracingPipelineInterfaceCreateInfoKHR.html>"]
pub struct RayTracingPipelineInterfaceCreateInfoKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub max_pipeline_ray_payload_size: u32,
    pub max_pipeline_ray_hit_attribute_size: u32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for RayTracingPipelineInterfaceCreateInfoKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            max_pipeline_ray_payload_size: u32::default(),
            max_pipeline_ray_hit_attribute_size: u32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for RayTracingPipelineInterfaceCreateInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR;
}
impl<'a> RayTracingPipelineInterfaceCreateInfoKHR<'a> {
    #[inline]
    pub fn max_pipeline_ray_payload_size(mut self, max_pipeline_ray_payload_size: u32) -> Self {
        self.max_pipeline_ray_payload_size = max_pipeline_ray_payload_size;
        self
    }
    #[inline]
    pub fn max_pipeline_ray_hit_attribute_size(
        mut self,
        max_pipeline_ray_hit_attribute_size: u32,
    ) -> Self {
        self.max_pipeline_ray_hit_attribute_size = max_pipeline_ray_hit_attribute_size;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineLibraryCreateInfoKHR.html>"]
pub struct PipelineLibraryCreateInfoKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub library_count: u32,
    pub p_libraries: *const Pipeline,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PipelineLibraryCreateInfoKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            library_count: u32::default(),
            p_libraries: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PipelineLibraryCreateInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PIPELINE_LIBRARY_CREATE_INFO_KHR;
}
unsafe impl ExtendsGraphicsPipelineCreateInfo for PipelineLibraryCreateInfoKHR<'_> {}
impl<'a> PipelineLibraryCreateInfoKHR<'a> {
    #[inline]
    pub fn libraries(mut self, libraries: &'a [Pipeline]) -> Self {
        self.library_count = libraries.len() as _;
        self.p_libraries = libraries.as_ptr();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceExtendedDynamicStateFeaturesEXT.html>"]
pub struct PhysicalDeviceExtendedDynamicStateFeaturesEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub extended_dynamic_state: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceExtendedDynamicStateFeaturesEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            extended_dynamic_state: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceExtendedDynamicStateFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT;
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceExtendedDynamicStateFeaturesEXT<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceExtendedDynamicStateFeaturesEXT<'_> {}
impl<'a> PhysicalDeviceExtendedDynamicStateFeaturesEXT<'a> {
    #[inline]
    pub fn extended_dynamic_state(mut self, extended_dynamic_state: bool) -> Self {
        self.extended_dynamic_state = extended_dynamic_state.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceExtendedDynamicState2FeaturesEXT.html>"]
pub struct PhysicalDeviceExtendedDynamicState2FeaturesEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub extended_dynamic_state2: Bool32,
    pub extended_dynamic_state2_logic_op: Bool32,
    pub extended_dynamic_state2_patch_control_points: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceExtendedDynamicState2FeaturesEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            extended_dynamic_state2: Bool32::default(),
            extended_dynamic_state2_logic_op: Bool32::default(),
            extended_dynamic_state2_patch_control_points: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceExtendedDynamicState2FeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT;
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceExtendedDynamicState2FeaturesEXT<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceExtendedDynamicState2FeaturesEXT<'_> {}
impl<'a> PhysicalDeviceExtendedDynamicState2FeaturesEXT<'a> {
    #[inline]
    pub fn extended_dynamic_state2(mut self, extended_dynamic_state2: bool) -> Self {
        self.extended_dynamic_state2 = extended_dynamic_state2.into();
        self
    }
    #[inline]
    pub fn extended_dynamic_state2_logic_op(
        mut self,
        extended_dynamic_state2_logic_op: bool,
    ) -> Self {
        self.extended_dynamic_state2_logic_op = extended_dynamic_state2_logic_op.into();
        self
    }
    #[inline]
    pub fn extended_dynamic_state2_patch_control_points(
        mut self,
        extended_dynamic_state2_patch_control_points: bool,
    ) -> Self {
        self.extended_dynamic_state2_patch_control_points =
            extended_dynamic_state2_patch_control_points.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderPassTransformBeginInfoQCOM.html>"]
pub struct RenderPassTransformBeginInfoQCOM<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub transform: SurfaceTransformFlagsKHR,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for RenderPassTransformBeginInfoQCOM<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            transform: SurfaceTransformFlagsKHR::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for RenderPassTransformBeginInfoQCOM<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM;
}
unsafe impl ExtendsRenderPassBeginInfo for RenderPassTransformBeginInfoQCOM<'_> {}
impl<'a> RenderPassTransformBeginInfoQCOM<'a> {
    #[inline]
    pub fn transform(mut self, transform: SurfaceTransformFlagsKHR) -> Self {
        self.transform = transform;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCopyCommandTransformInfoQCOM.html>"]
pub struct CopyCommandTransformInfoQCOM<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub transform: SurfaceTransformFlagsKHR,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for CopyCommandTransformInfoQCOM<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            transform: SurfaceTransformFlagsKHR::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for CopyCommandTransformInfoQCOM<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::COPY_COMMAND_TRANSFORM_INFO_QCOM;
}
unsafe impl ExtendsBufferImageCopy2 for CopyCommandTransformInfoQCOM<'_> {}
unsafe impl ExtendsImageBlit2 for CopyCommandTransformInfoQCOM<'_> {}
impl<'a> CopyCommandTransformInfoQCOM<'a> {
    #[inline]
    pub fn transform(mut self, transform: SurfaceTransformFlagsKHR) -> Self {
        self.transform = transform;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandBufferInheritanceRenderPassTransformInfoQCOM.html>"]
pub struct CommandBufferInheritanceRenderPassTransformInfoQCOM<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub transform: SurfaceTransformFlagsKHR,
    pub render_area: Rect2D,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for CommandBufferInheritanceRenderPassTransformInfoQCOM<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            transform: SurfaceTransformFlagsKHR::default(),
            render_area: Rect2D::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for CommandBufferInheritanceRenderPassTransformInfoQCOM<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM;
}
unsafe impl ExtendsCommandBufferInheritanceInfo
    for CommandBufferInheritanceRenderPassTransformInfoQCOM<'_>
{
}
impl<'a> CommandBufferInheritanceRenderPassTransformInfoQCOM<'a> {
    #[inline]
    pub fn transform(mut self, transform: SurfaceTransformFlagsKHR) -> Self {
        self.transform = transform;
        self
    }
    #[inline]
    pub fn render_area(mut self, render_area: Rect2D) -> Self {
        self.render_area = render_area;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDiagnosticsConfigFeaturesNV.html>"]
pub struct PhysicalDeviceDiagnosticsConfigFeaturesNV<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub diagnostics_config: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceDiagnosticsConfigFeaturesNV<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            diagnostics_config: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceDiagnosticsConfigFeaturesNV<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV;
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceDiagnosticsConfigFeaturesNV<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceDiagnosticsConfigFeaturesNV<'_> {}
impl<'a> PhysicalDeviceDiagnosticsConfigFeaturesNV<'a> {
    #[inline]
    pub fn diagnostics_config(mut self, diagnostics_config: bool) -> Self {
        self.diagnostics_config = diagnostics_config.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceDiagnosticsConfigCreateInfoNV.html>"]
pub struct DeviceDiagnosticsConfigCreateInfoNV<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: DeviceDiagnosticsConfigFlagsNV,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for DeviceDiagnosticsConfigCreateInfoNV<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: DeviceDiagnosticsConfigFlagsNV::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for DeviceDiagnosticsConfigCreateInfoNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV;
}
unsafe impl ExtendsDeviceCreateInfo for DeviceDiagnosticsConfigCreateInfoNV<'_> {}
impl<'a> DeviceDiagnosticsConfigCreateInfoNV<'a> {
    #[inline]
    pub fn flags(mut self, flags: DeviceDiagnosticsConfigFlagsNV) -> Self {
        self.flags = flags;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures.html>"]
pub struct PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shader_zero_initialize_workgroup_memory: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            shader_zero_initialize_workgroup_memory: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES;
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures<'_>
{
}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures<'_> {}
impl<'a> PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures<'a> {
    #[inline]
    pub fn shader_zero_initialize_workgroup_memory(
        mut self,
        shader_zero_initialize_workgroup_memory: bool,
    ) -> Self {
        self.shader_zero_initialize_workgroup_memory =
            shader_zero_initialize_workgroup_memory.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR.html>"]
pub struct PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shader_subgroup_uniform_control_flow: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            shader_subgroup_uniform_control_flow: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR;
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR<'_>
{
}
unsafe impl ExtendsDeviceCreateInfo
    for PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR<'_>
{
}
impl<'a> PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR<'a> {
    #[inline]
    pub fn shader_subgroup_uniform_control_flow(
        mut self,
        shader_subgroup_uniform_control_flow: bool,
    ) -> Self {
        self.shader_subgroup_uniform_control_flow = shader_subgroup_uniform_control_flow.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceRobustness2FeaturesEXT.html>"]
pub struct PhysicalDeviceRobustness2FeaturesEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub robust_buffer_access2: Bool32,
    pub robust_image_access2: Bool32,
    pub null_descriptor: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceRobustness2FeaturesEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            robust_buffer_access2: Bool32::default(),
            robust_image_access2: Bool32::default(),
            null_descriptor: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceRobustness2FeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT;
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceRobustness2FeaturesEXT<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceRobustness2FeaturesEXT<'_> {}
impl<'a> PhysicalDeviceRobustness2FeaturesEXT<'a> {
    #[inline]
    pub fn robust_buffer_access2(mut self, robust_buffer_access2: bool) -> Self {
        self.robust_buffer_access2 = robust_buffer_access2.into();
        self
    }
    #[inline]
    pub fn robust_image_access2(mut self, robust_image_access2: bool) -> Self {
        self.robust_image_access2 = robust_image_access2.into();
        self
    }
    #[inline]
    pub fn null_descriptor(mut self, null_descriptor: bool) -> Self {
        self.null_descriptor = null_descriptor.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceRobustness2PropertiesEXT.html>"]
pub struct PhysicalDeviceRobustness2PropertiesEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub robust_storage_buffer_access_size_alignment: DeviceSize,
    pub robust_uniform_buffer_access_size_alignment: DeviceSize,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceRobustness2PropertiesEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            robust_storage_buffer_access_size_alignment: DeviceSize::default(),
            robust_uniform_buffer_access_size_alignment: DeviceSize::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceRobustness2PropertiesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT;
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceRobustness2PropertiesEXT<'_> {}
impl<'a> PhysicalDeviceRobustness2PropertiesEXT<'a> {
    #[inline]
    pub fn robust_storage_buffer_access_size_alignment(
        mut self,
        robust_storage_buffer_access_size_alignment: DeviceSize,
    ) -> Self {
        self.robust_storage_buffer_access_size_alignment =
            robust_storage_buffer_access_size_alignment;
        self
    }
    #[inline]
    pub fn robust_uniform_buffer_access_size_alignment(
        mut self,
        robust_uniform_buffer_access_size_alignment: DeviceSize,
    ) -> Self {
        self.robust_uniform_buffer_access_size_alignment =
            robust_uniform_buffer_access_size_alignment;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceImageRobustnessFeatures.html>"]
pub struct PhysicalDeviceImageRobustnessFeatures<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub robust_image_access: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceImageRobustnessFeatures<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            robust_image_access: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceImageRobustnessFeatures<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES;
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceImageRobustnessFeatures<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceImageRobustnessFeatures<'_> {}
impl<'a> PhysicalDeviceImageRobustnessFeatures<'a> {
    #[inline]
    pub fn robust_image_access(mut self, robust_image_access: bool) -> Self {
        self.robust_image_access = robust_image_access.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR.html>"]
pub struct PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub workgroup_memory_explicit_layout: Bool32,
    pub workgroup_memory_explicit_layout_scalar_block_layout: Bool32,
    pub workgroup_memory_explicit_layout8_bit_access: Bool32,
    pub workgroup_memory_explicit_layout16_bit_access: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            workgroup_memory_explicit_layout: Bool32::default(),
            workgroup_memory_explicit_layout_scalar_block_layout: Bool32::default(),
            workgroup_memory_explicit_layout8_bit_access: Bool32::default(),
            workgroup_memory_explicit_layout16_bit_access: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR;
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR<'_>
{
}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR<'_> {}
impl<'a> PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR<'a> {
    #[inline]
    pub fn workgroup_memory_explicit_layout(
        mut self,
        workgroup_memory_explicit_layout: bool,
    ) -> Self {
        self.workgroup_memory_explicit_layout = workgroup_memory_explicit_layout.into();
        self
    }
    #[inline]
    pub fn workgroup_memory_explicit_layout_scalar_block_layout(
        mut self,
        workgroup_memory_explicit_layout_scalar_block_layout: bool,
    ) -> Self {
        self.workgroup_memory_explicit_layout_scalar_block_layout =
            workgroup_memory_explicit_layout_scalar_block_layout.into();
        self
    }
    #[inline]
    pub fn workgroup_memory_explicit_layout8_bit_access(
        mut self,
        workgroup_memory_explicit_layout8_bit_access: bool,
    ) -> Self {
        self.workgroup_memory_explicit_layout8_bit_access =
            workgroup_memory_explicit_layout8_bit_access.into();
        self
    }
    #[inline]
    pub fn workgroup_memory_explicit_layout16_bit_access(
        mut self,
        workgroup_memory_explicit_layout16_bit_access: bool,
    ) -> Self {
        self.workgroup_memory_explicit_layout16_bit_access =
            workgroup_memory_explicit_layout16_bit_access.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePortabilitySubsetFeaturesKHR.html>"]
pub struct PhysicalDevicePortabilitySubsetFeaturesKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub constant_alpha_color_blend_factors: Bool32,
    pub events: Bool32,
    pub image_view_format_reinterpretation: Bool32,
    pub image_view_format_swizzle: Bool32,
    pub image_view2_d_on3_d_image: Bool32,
    pub multisample_array_image: Bool32,
    pub mutable_comparison_samplers: Bool32,
    pub point_polygons: Bool32,
    pub sampler_mip_lod_bias: Bool32,
    pub separate_stencil_mask_ref: Bool32,
    pub shader_sample_rate_interpolation_functions: Bool32,
    pub tessellation_isolines: Bool32,
    pub tessellation_point_mode: Bool32,
    pub triangle_fans: Bool32,
    pub vertex_attribute_access_beyond_stride: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDevicePortabilitySubsetFeaturesKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            constant_alpha_color_blend_factors: Bool32::default(),
            events: Bool32::default(),
            image_view_format_reinterpretation: Bool32::default(),
            image_view_format_swizzle: Bool32::default(),
            image_view2_d_on3_d_image: Bool32::default(),
            multisample_array_image: Bool32::default(),
            mutable_comparison_samplers: Bool32::default(),
            point_polygons: Bool32::default(),
            sampler_mip_lod_bias: Bool32::default(),
            separate_stencil_mask_ref: Bool32::default(),
            shader_sample_rate_interpolation_functions: Bool32::default(),
            tessellation_isolines: Bool32::default(),
            tessellation_point_mode: Bool32::default(),
            triangle_fans: Bool32::default(),
            vertex_attribute_access_beyond_stride: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDevicePortabilitySubsetFeaturesKHR<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR;
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDevicePortabilitySubsetFeaturesKHR<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDevicePortabilitySubsetFeaturesKHR<'_> {}
impl<'a> PhysicalDevicePortabilitySubsetFeaturesKHR<'a> {
    #[inline]
    pub fn constant_alpha_color_blend_factors(
        mut self,
        constant_alpha_color_blend_factors: bool,
    ) -> Self {
        self.constant_alpha_color_blend_factors = constant_alpha_color_blend_factors.into();
        self
    }
    #[inline]
    pub fn events(mut self, events: bool) -> Self {
        self.events = events.into();
        self
    }
    #[inline]
    pub fn image_view_format_reinterpretation(
        mut self,
        image_view_format_reinterpretation: bool,
    ) -> Self {
        self.image_view_format_reinterpretation = image_view_format_reinterpretation.into();
        self
    }
    #[inline]
    pub fn image_view_format_swizzle(mut self, image_view_format_swizzle: bool) -> Self {
        self.image_view_format_swizzle = image_view_format_swizzle.into();
        self
    }
    #[inline]
    pub fn image_view2_d_on3_d_image(mut self, image_view2_d_on3_d_image: bool) -> Self {
        self.image_view2_d_on3_d_image = image_view2_d_on3_d_image.into();
        self
    }
    #[inline]
    pub fn multisample_array_image(mut self, multisample_array_image: bool) -> Self {
        self.multisample_array_image = multisample_array_image.into();
        self
    }
    #[inline]
    pub fn mutable_comparison_samplers(mut self, mutable_comparison_samplers: bool) -> Self {
        self.mutable_comparison_samplers = mutable_comparison_samplers.into();
        self
    }
    #[inline]
    pub fn point_polygons(mut self, point_polygons: bool) -> Self {
        self.point_polygons = point_polygons.into();
        self
    }
    #[inline]
    pub fn sampler_mip_lod_bias(mut self, sampler_mip_lod_bias: bool) -> Self {
        self.sampler_mip_lod_bias = sampler_mip_lod_bias.into();
        self
    }
    #[inline]
    pub fn separate_stencil_mask_ref(mut self, separate_stencil_mask_ref: bool) -> Self {
        self.separate_stencil_mask_ref = separate_stencil_mask_ref.into();
        self
    }
    #[inline]
    pub fn shader_sample_rate_interpolation_functions(
        mut self,
        shader_sample_rate_interpolation_functions: bool,
    ) -> Self {
        self.shader_sample_rate_interpolation_functions =
            shader_sample_rate_interpolation_functions.into();
        self
    }
    #[inline]
    pub fn tessellation_isolines(mut self, tessellation_isolines: bool) -> Self {
        self.tessellation_isolines = tessellation_isolines.into();
        self
    }
    #[inline]
    pub fn tessellation_point_mode(mut self, tessellation_point_mode: bool) -> Self {
        self.tessellation_point_mode = tessellation_point_mode.into();
        self
    }
    #[inline]
    pub fn triangle_fans(mut self, triangle_fans: bool) -> Self {
        self.triangle_fans = triangle_fans.into();
        self
    }
    #[inline]
    pub fn vertex_attribute_access_beyond_stride(
        mut self,
        vertex_attribute_access_beyond_stride: bool,
    ) -> Self {
        self.vertex_attribute_access_beyond_stride = vertex_attribute_access_beyond_stride.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePortabilitySubsetPropertiesKHR.html>"]
pub struct PhysicalDevicePortabilitySubsetPropertiesKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub min_vertex_input_binding_stride_alignment: u32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDevicePortabilitySubsetPropertiesKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            min_vertex_input_binding_stride_alignment: u32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDevicePortabilitySubsetPropertiesKHR<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_PORTABILITY_SUBSET_PROPERTIES_KHR;
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDevicePortabilitySubsetPropertiesKHR<'_> {}
impl<'a> PhysicalDevicePortabilitySubsetPropertiesKHR<'a> {
    #[inline]
    pub fn min_vertex_input_binding_stride_alignment(
        mut self,
        min_vertex_input_binding_stride_alignment: u32,
    ) -> Self {
        self.min_vertex_input_binding_stride_alignment = min_vertex_input_binding_stride_alignment;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevice4444FormatsFeaturesEXT.html>"]
pub struct PhysicalDevice4444FormatsFeaturesEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub format_a4r4g4b4: Bool32,
    pub format_a4b4g4r4: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDevice4444FormatsFeaturesEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            format_a4r4g4b4: Bool32::default(),
            format_a4b4g4r4: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDevice4444FormatsFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT;
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDevice4444FormatsFeaturesEXT<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDevice4444FormatsFeaturesEXT<'_> {}
impl<'a> PhysicalDevice4444FormatsFeaturesEXT<'a> {
    #[inline]
    pub fn format_a4r4g4b4(mut self, format_a4r4g4b4: bool) -> Self {
        self.format_a4r4g4b4 = format_a4r4g4b4.into();
        self
    }
    #[inline]
    pub fn format_a4b4g4r4(mut self, format_a4b4g4r4: bool) -> Self {
        self.format_a4b4g4r4 = format_a4b4g4r4.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceSubpassShadingFeaturesHUAWEI.html>"]
pub struct PhysicalDeviceSubpassShadingFeaturesHUAWEI<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub subpass_shading: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceSubpassShadingFeaturesHUAWEI<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            subpass_shading: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceSubpassShadingFeaturesHUAWEI<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI;
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceSubpassShadingFeaturesHUAWEI<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceSubpassShadingFeaturesHUAWEI<'_> {}
impl<'a> PhysicalDeviceSubpassShadingFeaturesHUAWEI<'a> {
    #[inline]
    pub fn subpass_shading(mut self, subpass_shading: bool) -> Self {
        self.subpass_shading = subpass_shading.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferCopy2.html>"]
pub struct BufferCopy2<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub src_offset: DeviceSize,
    pub dst_offset: DeviceSize,
    pub size: DeviceSize,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for BufferCopy2<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            src_offset: DeviceSize::default(),
            dst_offset: DeviceSize::default(),
            size: DeviceSize::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for BufferCopy2<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::BUFFER_COPY_2;
}
impl<'a> BufferCopy2<'a> {
    #[inline]
    pub fn src_offset(mut self, src_offset: DeviceSize) -> Self {
        self.src_offset = src_offset;
        self
    }
    #[inline]
    pub fn dst_offset(mut self, dst_offset: DeviceSize) -> Self {
        self.dst_offset = dst_offset;
        self
    }
    #[inline]
    pub fn size(mut self, size: DeviceSize) -> Self {
        self.size = size;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageCopy2.html>"]
pub struct ImageCopy2<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub src_subresource: ImageSubresourceLayers,
    pub src_offset: Offset3D,
    pub dst_subresource: ImageSubresourceLayers,
    pub dst_offset: Offset3D,
    pub extent: Extent3D,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for ImageCopy2<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            src_subresource: ImageSubresourceLayers::default(),
            src_offset: Offset3D::default(),
            dst_subresource: ImageSubresourceLayers::default(),
            dst_offset: Offset3D::default(),
            extent: Extent3D::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for ImageCopy2<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::IMAGE_COPY_2;
}
impl<'a> ImageCopy2<'a> {
    #[inline]
    pub fn src_subresource(mut self, src_subresource: ImageSubresourceLayers) -> Self {
        self.src_subresource = src_subresource;
        self
    }
    #[inline]
    pub fn src_offset(mut self, src_offset: Offset3D) -> Self {
        self.src_offset = src_offset;
        self
    }
    #[inline]
    pub fn dst_subresource(mut self, dst_subresource: ImageSubresourceLayers) -> Self {
        self.dst_subresource = dst_subresource;
        self
    }
    #[inline]
    pub fn dst_offset(mut self, dst_offset: Offset3D) -> Self {
        self.dst_offset = dst_offset;
        self
    }
    #[inline]
    pub fn extent(mut self, extent: Extent3D) -> Self {
        self.extent = extent;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageBlit2.html>"]
pub struct ImageBlit2<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub src_subresource: ImageSubresourceLayers,
    pub src_offsets: [Offset3D; 2],
    pub dst_subresource: ImageSubresourceLayers,
    pub dst_offsets: [Offset3D; 2],
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for ImageBlit2<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            src_subresource: ImageSubresourceLayers::default(),
            src_offsets: unsafe { ::std::mem::zeroed() },
            dst_subresource: ImageSubresourceLayers::default(),
            dst_offsets: unsafe { ::std::mem::zeroed() },
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for ImageBlit2<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::IMAGE_BLIT_2;
}
pub unsafe trait ExtendsImageBlit2 {}
impl<'a> ImageBlit2<'a> {
    #[inline]
    pub fn src_subresource(mut self, src_subresource: ImageSubresourceLayers) -> Self {
        self.src_subresource = src_subresource;
        self
    }
    #[inline]
    pub fn src_offsets(mut self, src_offsets: [Offset3D; 2]) -> Self {
        self.src_offsets = src_offsets;
        self
    }
    #[inline]
    pub fn dst_subresource(mut self, dst_subresource: ImageSubresourceLayers) -> Self {
        self.dst_subresource = dst_subresource;
        self
    }
    #[inline]
    pub fn dst_offsets(mut self, dst_offsets: [Offset3D; 2]) -> Self {
        self.dst_offsets = dst_offsets;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `x.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsImageBlit2>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.p_next as _;
            self.p_next = next_ptr;
        }
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferImageCopy2.html>"]
pub struct BufferImageCopy2<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub buffer_offset: DeviceSize,
    pub buffer_row_length: u32,
    pub buffer_image_height: u32,
    pub image_subresource: ImageSubresourceLayers,
    pub image_offset: Offset3D,
    pub image_extent: Extent3D,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for BufferImageCopy2<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            buffer_offset: DeviceSize::default(),
            buffer_row_length: u32::default(),
            buffer_image_height: u32::default(),
            image_subresource: ImageSubresourceLayers::default(),
            image_offset: Offset3D::default(),
            image_extent: Extent3D::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for BufferImageCopy2<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::BUFFER_IMAGE_COPY_2;
}
pub unsafe trait ExtendsBufferImageCopy2 {}
impl<'a> BufferImageCopy2<'a> {
    #[inline]
    pub fn buffer_offset(mut self, buffer_offset: DeviceSize) -> Self {
        self.buffer_offset = buffer_offset;
        self
    }
    #[inline]
    pub fn buffer_row_length(mut self, buffer_row_length: u32) -> Self {
        self.buffer_row_length = buffer_row_length;
        self
    }
    #[inline]
    pub fn buffer_image_height(mut self, buffer_image_height: u32) -> Self {
        self.buffer_image_height = buffer_image_height;
        self
    }
    #[inline]
    pub fn image_subresource(mut self, image_subresource: ImageSubresourceLayers) -> Self {
        self.image_subresource = image_subresource;
        self
    }
    #[inline]
    pub fn image_offset(mut self, image_offset: Offset3D) -> Self {
        self.image_offset = image_offset;
        self
    }
    #[inline]
    pub fn image_extent(mut self, image_extent: Extent3D) -> Self {
        self.image_extent = image_extent;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `x.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsBufferImageCopy2>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.p_next as _;
            self.p_next = next_ptr;
        }
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageResolve2.html>"]
pub struct ImageResolve2<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub src_subresource: ImageSubresourceLayers,
    pub src_offset: Offset3D,
    pub dst_subresource: ImageSubresourceLayers,
    pub dst_offset: Offset3D,
    pub extent: Extent3D,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for ImageResolve2<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            src_subresource: ImageSubresourceLayers::default(),
            src_offset: Offset3D::default(),
            dst_subresource: ImageSubresourceLayers::default(),
            dst_offset: Offset3D::default(),
            extent: Extent3D::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for ImageResolve2<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::IMAGE_RESOLVE_2;
}
impl<'a> ImageResolve2<'a> {
    #[inline]
    pub fn src_subresource(mut self, src_subresource: ImageSubresourceLayers) -> Self {
        self.src_subresource = src_subresource;
        self
    }
    #[inline]
    pub fn src_offset(mut self, src_offset: Offset3D) -> Self {
        self.src_offset = src_offset;
        self
    }
    #[inline]
    pub fn dst_subresource(mut self, dst_subresource: ImageSubresourceLayers) -> Self {
        self.dst_subresource = dst_subresource;
        self
    }
    #[inline]
    pub fn dst_offset(mut self, dst_offset: Offset3D) -> Self {
        self.dst_offset = dst_offset;
        self
    }
    #[inline]
    pub fn extent(mut self, extent: Extent3D) -> Self {
        self.extent = extent;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCopyBufferInfo2.html>"]
pub struct CopyBufferInfo2<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub src_buffer: Buffer,
    pub dst_buffer: Buffer,
    pub region_count: u32,
    pub p_regions: *const BufferCopy2<'a>,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for CopyBufferInfo2<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            src_buffer: Buffer::default(),
            dst_buffer: Buffer::default(),
            region_count: u32::default(),
            p_regions: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for CopyBufferInfo2<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::COPY_BUFFER_INFO_2;
}
impl<'a> CopyBufferInfo2<'a> {
    #[inline]
    pub fn src_buffer(mut self, src_buffer: Buffer) -> Self {
        self.src_buffer = src_buffer;
        self
    }
    #[inline]
    pub fn dst_buffer(mut self, dst_buffer: Buffer) -> Self {
        self.dst_buffer = dst_buffer;
        self
    }
    #[inline]
    pub fn regions(mut self, regions: &'a [BufferCopy2]) -> Self {
        self.region_count = regions.len() as _;
        self.p_regions = regions.as_ptr();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCopyImageInfo2.html>"]
pub struct CopyImageInfo2<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub src_image: Image,
    pub src_image_layout: ImageLayout,
    pub dst_image: Image,
    pub dst_image_layout: ImageLayout,
    pub region_count: u32,
    pub p_regions: *const ImageCopy2<'a>,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for CopyImageInfo2<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            src_image: Image::default(),
            src_image_layout: ImageLayout::default(),
            dst_image: Image::default(),
            dst_image_layout: ImageLayout::default(),
            region_count: u32::default(),
            p_regions: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for CopyImageInfo2<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::COPY_IMAGE_INFO_2;
}
impl<'a> CopyImageInfo2<'a> {
    #[inline]
    pub fn src_image(mut self, src_image: Image) -> Self {
        self.src_image = src_image;
        self
    }
    #[inline]
    pub fn src_image_layout(mut self, src_image_layout: ImageLayout) -> Self {
        self.src_image_layout = src_image_layout;
        self
    }
    #[inline]
    pub fn dst_image(mut self, dst_image: Image) -> Self {
        self.dst_image = dst_image;
        self
    }
    #[inline]
    pub fn dst_image_layout(mut self, dst_image_layout: ImageLayout) -> Self {
        self.dst_image_layout = dst_image_layout;
        self
    }
    #[inline]
    pub fn regions(mut self, regions: &'a [ImageCopy2]) -> Self {
        self.region_count = regions.len() as _;
        self.p_regions = regions.as_ptr();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBlitImageInfo2.html>"]
pub struct BlitImageInfo2<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub src_image: Image,
    pub src_image_layout: ImageLayout,
    pub dst_image: Image,
    pub dst_image_layout: ImageLayout,
    pub region_count: u32,
    pub p_regions: *const ImageBlit2<'a>,
    pub filter: Filter,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for BlitImageInfo2<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            src_image: Image::default(),
            src_image_layout: ImageLayout::default(),
            dst_image: Image::default(),
            dst_image_layout: ImageLayout::default(),
            region_count: u32::default(),
            p_regions: ::std::ptr::null(),
            filter: Filter::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for BlitImageInfo2<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::BLIT_IMAGE_INFO_2;
}
impl<'a> BlitImageInfo2<'a> {
    #[inline]
    pub fn src_image(mut self, src_image: Image) -> Self {
        self.src_image = src_image;
        self
    }
    #[inline]
    pub fn src_image_layout(mut self, src_image_layout: ImageLayout) -> Self {
        self.src_image_layout = src_image_layout;
        self
    }
    #[inline]
    pub fn dst_image(mut self, dst_image: Image) -> Self {
        self.dst_image = dst_image;
        self
    }
    #[inline]
    pub fn dst_image_layout(mut self, dst_image_layout: ImageLayout) -> Self {
        self.dst_image_layout = dst_image_layout;
        self
    }
    #[inline]
    pub fn regions(mut self, regions: &'a [ImageBlit2]) -> Self {
        self.region_count = regions.len() as _;
        self.p_regions = regions.as_ptr();
        self
    }
    #[inline]
    pub fn filter(mut self, filter: Filter) -> Self {
        self.filter = filter;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCopyBufferToImageInfo2.html>"]
pub struct CopyBufferToImageInfo2<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub src_buffer: Buffer,
    pub dst_image: Image,
    pub dst_image_layout: ImageLayout,
    pub region_count: u32,
    pub p_regions: *const BufferImageCopy2<'a>,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for CopyBufferToImageInfo2<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            src_buffer: Buffer::default(),
            dst_image: Image::default(),
            dst_image_layout: ImageLayout::default(),
            region_count: u32::default(),
            p_regions: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for CopyBufferToImageInfo2<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::COPY_BUFFER_TO_IMAGE_INFO_2;
}
impl<'a> CopyBufferToImageInfo2<'a> {
    #[inline]
    pub fn src_buffer(mut self, src_buffer: Buffer) -> Self {
        self.src_buffer = src_buffer;
        self
    }
    #[inline]
    pub fn dst_image(mut self, dst_image: Image) -> Self {
        self.dst_image = dst_image;
        self
    }
    #[inline]
    pub fn dst_image_layout(mut self, dst_image_layout: ImageLayout) -> Self {
        self.dst_image_layout = dst_image_layout;
        self
    }
    #[inline]
    pub fn regions(mut self, regions: &'a [BufferImageCopy2]) -> Self {
        self.region_count = regions.len() as _;
        self.p_regions = regions.as_ptr();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCopyImageToBufferInfo2.html>"]
pub struct CopyImageToBufferInfo2<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub src_image: Image,
    pub src_image_layout: ImageLayout,
    pub dst_buffer: Buffer,
    pub region_count: u32,
    pub p_regions: *const BufferImageCopy2<'a>,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for CopyImageToBufferInfo2<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            src_image: Image::default(),
            src_image_layout: ImageLayout::default(),
            dst_buffer: Buffer::default(),
            region_count: u32::default(),
            p_regions: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for CopyImageToBufferInfo2<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::COPY_IMAGE_TO_BUFFER_INFO_2;
}
impl<'a> CopyImageToBufferInfo2<'a> {
    #[inline]
    pub fn src_image(mut self, src_image: Image) -> Self {
        self.src_image = src_image;
        self
    }
    #[inline]
    pub fn src_image_layout(mut self, src_image_layout: ImageLayout) -> Self {
        self.src_image_layout = src_image_layout;
        self
    }
    #[inline]
    pub fn dst_buffer(mut self, dst_buffer: Buffer) -> Self {
        self.dst_buffer = dst_buffer;
        self
    }
    #[inline]
    pub fn regions(mut self, regions: &'a [BufferImageCopy2]) -> Self {
        self.region_count = regions.len() as _;
        self.p_regions = regions.as_ptr();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkResolveImageInfo2.html>"]
pub struct ResolveImageInfo2<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub src_image: Image,
    pub src_image_layout: ImageLayout,
    pub dst_image: Image,
    pub dst_image_layout: ImageLayout,
    pub region_count: u32,
    pub p_regions: *const ImageResolve2<'a>,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for ResolveImageInfo2<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            src_image: Image::default(),
            src_image_layout: ImageLayout::default(),
            dst_image: Image::default(),
            dst_image_layout: ImageLayout::default(),
            region_count: u32::default(),
            p_regions: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for ResolveImageInfo2<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::RESOLVE_IMAGE_INFO_2;
}
impl<'a> ResolveImageInfo2<'a> {
    #[inline]
    pub fn src_image(mut self, src_image: Image) -> Self {
        self.src_image = src_image;
        self
    }
    #[inline]
    pub fn src_image_layout(mut self, src_image_layout: ImageLayout) -> Self {
        self.src_image_layout = src_image_layout;
        self
    }
    #[inline]
    pub fn dst_image(mut self, dst_image: Image) -> Self {
        self.dst_image = dst_image;
        self
    }
    #[inline]
    pub fn dst_image_layout(mut self, dst_image_layout: ImageLayout) -> Self {
        self.dst_image_layout = dst_image_layout;
        self
    }
    #[inline]
    pub fn regions(mut self, regions: &'a [ImageResolve2]) -> Self {
        self.region_count = regions.len() as _;
        self.p_regions = regions.as_ptr();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT.html>"]
pub struct PhysicalDeviceShaderImageAtomicInt64FeaturesEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shader_image_int64_atomics: Bool32,
    pub sparse_image_int64_atomics: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceShaderImageAtomicInt64FeaturesEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            shader_image_int64_atomics: Bool32::default(),
            sparse_image_int64_atomics: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceShaderImageAtomicInt64FeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT;
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceShaderImageAtomicInt64FeaturesEXT<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceShaderImageAtomicInt64FeaturesEXT<'_> {}
impl<'a> PhysicalDeviceShaderImageAtomicInt64FeaturesEXT<'a> {
    #[inline]
    pub fn shader_image_int64_atomics(mut self, shader_image_int64_atomics: bool) -> Self {
        self.shader_image_int64_atomics = shader_image_int64_atomics.into();
        self
    }
    #[inline]
    pub fn sparse_image_int64_atomics(mut self, sparse_image_int64_atomics: bool) -> Self {
        self.sparse_image_int64_atomics = sparse_image_int64_atomics.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFragmentShadingRateAttachmentInfoKHR.html>"]
pub struct FragmentShadingRateAttachmentInfoKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub p_fragment_shading_rate_attachment: *const AttachmentReference2<'a>,
    pub shading_rate_attachment_texel_size: Extent2D,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for FragmentShadingRateAttachmentInfoKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            p_fragment_shading_rate_attachment: ::std::ptr::null(),
            shading_rate_attachment_texel_size: Extent2D::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for FragmentShadingRateAttachmentInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR;
}
unsafe impl ExtendsSubpassDescription2 for FragmentShadingRateAttachmentInfoKHR<'_> {}
impl<'a> FragmentShadingRateAttachmentInfoKHR<'a> {
    #[inline]
    pub fn fragment_shading_rate_attachment(
        mut self,
        fragment_shading_rate_attachment: &'a AttachmentReference2<'a>,
    ) -> Self {
        self.p_fragment_shading_rate_attachment = fragment_shading_rate_attachment;
        self
    }
    #[inline]
    pub fn shading_rate_attachment_texel_size(
        mut self,
        shading_rate_attachment_texel_size: Extent2D,
    ) -> Self {
        self.shading_rate_attachment_texel_size = shading_rate_attachment_texel_size;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineFragmentShadingRateStateCreateInfoKHR.html>"]
pub struct PipelineFragmentShadingRateStateCreateInfoKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub fragment_size: Extent2D,
    pub combiner_ops: [FragmentShadingRateCombinerOpKHR; 2],
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PipelineFragmentShadingRateStateCreateInfoKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            fragment_size: Extent2D::default(),
            combiner_ops: unsafe { ::std::mem::zeroed() },
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PipelineFragmentShadingRateStateCreateInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR;
}
unsafe impl ExtendsGraphicsPipelineCreateInfo
    for PipelineFragmentShadingRateStateCreateInfoKHR<'_>
{
}
impl<'a> PipelineFragmentShadingRateStateCreateInfoKHR<'a> {
    #[inline]
    pub fn fragment_size(mut self, fragment_size: Extent2D) -> Self {
        self.fragment_size = fragment_size;
        self
    }
    #[inline]
    pub fn combiner_ops(mut self, combiner_ops: [FragmentShadingRateCombinerOpKHR; 2]) -> Self {
        self.combiner_ops = combiner_ops;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFragmentShadingRateFeaturesKHR.html>"]
pub struct PhysicalDeviceFragmentShadingRateFeaturesKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub pipeline_fragment_shading_rate: Bool32,
    pub primitive_fragment_shading_rate: Bool32,
    pub attachment_fragment_shading_rate: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceFragmentShadingRateFeaturesKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            pipeline_fragment_shading_rate: Bool32::default(),
            primitive_fragment_shading_rate: Bool32::default(),
            attachment_fragment_shading_rate: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceFragmentShadingRateFeaturesKHR<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR;
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceFragmentShadingRateFeaturesKHR<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceFragmentShadingRateFeaturesKHR<'_> {}
impl<'a> PhysicalDeviceFragmentShadingRateFeaturesKHR<'a> {
    #[inline]
    pub fn pipeline_fragment_shading_rate(mut self, pipeline_fragment_shading_rate: bool) -> Self {
        self.pipeline_fragment_shading_rate = pipeline_fragment_shading_rate.into();
        self
    }
    #[inline]
    pub fn primitive_fragment_shading_rate(
        mut self,
        primitive_fragment_shading_rate: bool,
    ) -> Self {
        self.primitive_fragment_shading_rate = primitive_fragment_shading_rate.into();
        self
    }
    #[inline]
    pub fn attachment_fragment_shading_rate(
        mut self,
        attachment_fragment_shading_rate: bool,
    ) -> Self {
        self.attachment_fragment_shading_rate = attachment_fragment_shading_rate.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFragmentShadingRatePropertiesKHR.html>"]
pub struct PhysicalDeviceFragmentShadingRatePropertiesKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub min_fragment_shading_rate_attachment_texel_size: Extent2D,
    pub max_fragment_shading_rate_attachment_texel_size: Extent2D,
    pub max_fragment_shading_rate_attachment_texel_size_aspect_ratio: u32,
    pub primitive_fragment_shading_rate_with_multiple_viewports: Bool32,
    pub layered_shading_rate_attachments: Bool32,
    pub fragment_shading_rate_non_trivial_combiner_ops: Bool32,
    pub max_fragment_size: Extent2D,
    pub max_fragment_size_aspect_ratio: u32,
    pub max_fragment_shading_rate_coverage_samples: u32,
    pub max_fragment_shading_rate_rasterization_samples: SampleCountFlags,
    pub fragment_shading_rate_with_shader_depth_stencil_writes: Bool32,
    pub fragment_shading_rate_with_sample_mask: Bool32,
    pub fragment_shading_rate_with_shader_sample_mask: Bool32,
    pub fragment_shading_rate_with_conservative_rasterization: Bool32,
    pub fragment_shading_rate_with_fragment_shader_interlock: Bool32,
    pub fragment_shading_rate_with_custom_sample_locations: Bool32,
    pub fragment_shading_rate_strict_multiply_combiner: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceFragmentShadingRatePropertiesKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            min_fragment_shading_rate_attachment_texel_size: Extent2D::default(),
            max_fragment_shading_rate_attachment_texel_size: Extent2D::default(),
            max_fragment_shading_rate_attachment_texel_size_aspect_ratio: u32::default(),
            primitive_fragment_shading_rate_with_multiple_viewports: Bool32::default(),
            layered_shading_rate_attachments: Bool32::default(),
            fragment_shading_rate_non_trivial_combiner_ops: Bool32::default(),
            max_fragment_size: Extent2D::default(),
            max_fragment_size_aspect_ratio: u32::default(),
            max_fragment_shading_rate_coverage_samples: u32::default(),
            max_fragment_shading_rate_rasterization_samples: SampleCountFlags::default(),
            fragment_shading_rate_with_shader_depth_stencil_writes: Bool32::default(),
            fragment_shading_rate_with_sample_mask: Bool32::default(),
            fragment_shading_rate_with_shader_sample_mask: Bool32::default(),
            fragment_shading_rate_with_conservative_rasterization: Bool32::default(),
            fragment_shading_rate_with_fragment_shader_interlock: Bool32::default(),
            fragment_shading_rate_with_custom_sample_locations: Bool32::default(),
            fragment_shading_rate_strict_multiply_combiner: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceFragmentShadingRatePropertiesKHR<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR;
}
unsafe impl ExtendsPhysicalDeviceProperties2
    for PhysicalDeviceFragmentShadingRatePropertiesKHR<'_>
{
}
impl<'a> PhysicalDeviceFragmentShadingRatePropertiesKHR<'a> {
    #[inline]
    pub fn min_fragment_shading_rate_attachment_texel_size(
        mut self,
        min_fragment_shading_rate_attachment_texel_size: Extent2D,
    ) -> Self {
        self.min_fragment_shading_rate_attachment_texel_size =
            min_fragment_shading_rate_attachment_texel_size;
        self
    }
    #[inline]
    pub fn max_fragment_shading_rate_attachment_texel_size(
        mut self,
        max_fragment_shading_rate_attachment_texel_size: Extent2D,
    ) -> Self {
        self.max_fragment_shading_rate_attachment_texel_size =
            max_fragment_shading_rate_attachment_texel_size;
        self
    }
    #[inline]
    pub fn max_fragment_shading_rate_attachment_texel_size_aspect_ratio(
        mut self,
        max_fragment_shading_rate_attachment_texel_size_aspect_ratio: u32,
    ) -> Self {
        self.max_fragment_shading_rate_attachment_texel_size_aspect_ratio =
            max_fragment_shading_rate_attachment_texel_size_aspect_ratio;
        self
    }
    #[inline]
    pub fn primitive_fragment_shading_rate_with_multiple_viewports(
        mut self,
        primitive_fragment_shading_rate_with_multiple_viewports: bool,
    ) -> Self {
        self.primitive_fragment_shading_rate_with_multiple_viewports =
            primitive_fragment_shading_rate_with_multiple_viewports.into();
        self
    }
    #[inline]
    pub fn layered_shading_rate_attachments(
        mut self,
        layered_shading_rate_attachments: bool,
    ) -> Self {
        self.layered_shading_rate_attachments = layered_shading_rate_attachments.into();
        self
    }
    #[inline]
    pub fn fragment_shading_rate_non_trivial_combiner_ops(
        mut self,
        fragment_shading_rate_non_trivial_combiner_ops: bool,
    ) -> Self {
        self.fragment_shading_rate_non_trivial_combiner_ops =
            fragment_shading_rate_non_trivial_combiner_ops.into();
        self
    }
    #[inline]
    pub fn max_fragment_size(mut self, max_fragment_size: Extent2D) -> Self {
        self.max_fragment_size = max_fragment_size;
        self
    }
    #[inline]
    pub fn max_fragment_size_aspect_ratio(mut self, max_fragment_size_aspect_ratio: u32) -> Self {
        self.max_fragment_size_aspect_ratio = max_fragment_size_aspect_ratio;
        self
    }
    #[inline]
    pub fn max_fragment_shading_rate_coverage_samples(
        mut self,
        max_fragment_shading_rate_coverage_samples: u32,
    ) -> Self {
        self.max_fragment_shading_rate_coverage_samples =
            max_fragment_shading_rate_coverage_samples;
        self
    }
    #[inline]
    pub fn max_fragment_shading_rate_rasterization_samples(
        mut self,
        max_fragment_shading_rate_rasterization_samples: SampleCountFlags,
    ) -> Self {
        self.max_fragment_shading_rate_rasterization_samples =
            max_fragment_shading_rate_rasterization_samples;
        self
    }
    #[inline]
    pub fn fragment_shading_rate_with_shader_depth_stencil_writes(
        mut self,
        fragment_shading_rate_with_shader_depth_stencil_writes: bool,
    ) -> Self {
        self.fragment_shading_rate_with_shader_depth_stencil_writes =
            fragment_shading_rate_with_shader_depth_stencil_writes.into();
        self
    }
    #[inline]
    pub fn fragment_shading_rate_with_sample_mask(
        mut self,
        fragment_shading_rate_with_sample_mask: bool,
    ) -> Self {
        self.fragment_shading_rate_with_sample_mask = fragment_shading_rate_with_sample_mask.into();
        self
    }
    #[inline]
    pub fn fragment_shading_rate_with_shader_sample_mask(
        mut self,
        fragment_shading_rate_with_shader_sample_mask: bool,
    ) -> Self {
        self.fragment_shading_rate_with_shader_sample_mask =
            fragment_shading_rate_with_shader_sample_mask.into();
        self
    }
    #[inline]
    pub fn fragment_shading_rate_with_conservative_rasterization(
        mut self,
        fragment_shading_rate_with_conservative_rasterization: bool,
    ) -> Self {
        self.fragment_shading_rate_with_conservative_rasterization =
            fragment_shading_rate_with_conservative_rasterization.into();
        self
    }
    #[inline]
    pub fn fragment_shading_rate_with_fragment_shader_interlock(
        mut self,
        fragment_shading_rate_with_fragment_shader_interlock: bool,
    ) -> Self {
        self.fragment_shading_rate_with_fragment_shader_interlock =
            fragment_shading_rate_with_fragment_shader_interlock.into();
        self
    }
    #[inline]
    pub fn fragment_shading_rate_with_custom_sample_locations(
        mut self,
        fragment_shading_rate_with_custom_sample_locations: bool,
    ) -> Self {
        self.fragment_shading_rate_with_custom_sample_locations =
            fragment_shading_rate_with_custom_sample_locations.into();
        self
    }
    #[inline]
    pub fn fragment_shading_rate_strict_multiply_combiner(
        mut self,
        fragment_shading_rate_strict_multiply_combiner: bool,
    ) -> Self {
        self.fragment_shading_rate_strict_multiply_combiner =
            fragment_shading_rate_strict_multiply_combiner.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFragmentShadingRateKHR.html>"]
pub struct PhysicalDeviceFragmentShadingRateKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub sample_counts: SampleCountFlags,
    pub fragment_size: Extent2D,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceFragmentShadingRateKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            sample_counts: SampleCountFlags::default(),
            fragment_size: Extent2D::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceFragmentShadingRateKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR;
}
impl<'a> PhysicalDeviceFragmentShadingRateKHR<'a> {
    #[inline]
    pub fn sample_counts(mut self, sample_counts: SampleCountFlags) -> Self {
        self.sample_counts = sample_counts;
        self
    }
    #[inline]
    pub fn fragment_size(mut self, fragment_size: Extent2D) -> Self {
        self.fragment_size = fragment_size;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderTerminateInvocationFeatures.html>"]
pub struct PhysicalDeviceShaderTerminateInvocationFeatures<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shader_terminate_invocation: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceShaderTerminateInvocationFeatures<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            shader_terminate_invocation: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceShaderTerminateInvocationFeatures<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES;
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceShaderTerminateInvocationFeatures<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceShaderTerminateInvocationFeatures<'_> {}
impl<'a> PhysicalDeviceShaderTerminateInvocationFeatures<'a> {
    #[inline]
    pub fn shader_terminate_invocation(mut self, shader_terminate_invocation: bool) -> Self {
        self.shader_terminate_invocation = shader_terminate_invocation.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV.html>"]
pub struct PhysicalDeviceFragmentShadingRateEnumsFeaturesNV<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub fragment_shading_rate_enums: Bool32,
    pub supersample_fragment_shading_rates: Bool32,
    pub no_invocation_fragment_shading_rates: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceFragmentShadingRateEnumsFeaturesNV<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            fragment_shading_rate_enums: Bool32::default(),
            supersample_fragment_shading_rates: Bool32::default(),
            no_invocation_fragment_shading_rates: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceFragmentShadingRateEnumsFeaturesNV<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV;
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceFragmentShadingRateEnumsFeaturesNV<'_>
{
}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceFragmentShadingRateEnumsFeaturesNV<'_> {}
impl<'a> PhysicalDeviceFragmentShadingRateEnumsFeaturesNV<'a> {
    #[inline]
    pub fn fragment_shading_rate_enums(mut self, fragment_shading_rate_enums: bool) -> Self {
        self.fragment_shading_rate_enums = fragment_shading_rate_enums.into();
        self
    }
    #[inline]
    pub fn supersample_fragment_shading_rates(
        mut self,
        supersample_fragment_shading_rates: bool,
    ) -> Self {
        self.supersample_fragment_shading_rates = supersample_fragment_shading_rates.into();
        self
    }
    #[inline]
    pub fn no_invocation_fragment_shading_rates(
        mut self,
        no_invocation_fragment_shading_rates: bool,
    ) -> Self {
        self.no_invocation_fragment_shading_rates = no_invocation_fragment_shading_rates.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV.html>"]
pub struct PhysicalDeviceFragmentShadingRateEnumsPropertiesNV<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub max_fragment_shading_rate_invocation_count: SampleCountFlags,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceFragmentShadingRateEnumsPropertiesNV<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            max_fragment_shading_rate_invocation_count: SampleCountFlags::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceFragmentShadingRateEnumsPropertiesNV<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV;
}
unsafe impl ExtendsPhysicalDeviceProperties2
    for PhysicalDeviceFragmentShadingRateEnumsPropertiesNV<'_>
{
}
impl<'a> PhysicalDeviceFragmentShadingRateEnumsPropertiesNV<'a> {
    #[inline]
    pub fn max_fragment_shading_rate_invocation_count(
        mut self,
        max_fragment_shading_rate_invocation_count: SampleCountFlags,
    ) -> Self {
        self.max_fragment_shading_rate_invocation_count =
            max_fragment_shading_rate_invocation_count;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineFragmentShadingRateEnumStateCreateInfoNV.html>"]
pub struct PipelineFragmentShadingRateEnumStateCreateInfoNV<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub shading_rate_type: FragmentShadingRateTypeNV,
    pub shading_rate: FragmentShadingRateNV,
    pub combiner_ops: [FragmentShadingRateCombinerOpKHR; 2],
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PipelineFragmentShadingRateEnumStateCreateInfoNV<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            shading_rate_type: FragmentShadingRateTypeNV::default(),
            shading_rate: FragmentShadingRateNV::default(),
            combiner_ops: unsafe { ::std::mem::zeroed() },
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PipelineFragmentShadingRateEnumStateCreateInfoNV<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV;
}
unsafe impl ExtendsGraphicsPipelineCreateInfo
    for PipelineFragmentShadingRateEnumStateCreateInfoNV<'_>
{
}
impl<'a> PipelineFragmentShadingRateEnumStateCreateInfoNV<'a> {
    #[inline]
    pub fn shading_rate_type(mut self, shading_rate_type: FragmentShadingRateTypeNV) -> Self {
        self.shading_rate_type = shading_rate_type;
        self
    }
    #[inline]
    pub fn shading_rate(mut self, shading_rate: FragmentShadingRateNV) -> Self {
        self.shading_rate = shading_rate;
        self
    }
    #[inline]
    pub fn combiner_ops(mut self, combiner_ops: [FragmentShadingRateCombinerOpKHR; 2]) -> Self {
        self.combiner_ops = combiner_ops;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAccelerationStructureBuildSizesInfoKHR.html>"]
pub struct AccelerationStructureBuildSizesInfoKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub acceleration_structure_size: DeviceSize,
    pub update_scratch_size: DeviceSize,
    pub build_scratch_size: DeviceSize,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for AccelerationStructureBuildSizesInfoKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            acceleration_structure_size: DeviceSize::default(),
            update_scratch_size: DeviceSize::default(),
            build_scratch_size: DeviceSize::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for AccelerationStructureBuildSizesInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR;
}
impl<'a> AccelerationStructureBuildSizesInfoKHR<'a> {
    #[inline]
    pub fn acceleration_structure_size(mut self, acceleration_structure_size: DeviceSize) -> Self {
        self.acceleration_structure_size = acceleration_structure_size;
        self
    }
    #[inline]
    pub fn update_scratch_size(mut self, update_scratch_size: DeviceSize) -> Self {
        self.update_scratch_size = update_scratch_size;
        self
    }
    #[inline]
    pub fn build_scratch_size(mut self, build_scratch_size: DeviceSize) -> Self {
        self.build_scratch_size = build_scratch_size;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceImage2DViewOf3DFeaturesEXT.html>"]
pub struct PhysicalDeviceImage2DViewOf3DFeaturesEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub image2_d_view_of3_d: Bool32,
    pub sampler2_d_view_of3_d: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceImage2DViewOf3DFeaturesEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            image2_d_view_of3_d: Bool32::default(),
            sampler2_d_view_of3_d: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceImage2DViewOf3DFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT;
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceImage2DViewOf3DFeaturesEXT<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceImage2DViewOf3DFeaturesEXT<'_> {}
impl<'a> PhysicalDeviceImage2DViewOf3DFeaturesEXT<'a> {
    #[inline]
    pub fn image2_d_view_of3_d(mut self, image2_d_view_of3_d: bool) -> Self {
        self.image2_d_view_of3_d = image2_d_view_of3_d.into();
        self
    }
    #[inline]
    pub fn sampler2_d_view_of3_d(mut self, sampler2_d_view_of3_d: bool) -> Self {
        self.sampler2_d_view_of3_d = sampler2_d_view_of3_d.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE.html>"]
pub struct PhysicalDeviceMutableDescriptorTypeFeaturesVALVE<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub mutable_descriptor_type: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceMutableDescriptorTypeFeaturesVALVE<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            mutable_descriptor_type: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceMutableDescriptorTypeFeaturesVALVE<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_VALVE;
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceMutableDescriptorTypeFeaturesVALVE<'_>
{
}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceMutableDescriptorTypeFeaturesVALVE<'_> {}
impl<'a> PhysicalDeviceMutableDescriptorTypeFeaturesVALVE<'a> {
    #[inline]
    pub fn mutable_descriptor_type(mut self, mutable_descriptor_type: bool) -> Self {
        self.mutable_descriptor_type = mutable_descriptor_type.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMutableDescriptorTypeListVALVE.html>"]
pub struct MutableDescriptorTypeListVALVE<'a> {
    pub descriptor_type_count: u32,
    pub p_descriptor_types: *const DescriptorType,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for MutableDescriptorTypeListVALVE<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            descriptor_type_count: u32::default(),
            p_descriptor_types: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
impl<'a> MutableDescriptorTypeListVALVE<'a> {
    #[inline]
    pub fn descriptor_types(mut self, descriptor_types: &'a [DescriptorType]) -> Self {
        self.descriptor_type_count = descriptor_types.len() as _;
        self.p_descriptor_types = descriptor_types.as_ptr();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMutableDescriptorTypeCreateInfoVALVE.html>"]
pub struct MutableDescriptorTypeCreateInfoVALVE<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub mutable_descriptor_type_list_count: u32,
    pub p_mutable_descriptor_type_lists: *const MutableDescriptorTypeListVALVE<'a>,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for MutableDescriptorTypeCreateInfoVALVE<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            mutable_descriptor_type_list_count: u32::default(),
            p_mutable_descriptor_type_lists: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for MutableDescriptorTypeCreateInfoVALVE<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_VALVE;
}
unsafe impl ExtendsDescriptorSetLayoutCreateInfo for MutableDescriptorTypeCreateInfoVALVE<'_> {}
unsafe impl ExtendsDescriptorPoolCreateInfo for MutableDescriptorTypeCreateInfoVALVE<'_> {}
impl<'a> MutableDescriptorTypeCreateInfoVALVE<'a> {
    #[inline]
    pub fn mutable_descriptor_type_lists(
        mut self,
        mutable_descriptor_type_lists: &'a [MutableDescriptorTypeListVALVE],
    ) -> Self {
        self.mutable_descriptor_type_list_count = mutable_descriptor_type_lists.len() as _;
        self.p_mutable_descriptor_type_lists = mutable_descriptor_type_lists.as_ptr();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDepthClipControlFeaturesEXT.html>"]
pub struct PhysicalDeviceDepthClipControlFeaturesEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub depth_clip_control: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceDepthClipControlFeaturesEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            depth_clip_control: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceDepthClipControlFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT;
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceDepthClipControlFeaturesEXT<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceDepthClipControlFeaturesEXT<'_> {}
impl<'a> PhysicalDeviceDepthClipControlFeaturesEXT<'a> {
    #[inline]
    pub fn depth_clip_control(mut self, depth_clip_control: bool) -> Self {
        self.depth_clip_control = depth_clip_control.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineViewportDepthClipControlCreateInfoEXT.html>"]
pub struct PipelineViewportDepthClipControlCreateInfoEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub negative_one_to_one: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PipelineViewportDepthClipControlCreateInfoEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            negative_one_to_one: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PipelineViewportDepthClipControlCreateInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT;
}
unsafe impl ExtendsPipelineViewportStateCreateInfo
    for PipelineViewportDepthClipControlCreateInfoEXT<'_>
{
}
impl<'a> PipelineViewportDepthClipControlCreateInfoEXT<'a> {
    #[inline]
    pub fn negative_one_to_one(mut self, negative_one_to_one: bool) -> Self {
        self.negative_one_to_one = negative_one_to_one.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT.html>"]
pub struct PhysicalDeviceVertexInputDynamicStateFeaturesEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub vertex_input_dynamic_state: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceVertexInputDynamicStateFeaturesEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            vertex_input_dynamic_state: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceVertexInputDynamicStateFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT;
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceVertexInputDynamicStateFeaturesEXT<'_>
{
}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceVertexInputDynamicStateFeaturesEXT<'_> {}
impl<'a> PhysicalDeviceVertexInputDynamicStateFeaturesEXT<'a> {
    #[inline]
    pub fn vertex_input_dynamic_state(mut self, vertex_input_dynamic_state: bool) -> Self {
        self.vertex_input_dynamic_state = vertex_input_dynamic_state.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceExternalMemoryRDMAFeaturesNV.html>"]
pub struct PhysicalDeviceExternalMemoryRDMAFeaturesNV<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub external_memory_rdma: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceExternalMemoryRDMAFeaturesNV<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            external_memory_rdma: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceExternalMemoryRDMAFeaturesNV<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_EXTERNAL_MEMORY_RDMA_FEATURES_NV;
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceExternalMemoryRDMAFeaturesNV<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceExternalMemoryRDMAFeaturesNV<'_> {}
impl<'a> PhysicalDeviceExternalMemoryRDMAFeaturesNV<'a> {
    #[inline]
    pub fn external_memory_rdma(mut self, external_memory_rdma: bool) -> Self {
        self.external_memory_rdma = external_memory_rdma.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVertexInputBindingDescription2EXT.html>"]
pub struct VertexInputBindingDescription2EXT<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub binding: u32,
    pub stride: u32,
    pub input_rate: VertexInputRate,
    pub divisor: u32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for VertexInputBindingDescription2EXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            binding: u32::default(),
            stride: u32::default(),
            input_rate: VertexInputRate::default(),
            divisor: u32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for VertexInputBindingDescription2EXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT;
}
impl<'a> VertexInputBindingDescription2EXT<'a> {
    #[inline]
    pub fn binding(mut self, binding: u32) -> Self {
        self.binding = binding;
        self
    }
    #[inline]
    pub fn stride(mut self, stride: u32) -> Self {
        self.stride = stride;
        self
    }
    #[inline]
    pub fn input_rate(mut self, input_rate: VertexInputRate) -> Self {
        self.input_rate = input_rate;
        self
    }
    #[inline]
    pub fn divisor(mut self, divisor: u32) -> Self {
        self.divisor = divisor;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVertexInputAttributeDescription2EXT.html>"]
pub struct VertexInputAttributeDescription2EXT<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub location: u32,
    pub binding: u32,
    pub format: Format,
    pub offset: u32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for VertexInputAttributeDescription2EXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            location: u32::default(),
            binding: u32::default(),
            format: Format::default(),
            offset: u32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for VertexInputAttributeDescription2EXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT;
}
impl<'a> VertexInputAttributeDescription2EXT<'a> {
    #[inline]
    pub fn location(mut self, location: u32) -> Self {
        self.location = location;
        self
    }
    #[inline]
    pub fn binding(mut self, binding: u32) -> Self {
        self.binding = binding;
        self
    }
    #[inline]
    pub fn format(mut self, format: Format) -> Self {
        self.format = format;
        self
    }
    #[inline]
    pub fn offset(mut self, offset: u32) -> Self {
        self.offset = offset;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceColorWriteEnableFeaturesEXT.html>"]
pub struct PhysicalDeviceColorWriteEnableFeaturesEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub color_write_enable: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceColorWriteEnableFeaturesEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            color_write_enable: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceColorWriteEnableFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT;
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceColorWriteEnableFeaturesEXT<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceColorWriteEnableFeaturesEXT<'_> {}
impl<'a> PhysicalDeviceColorWriteEnableFeaturesEXT<'a> {
    #[inline]
    pub fn color_write_enable(mut self, color_write_enable: bool) -> Self {
        self.color_write_enable = color_write_enable.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineColorWriteCreateInfoEXT.html>"]
pub struct PipelineColorWriteCreateInfoEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub attachment_count: u32,
    pub p_color_write_enables: *const Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PipelineColorWriteCreateInfoEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            attachment_count: u32::default(),
            p_color_write_enables: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PipelineColorWriteCreateInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PIPELINE_COLOR_WRITE_CREATE_INFO_EXT;
}
unsafe impl ExtendsPipelineColorBlendStateCreateInfo for PipelineColorWriteCreateInfoEXT<'_> {}
impl<'a> PipelineColorWriteCreateInfoEXT<'a> {
    #[inline]
    pub fn color_write_enables(mut self, color_write_enables: &'a [Bool32]) -> Self {
        self.attachment_count = color_write_enables.len() as _;
        self.p_color_write_enables = color_write_enables.as_ptr();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryBarrier2.html>"]
pub struct MemoryBarrier2<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub src_stage_mask: PipelineStageFlags2,
    pub src_access_mask: AccessFlags2,
    pub dst_stage_mask: PipelineStageFlags2,
    pub dst_access_mask: AccessFlags2,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for MemoryBarrier2<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            src_stage_mask: PipelineStageFlags2::default(),
            src_access_mask: AccessFlags2::default(),
            dst_stage_mask: PipelineStageFlags2::default(),
            dst_access_mask: AccessFlags2::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for MemoryBarrier2<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::MEMORY_BARRIER_2;
}
unsafe impl ExtendsSubpassDependency2 for MemoryBarrier2<'_> {}
impl<'a> MemoryBarrier2<'a> {
    #[inline]
    pub fn src_stage_mask(mut self, src_stage_mask: PipelineStageFlags2) -> Self {
        self.src_stage_mask = src_stage_mask;
        self
    }
    #[inline]
    pub fn src_access_mask(mut self, src_access_mask: AccessFlags2) -> Self {
        self.src_access_mask = src_access_mask;
        self
    }
    #[inline]
    pub fn dst_stage_mask(mut self, dst_stage_mask: PipelineStageFlags2) -> Self {
        self.dst_stage_mask = dst_stage_mask;
        self
    }
    #[inline]
    pub fn dst_access_mask(mut self, dst_access_mask: AccessFlags2) -> Self {
        self.dst_access_mask = dst_access_mask;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageMemoryBarrier2.html>"]
pub struct ImageMemoryBarrier2<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub src_stage_mask: PipelineStageFlags2,
    pub src_access_mask: AccessFlags2,
    pub dst_stage_mask: PipelineStageFlags2,
    pub dst_access_mask: AccessFlags2,
    pub old_layout: ImageLayout,
    pub new_layout: ImageLayout,
    pub src_queue_family_index: u32,
    pub dst_queue_family_index: u32,
    pub image: Image,
    pub subresource_range: ImageSubresourceRange,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for ImageMemoryBarrier2<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            src_stage_mask: PipelineStageFlags2::default(),
            src_access_mask: AccessFlags2::default(),
            dst_stage_mask: PipelineStageFlags2::default(),
            dst_access_mask: AccessFlags2::default(),
            old_layout: ImageLayout::default(),
            new_layout: ImageLayout::default(),
            src_queue_family_index: u32::default(),
            dst_queue_family_index: u32::default(),
            image: Image::default(),
            subresource_range: ImageSubresourceRange::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for ImageMemoryBarrier2<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::IMAGE_MEMORY_BARRIER_2;
}
pub unsafe trait ExtendsImageMemoryBarrier2 {}
impl<'a> ImageMemoryBarrier2<'a> {
    #[inline]
    pub fn src_stage_mask(mut self, src_stage_mask: PipelineStageFlags2) -> Self {
        self.src_stage_mask = src_stage_mask;
        self
    }
    #[inline]
    pub fn src_access_mask(mut self, src_access_mask: AccessFlags2) -> Self {
        self.src_access_mask = src_access_mask;
        self
    }
    #[inline]
    pub fn dst_stage_mask(mut self, dst_stage_mask: PipelineStageFlags2) -> Self {
        self.dst_stage_mask = dst_stage_mask;
        self
    }
    #[inline]
    pub fn dst_access_mask(mut self, dst_access_mask: AccessFlags2) -> Self {
        self.dst_access_mask = dst_access_mask;
        self
    }
    #[inline]
    pub fn old_layout(mut self, old_layout: ImageLayout) -> Self {
        self.old_layout = old_layout;
        self
    }
    #[inline]
    pub fn new_layout(mut self, new_layout: ImageLayout) -> Self {
        self.new_layout = new_layout;
        self
    }
    #[inline]
    pub fn src_queue_family_index(mut self, src_queue_family_index: u32) -> Self {
        self.src_queue_family_index = src_queue_family_index;
        self
    }
    #[inline]
    pub fn dst_queue_family_index(mut self, dst_queue_family_index: u32) -> Self {
        self.dst_queue_family_index = dst_queue_family_index;
        self
    }
    #[inline]
    pub fn image(mut self, image: Image) -> Self {
        self.image = image;
        self
    }
    #[inline]
    pub fn subresource_range(mut self, subresource_range: ImageSubresourceRange) -> Self {
        self.subresource_range = subresource_range;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `x.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsImageMemoryBarrier2>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.p_next as _;
            self.p_next = next_ptr;
        }
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferMemoryBarrier2.html>"]
pub struct BufferMemoryBarrier2<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub src_stage_mask: PipelineStageFlags2,
    pub src_access_mask: AccessFlags2,
    pub dst_stage_mask: PipelineStageFlags2,
    pub dst_access_mask: AccessFlags2,
    pub src_queue_family_index: u32,
    pub dst_queue_family_index: u32,
    pub buffer: Buffer,
    pub offset: DeviceSize,
    pub size: DeviceSize,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for BufferMemoryBarrier2<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            src_stage_mask: PipelineStageFlags2::default(),
            src_access_mask: AccessFlags2::default(),
            dst_stage_mask: PipelineStageFlags2::default(),
            dst_access_mask: AccessFlags2::default(),
            src_queue_family_index: u32::default(),
            dst_queue_family_index: u32::default(),
            buffer: Buffer::default(),
            offset: DeviceSize::default(),
            size: DeviceSize::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for BufferMemoryBarrier2<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::BUFFER_MEMORY_BARRIER_2;
}
impl<'a> BufferMemoryBarrier2<'a> {
    #[inline]
    pub fn src_stage_mask(mut self, src_stage_mask: PipelineStageFlags2) -> Self {
        self.src_stage_mask = src_stage_mask;
        self
    }
    #[inline]
    pub fn src_access_mask(mut self, src_access_mask: AccessFlags2) -> Self {
        self.src_access_mask = src_access_mask;
        self
    }
    #[inline]
    pub fn dst_stage_mask(mut self, dst_stage_mask: PipelineStageFlags2) -> Self {
        self.dst_stage_mask = dst_stage_mask;
        self
    }
    #[inline]
    pub fn dst_access_mask(mut self, dst_access_mask: AccessFlags2) -> Self {
        self.dst_access_mask = dst_access_mask;
        self
    }
    #[inline]
    pub fn src_queue_family_index(mut self, src_queue_family_index: u32) -> Self {
        self.src_queue_family_index = src_queue_family_index;
        self
    }
    #[inline]
    pub fn dst_queue_family_index(mut self, dst_queue_family_index: u32) -> Self {
        self.dst_queue_family_index = dst_queue_family_index;
        self
    }
    #[inline]
    pub fn buffer(mut self, buffer: Buffer) -> Self {
        self.buffer = buffer;
        self
    }
    #[inline]
    pub fn offset(mut self, offset: DeviceSize) -> Self {
        self.offset = offset;
        self
    }
    #[inline]
    pub fn size(mut self, size: DeviceSize) -> Self {
        self.size = size;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDependencyInfo.html>"]
pub struct DependencyInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub dependency_flags: DependencyFlags,
    pub memory_barrier_count: u32,
    pub p_memory_barriers: *const MemoryBarrier2<'a>,
    pub buffer_memory_barrier_count: u32,
    pub p_buffer_memory_barriers: *const BufferMemoryBarrier2<'a>,
    pub image_memory_barrier_count: u32,
    pub p_image_memory_barriers: *const ImageMemoryBarrier2<'a>,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for DependencyInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            dependency_flags: DependencyFlags::default(),
            memory_barrier_count: u32::default(),
            p_memory_barriers: ::std::ptr::null(),
            buffer_memory_barrier_count: u32::default(),
            p_buffer_memory_barriers: ::std::ptr::null(),
            image_memory_barrier_count: u32::default(),
            p_image_memory_barriers: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for DependencyInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DEPENDENCY_INFO;
}
impl<'a> DependencyInfo<'a> {
    #[inline]
    pub fn dependency_flags(mut self, dependency_flags: DependencyFlags) -> Self {
        self.dependency_flags = dependency_flags;
        self
    }
    #[inline]
    pub fn memory_barriers(mut self, memory_barriers: &'a [MemoryBarrier2]) -> Self {
        self.memory_barrier_count = memory_barriers.len() as _;
        self.p_memory_barriers = memory_barriers.as_ptr();
        self
    }
    #[inline]
    pub fn buffer_memory_barriers(
        mut self,
        buffer_memory_barriers: &'a [BufferMemoryBarrier2],
    ) -> Self {
        self.buffer_memory_barrier_count = buffer_memory_barriers.len() as _;
        self.p_buffer_memory_barriers = buffer_memory_barriers.as_ptr();
        self
    }
    #[inline]
    pub fn image_memory_barriers(
        mut self,
        image_memory_barriers: &'a [ImageMemoryBarrier2],
    ) -> Self {
        self.image_memory_barrier_count = image_memory_barriers.len() as _;
        self.p_image_memory_barriers = image_memory_barriers.as_ptr();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSemaphoreSubmitInfo.html>"]
pub struct SemaphoreSubmitInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub semaphore: Semaphore,
    pub value: u64,
    pub stage_mask: PipelineStageFlags2,
    pub device_index: u32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for SemaphoreSubmitInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            semaphore: Semaphore::default(),
            value: u64::default(),
            stage_mask: PipelineStageFlags2::default(),
            device_index: u32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for SemaphoreSubmitInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::SEMAPHORE_SUBMIT_INFO;
}
impl<'a> SemaphoreSubmitInfo<'a> {
    #[inline]
    pub fn semaphore(mut self, semaphore: Semaphore) -> Self {
        self.semaphore = semaphore;
        self
    }
    #[inline]
    pub fn value(mut self, value: u64) -> Self {
        self.value = value;
        self
    }
    #[inline]
    pub fn stage_mask(mut self, stage_mask: PipelineStageFlags2) -> Self {
        self.stage_mask = stage_mask;
        self
    }
    #[inline]
    pub fn device_index(mut self, device_index: u32) -> Self {
        self.device_index = device_index;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandBufferSubmitInfo.html>"]
pub struct CommandBufferSubmitInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub command_buffer: CommandBuffer,
    pub device_mask: u32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for CommandBufferSubmitInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            command_buffer: CommandBuffer::default(),
            device_mask: u32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for CommandBufferSubmitInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::COMMAND_BUFFER_SUBMIT_INFO;
}
impl<'a> CommandBufferSubmitInfo<'a> {
    #[inline]
    pub fn command_buffer(mut self, command_buffer: CommandBuffer) -> Self {
        self.command_buffer = command_buffer;
        self
    }
    #[inline]
    pub fn device_mask(mut self, device_mask: u32) -> Self {
        self.device_mask = device_mask;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSubmitInfo2.html>"]
pub struct SubmitInfo2<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: SubmitFlags,
    pub wait_semaphore_info_count: u32,
    pub p_wait_semaphore_infos: *const SemaphoreSubmitInfo<'a>,
    pub command_buffer_info_count: u32,
    pub p_command_buffer_infos: *const CommandBufferSubmitInfo<'a>,
    pub signal_semaphore_info_count: u32,
    pub p_signal_semaphore_infos: *const SemaphoreSubmitInfo<'a>,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for SubmitInfo2<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: SubmitFlags::default(),
            wait_semaphore_info_count: u32::default(),
            p_wait_semaphore_infos: ::std::ptr::null(),
            command_buffer_info_count: u32::default(),
            p_command_buffer_infos: ::std::ptr::null(),
            signal_semaphore_info_count: u32::default(),
            p_signal_semaphore_infos: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for SubmitInfo2<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::SUBMIT_INFO_2;
}
pub unsafe trait ExtendsSubmitInfo2 {}
impl<'a> SubmitInfo2<'a> {
    #[inline]
    pub fn flags(mut self, flags: SubmitFlags) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn wait_semaphore_infos(mut self, wait_semaphore_infos: &'a [SemaphoreSubmitInfo]) -> Self {
        self.wait_semaphore_info_count = wait_semaphore_infos.len() as _;
        self.p_wait_semaphore_infos = wait_semaphore_infos.as_ptr();
        self
    }
    #[inline]
    pub fn command_buffer_infos(
        mut self,
        command_buffer_infos: &'a [CommandBufferSubmitInfo],
    ) -> Self {
        self.command_buffer_info_count = command_buffer_infos.len() as _;
        self.p_command_buffer_infos = command_buffer_infos.as_ptr();
        self
    }
    #[inline]
    pub fn signal_semaphore_infos(
        mut self,
        signal_semaphore_infos: &'a [SemaphoreSubmitInfo],
    ) -> Self {
        self.signal_semaphore_info_count = signal_semaphore_infos.len() as _;
        self.p_signal_semaphore_infos = signal_semaphore_infos.as_ptr();
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `x.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsSubmitInfo2>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.p_next as _;
            self.p_next = next_ptr;
        }
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkQueueFamilyCheckpointProperties2NV.html>"]
pub struct QueueFamilyCheckpointProperties2NV<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub checkpoint_execution_stage_mask: PipelineStageFlags2,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for QueueFamilyCheckpointProperties2NV<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            checkpoint_execution_stage_mask: PipelineStageFlags2::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for QueueFamilyCheckpointProperties2NV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV;
}
unsafe impl ExtendsQueueFamilyProperties2 for QueueFamilyCheckpointProperties2NV<'_> {}
impl<'a> QueueFamilyCheckpointProperties2NV<'a> {
    #[inline]
    pub fn checkpoint_execution_stage_mask(
        mut self,
        checkpoint_execution_stage_mask: PipelineStageFlags2,
    ) -> Self {
        self.checkpoint_execution_stage_mask = checkpoint_execution_stage_mask;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCheckpointData2NV.html>"]
pub struct CheckpointData2NV<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub stage: PipelineStageFlags2,
    pub p_checkpoint_marker: *mut c_void,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for CheckpointData2NV<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            stage: PipelineStageFlags2::default(),
            p_checkpoint_marker: ::std::ptr::null_mut(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for CheckpointData2NV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::CHECKPOINT_DATA_2_NV;
}
impl<'a> CheckpointData2NV<'a> {
    #[inline]
    pub fn stage(mut self, stage: PipelineStageFlags2) -> Self {
        self.stage = stage;
        self
    }
    #[inline]
    pub fn checkpoint_marker(mut self, checkpoint_marker: *mut c_void) -> Self {
        self.p_checkpoint_marker = checkpoint_marker;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceSynchronization2Features.html>"]
pub struct PhysicalDeviceSynchronization2Features<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub synchronization2: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceSynchronization2Features<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            synchronization2: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceSynchronization2Features<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES;
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceSynchronization2Features<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceSynchronization2Features<'_> {}
impl<'a> PhysicalDeviceSynchronization2Features<'a> {
    #[inline]
    pub fn synchronization2(mut self, synchronization2: bool) -> Self {
        self.synchronization2 = synchronization2.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT.html>"]
pub struct PhysicalDevicePrimitivesGeneratedQueryFeaturesEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub primitives_generated_query: Bool32,
    pub primitives_generated_query_with_rasterizer_discard: Bool32,
    pub primitives_generated_query_with_non_zero_streams: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDevicePrimitivesGeneratedQueryFeaturesEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            primitives_generated_query: Bool32::default(),
            primitives_generated_query_with_rasterizer_discard: Bool32::default(),
            primitives_generated_query_with_non_zero_streams: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDevicePrimitivesGeneratedQueryFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT;
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDevicePrimitivesGeneratedQueryFeaturesEXT<'_>
{
}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDevicePrimitivesGeneratedQueryFeaturesEXT<'_> {}
impl<'a> PhysicalDevicePrimitivesGeneratedQueryFeaturesEXT<'a> {
    #[inline]
    pub fn primitives_generated_query(mut self, primitives_generated_query: bool) -> Self {
        self.primitives_generated_query = primitives_generated_query.into();
        self
    }
    #[inline]
    pub fn primitives_generated_query_with_rasterizer_discard(
        mut self,
        primitives_generated_query_with_rasterizer_discard: bool,
    ) -> Self {
        self.primitives_generated_query_with_rasterizer_discard =
            primitives_generated_query_with_rasterizer_discard.into();
        self
    }
    #[inline]
    pub fn primitives_generated_query_with_non_zero_streams(
        mut self,
        primitives_generated_query_with_non_zero_streams: bool,
    ) -> Self {
        self.primitives_generated_query_with_non_zero_streams =
            primitives_generated_query_with_non_zero_streams.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT.html>"]
pub struct PhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub multisampled_render_to_single_sampled: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            multisampled_render_to_single_sampled: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT;
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT<'_>
{
}
unsafe impl ExtendsDeviceCreateInfo
    for PhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT<'_>
{
}
impl<'a> PhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT<'a> {
    #[inline]
    pub fn multisampled_render_to_single_sampled(
        mut self,
        multisampled_render_to_single_sampled: bool,
    ) -> Self {
        self.multisampled_render_to_single_sampled = multisampled_render_to_single_sampled.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSubpassResolvePerformanceQueryEXT.html>"]
pub struct SubpassResolvePerformanceQueryEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub optimal: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for SubpassResolvePerformanceQueryEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            optimal: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for SubpassResolvePerformanceQueryEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT;
}
unsafe impl ExtendsFormatProperties2 for SubpassResolvePerformanceQueryEXT<'_> {}
impl<'a> SubpassResolvePerformanceQueryEXT<'a> {
    #[inline]
    pub fn optimal(mut self, optimal: bool) -> Self {
        self.optimal = optimal.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMultisampledRenderToSingleSampledInfoEXT.html>"]
pub struct MultisampledRenderToSingleSampledInfoEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub multisampled_render_to_single_sampled_enable: Bool32,
    pub rasterization_samples: SampleCountFlags,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for MultisampledRenderToSingleSampledInfoEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            multisampled_render_to_single_sampled_enable: Bool32::default(),
            rasterization_samples: SampleCountFlags::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for MultisampledRenderToSingleSampledInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT;
}
unsafe impl ExtendsSubpassDescription2 for MultisampledRenderToSingleSampledInfoEXT<'_> {}
unsafe impl ExtendsRenderingInfo for MultisampledRenderToSingleSampledInfoEXT<'_> {}
impl<'a> MultisampledRenderToSingleSampledInfoEXT<'a> {
    #[inline]
    pub fn multisampled_render_to_single_sampled_enable(
        mut self,
        multisampled_render_to_single_sampled_enable: bool,
    ) -> Self {
        self.multisampled_render_to_single_sampled_enable =
            multisampled_render_to_single_sampled_enable.into();
        self
    }
    #[inline]
    pub fn rasterization_samples(mut self, rasterization_samples: SampleCountFlags) -> Self {
        self.rasterization_samples = rasterization_samples;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoQueueFamilyProperties2KHR.html>"]
pub struct VideoQueueFamilyProperties2KHR<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub video_codec_operations: VideoCodecOperationFlagsKHR,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for VideoQueueFamilyProperties2KHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            video_codec_operations: VideoCodecOperationFlagsKHR::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for VideoQueueFamilyProperties2KHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::VIDEO_QUEUE_FAMILY_PROPERTIES_2_KHR;
}
unsafe impl ExtendsQueueFamilyProperties2 for VideoQueueFamilyProperties2KHR<'_> {}
impl<'a> VideoQueueFamilyProperties2KHR<'a> {
    #[inline]
    pub fn video_codec_operations(
        mut self,
        video_codec_operations: VideoCodecOperationFlagsKHR,
    ) -> Self {
        self.video_codec_operations = video_codec_operations;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkQueueFamilyQueryResultStatusProperties2KHR.html>"]
pub struct QueueFamilyQueryResultStatusProperties2KHR<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub query_result_status_support: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for QueueFamilyQueryResultStatusProperties2KHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            query_result_status_support: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for QueueFamilyQueryResultStatusProperties2KHR<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::QUEUE_FAMILY_QUERY_RESULT_STATUS_PROPERTIES_2_KHR;
}
unsafe impl ExtendsQueueFamilyProperties2 for QueueFamilyQueryResultStatusProperties2KHR<'_> {}
impl<'a> QueueFamilyQueryResultStatusProperties2KHR<'a> {
    #[inline]
    pub fn query_result_status_support(mut self, query_result_status_support: bool) -> Self {
        self.query_result_status_support = query_result_status_support.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoProfilesKHR.html>"]
pub struct VideoProfilesKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub profile_count: u32,
    pub p_profiles: *const VideoProfileKHR<'a>,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for VideoProfilesKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            profile_count: u32::default(),
            p_profiles: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for VideoProfilesKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::VIDEO_PROFILES_KHR;
}
unsafe impl ExtendsPhysicalDeviceImageFormatInfo2 for VideoProfilesKHR<'_> {}
unsafe impl ExtendsPhysicalDeviceVideoFormatInfoKHR for VideoProfilesKHR<'_> {}
unsafe impl ExtendsImageCreateInfo for VideoProfilesKHR<'_> {}
unsafe impl ExtendsBufferCreateInfo for VideoProfilesKHR<'_> {}
impl<'a> VideoProfilesKHR<'a> {
    #[inline]
    pub fn profiles(mut self, profiles: &'a [VideoProfileKHR]) -> Self {
        self.profile_count = profiles.len() as _;
        self.p_profiles = profiles.as_ptr();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVideoFormatInfoKHR.html>"]
pub struct PhysicalDeviceVideoFormatInfoKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub image_usage: ImageUsageFlags,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceVideoFormatInfoKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            image_usage: ImageUsageFlags::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceVideoFormatInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_VIDEO_FORMAT_INFO_KHR;
}
pub unsafe trait ExtendsPhysicalDeviceVideoFormatInfoKHR {}
impl<'a> PhysicalDeviceVideoFormatInfoKHR<'a> {
    #[inline]
    pub fn image_usage(mut self, image_usage: ImageUsageFlags) -> Self {
        self.image_usage = image_usage;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `x.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsPhysicalDeviceVideoFormatInfoKHR>(
        mut self,
        next: &'a mut T,
    ) -> Self {
        unsafe {
            let next_ptr = <*mut T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.p_next as _;
            self.p_next = next_ptr;
        }
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoFormatPropertiesKHR.html>"]
pub struct VideoFormatPropertiesKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub format: Format,
    pub component_mapping: ComponentMapping,
    pub image_create_flags: ImageCreateFlags,
    pub image_type: ImageType,
    pub image_tiling: ImageTiling,
    pub image_usage_flags: ImageUsageFlags,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for VideoFormatPropertiesKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            format: Format::default(),
            component_mapping: ComponentMapping::default(),
            image_create_flags: ImageCreateFlags::default(),
            image_type: ImageType::default(),
            image_tiling: ImageTiling::default(),
            image_usage_flags: ImageUsageFlags::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for VideoFormatPropertiesKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::VIDEO_FORMAT_PROPERTIES_KHR;
}
impl<'a> VideoFormatPropertiesKHR<'a> {
    #[inline]
    pub fn format(mut self, format: Format) -> Self {
        self.format = format;
        self
    }
    #[inline]
    pub fn component_mapping(mut self, component_mapping: ComponentMapping) -> Self {
        self.component_mapping = component_mapping;
        self
    }
    #[inline]
    pub fn image_create_flags(mut self, image_create_flags: ImageCreateFlags) -> Self {
        self.image_create_flags = image_create_flags;
        self
    }
    #[inline]
    pub fn image_type(mut self, image_type: ImageType) -> Self {
        self.image_type = image_type;
        self
    }
    #[inline]
    pub fn image_tiling(mut self, image_tiling: ImageTiling) -> Self {
        self.image_tiling = image_tiling;
        self
    }
    #[inline]
    pub fn image_usage_flags(mut self, image_usage_flags: ImageUsageFlags) -> Self {
        self.image_usage_flags = image_usage_flags;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoProfileKHR.html>"]
pub struct VideoProfileKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub video_codec_operation: VideoCodecOperationFlagsKHR,
    pub chroma_subsampling: VideoChromaSubsamplingFlagsKHR,
    pub luma_bit_depth: VideoComponentBitDepthFlagsKHR,
    pub chroma_bit_depth: VideoComponentBitDepthFlagsKHR,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for VideoProfileKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            video_codec_operation: VideoCodecOperationFlagsKHR::default(),
            chroma_subsampling: VideoChromaSubsamplingFlagsKHR::default(),
            luma_bit_depth: VideoComponentBitDepthFlagsKHR::default(),
            chroma_bit_depth: VideoComponentBitDepthFlagsKHR::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for VideoProfileKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::VIDEO_PROFILE_KHR;
}
unsafe impl ExtendsQueryPoolCreateInfo for VideoProfileKHR<'_> {}
pub unsafe trait ExtendsVideoProfileKHR {}
impl<'a> VideoProfileKHR<'a> {
    #[inline]
    pub fn video_codec_operation(
        mut self,
        video_codec_operation: VideoCodecOperationFlagsKHR,
    ) -> Self {
        self.video_codec_operation = video_codec_operation;
        self
    }
    #[inline]
    pub fn chroma_subsampling(
        mut self,
        chroma_subsampling: VideoChromaSubsamplingFlagsKHR,
    ) -> Self {
        self.chroma_subsampling = chroma_subsampling;
        self
    }
    #[inline]
    pub fn luma_bit_depth(mut self, luma_bit_depth: VideoComponentBitDepthFlagsKHR) -> Self {
        self.luma_bit_depth = luma_bit_depth;
        self
    }
    #[inline]
    pub fn chroma_bit_depth(mut self, chroma_bit_depth: VideoComponentBitDepthFlagsKHR) -> Self {
        self.chroma_bit_depth = chroma_bit_depth;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `x.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsVideoProfileKHR>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.p_next as _;
            self.p_next = next_ptr;
        }
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoCapabilitiesKHR.html>"]
pub struct VideoCapabilitiesKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub capability_flags: VideoCapabilityFlagsKHR,
    pub min_bitstream_buffer_offset_alignment: DeviceSize,
    pub min_bitstream_buffer_size_alignment: DeviceSize,
    pub video_picture_extent_granularity: Extent2D,
    pub min_extent: Extent2D,
    pub max_extent: Extent2D,
    pub max_reference_pictures_slots_count: u32,
    pub max_reference_pictures_active_count: u32,
    pub std_header_version: ExtensionProperties,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for VideoCapabilitiesKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            capability_flags: VideoCapabilityFlagsKHR::default(),
            min_bitstream_buffer_offset_alignment: DeviceSize::default(),
            min_bitstream_buffer_size_alignment: DeviceSize::default(),
            video_picture_extent_granularity: Extent2D::default(),
            min_extent: Extent2D::default(),
            max_extent: Extent2D::default(),
            max_reference_pictures_slots_count: u32::default(),
            max_reference_pictures_active_count: u32::default(),
            std_header_version: ExtensionProperties::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for VideoCapabilitiesKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::VIDEO_CAPABILITIES_KHR;
}
pub unsafe trait ExtendsVideoCapabilitiesKHR {}
impl<'a> VideoCapabilitiesKHR<'a> {
    #[inline]
    pub fn capability_flags(mut self, capability_flags: VideoCapabilityFlagsKHR) -> Self {
        self.capability_flags = capability_flags;
        self
    }
    #[inline]
    pub fn min_bitstream_buffer_offset_alignment(
        mut self,
        min_bitstream_buffer_offset_alignment: DeviceSize,
    ) -> Self {
        self.min_bitstream_buffer_offset_alignment = min_bitstream_buffer_offset_alignment;
        self
    }
    #[inline]
    pub fn min_bitstream_buffer_size_alignment(
        mut self,
        min_bitstream_buffer_size_alignment: DeviceSize,
    ) -> Self {
        self.min_bitstream_buffer_size_alignment = min_bitstream_buffer_size_alignment;
        self
    }
    #[inline]
    pub fn video_picture_extent_granularity(
        mut self,
        video_picture_extent_granularity: Extent2D,
    ) -> Self {
        self.video_picture_extent_granularity = video_picture_extent_granularity;
        self
    }
    #[inline]
    pub fn min_extent(mut self, min_extent: Extent2D) -> Self {
        self.min_extent = min_extent;
        self
    }
    #[inline]
    pub fn max_extent(mut self, max_extent: Extent2D) -> Self {
        self.max_extent = max_extent;
        self
    }
    #[inline]
    pub fn max_reference_pictures_slots_count(
        mut self,
        max_reference_pictures_slots_count: u32,
    ) -> Self {
        self.max_reference_pictures_slots_count = max_reference_pictures_slots_count;
        self
    }
    #[inline]
    pub fn max_reference_pictures_active_count(
        mut self,
        max_reference_pictures_active_count: u32,
    ) -> Self {
        self.max_reference_pictures_active_count = max_reference_pictures_active_count;
        self
    }
    #[inline]
    pub fn std_header_version(mut self, std_header_version: ExtensionProperties) -> Self {
        self.std_header_version = std_header_version;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `x.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsVideoCapabilitiesKHR>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*mut T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.p_next as _;
            self.p_next = next_ptr;
        }
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoGetMemoryPropertiesKHR.html>"]
pub struct VideoGetMemoryPropertiesKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub memory_bind_index: u32,
    pub p_memory_requirements: *mut MemoryRequirements2<'a>,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for VideoGetMemoryPropertiesKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            memory_bind_index: u32::default(),
            p_memory_requirements: ::std::ptr::null_mut(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for VideoGetMemoryPropertiesKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::VIDEO_GET_MEMORY_PROPERTIES_KHR;
}
impl<'a> VideoGetMemoryPropertiesKHR<'a> {
    #[inline]
    pub fn memory_bind_index(mut self, memory_bind_index: u32) -> Self {
        self.memory_bind_index = memory_bind_index;
        self
    }
    #[inline]
    pub fn memory_requirements(
        mut self,
        memory_requirements: &'a mut MemoryRequirements2<'a>,
    ) -> Self {
        self.p_memory_requirements = memory_requirements;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoBindMemoryKHR.html>"]
pub struct VideoBindMemoryKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub memory_bind_index: u32,
    pub memory: DeviceMemory,
    pub memory_offset: DeviceSize,
    pub memory_size: DeviceSize,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for VideoBindMemoryKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            memory_bind_index: u32::default(),
            memory: DeviceMemory::default(),
            memory_offset: DeviceSize::default(),
            memory_size: DeviceSize::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for VideoBindMemoryKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::VIDEO_BIND_MEMORY_KHR;
}
impl<'a> VideoBindMemoryKHR<'a> {
    #[inline]
    pub fn memory_bind_index(mut self, memory_bind_index: u32) -> Self {
        self.memory_bind_index = memory_bind_index;
        self
    }
    #[inline]
    pub fn memory(mut self, memory: DeviceMemory) -> Self {
        self.memory = memory;
        self
    }
    #[inline]
    pub fn memory_offset(mut self, memory_offset: DeviceSize) -> Self {
        self.memory_offset = memory_offset;
        self
    }
    #[inline]
    pub fn memory_size(mut self, memory_size: DeviceSize) -> Self {
        self.memory_size = memory_size;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoPictureResourceKHR.html>"]
pub struct VideoPictureResourceKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub coded_offset: Offset2D,
    pub coded_extent: Extent2D,
    pub base_array_layer: u32,
    pub image_view_binding: ImageView,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for VideoPictureResourceKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            coded_offset: Offset2D::default(),
            coded_extent: Extent2D::default(),
            base_array_layer: u32::default(),
            image_view_binding: ImageView::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for VideoPictureResourceKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::VIDEO_PICTURE_RESOURCE_KHR;
}
impl<'a> VideoPictureResourceKHR<'a> {
    #[inline]
    pub fn coded_offset(mut self, coded_offset: Offset2D) -> Self {
        self.coded_offset = coded_offset;
        self
    }
    #[inline]
    pub fn coded_extent(mut self, coded_extent: Extent2D) -> Self {
        self.coded_extent = coded_extent;
        self
    }
    #[inline]
    pub fn base_array_layer(mut self, base_array_layer: u32) -> Self {
        self.base_array_layer = base_array_layer;
        self
    }
    #[inline]
    pub fn image_view_binding(mut self, image_view_binding: ImageView) -> Self {
        self.image_view_binding = image_view_binding;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoReferenceSlotKHR.html>"]
pub struct VideoReferenceSlotKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub slot_index: i8,
    pub p_picture_resource: *const VideoPictureResourceKHR<'a>,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for VideoReferenceSlotKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            slot_index: i8::default(),
            p_picture_resource: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for VideoReferenceSlotKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::VIDEO_REFERENCE_SLOT_KHR;
}
pub unsafe trait ExtendsVideoReferenceSlotKHR {}
impl<'a> VideoReferenceSlotKHR<'a> {
    #[inline]
    pub fn slot_index(mut self, slot_index: i8) -> Self {
        self.slot_index = slot_index;
        self
    }
    #[inline]
    pub fn picture_resource(mut self, picture_resource: &'a VideoPictureResourceKHR<'a>) -> Self {
        self.p_picture_resource = picture_resource;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `x.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsVideoReferenceSlotKHR>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.p_next as _;
            self.p_next = next_ptr;
        }
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoDecodeCapabilitiesKHR.html>"]
pub struct VideoDecodeCapabilitiesKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub flags: VideoDecodeCapabilityFlagsKHR,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for VideoDecodeCapabilitiesKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            flags: VideoDecodeCapabilityFlagsKHR::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for VideoDecodeCapabilitiesKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::VIDEO_DECODE_CAPABILITIES_KHR;
}
unsafe impl ExtendsVideoCapabilitiesKHR for VideoDecodeCapabilitiesKHR<'_> {}
pub unsafe trait ExtendsVideoDecodeCapabilitiesKHR {}
impl<'a> VideoDecodeCapabilitiesKHR<'a> {
    #[inline]
    pub fn flags(mut self, flags: VideoDecodeCapabilityFlagsKHR) -> Self {
        self.flags = flags;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `x.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsVideoDecodeCapabilitiesKHR>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*mut T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.p_next as _;
            self.p_next = next_ptr;
        }
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoDecodeInfoKHR.html>"]
pub struct VideoDecodeInfoKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: VideoDecodeFlagsKHR,
    pub src_buffer: Buffer,
    pub src_buffer_offset: DeviceSize,
    pub src_buffer_range: DeviceSize,
    pub dst_picture_resource: VideoPictureResourceKHR<'a>,
    pub p_setup_reference_slot: *const VideoReferenceSlotKHR<'a>,
    pub reference_slot_count: u32,
    pub p_reference_slots: *const VideoReferenceSlotKHR<'a>,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for VideoDecodeInfoKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: VideoDecodeFlagsKHR::default(),
            src_buffer: Buffer::default(),
            src_buffer_offset: DeviceSize::default(),
            src_buffer_range: DeviceSize::default(),
            dst_picture_resource: VideoPictureResourceKHR::default(),
            p_setup_reference_slot: ::std::ptr::null(),
            reference_slot_count: u32::default(),
            p_reference_slots: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for VideoDecodeInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::VIDEO_DECODE_INFO_KHR;
}
pub unsafe trait ExtendsVideoDecodeInfoKHR {}
impl<'a> VideoDecodeInfoKHR<'a> {
    #[inline]
    pub fn flags(mut self, flags: VideoDecodeFlagsKHR) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn src_buffer(mut self, src_buffer: Buffer) -> Self {
        self.src_buffer = src_buffer;
        self
    }
    #[inline]
    pub fn src_buffer_offset(mut self, src_buffer_offset: DeviceSize) -> Self {
        self.src_buffer_offset = src_buffer_offset;
        self
    }
    #[inline]
    pub fn src_buffer_range(mut self, src_buffer_range: DeviceSize) -> Self {
        self.src_buffer_range = src_buffer_range;
        self
    }
    #[inline]
    pub fn dst_picture_resource(
        mut self,
        dst_picture_resource: VideoPictureResourceKHR<'a>,
    ) -> Self {
        self.dst_picture_resource = dst_picture_resource;
        self
    }
    #[inline]
    pub fn setup_reference_slot(
        mut self,
        setup_reference_slot: &'a VideoReferenceSlotKHR<'a>,
    ) -> Self {
        self.p_setup_reference_slot = setup_reference_slot;
        self
    }
    #[inline]
    pub fn reference_slots(mut self, reference_slots: &'a [VideoReferenceSlotKHR]) -> Self {
        self.reference_slot_count = reference_slots.len() as _;
        self.p_reference_slots = reference_slots.as_ptr();
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `x.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsVideoDecodeInfoKHR>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.p_next as _;
            self.p_next = next_ptr;
        }
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoDecodeH264ProfileEXT.html>"]
pub struct VideoDecodeH264ProfileEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub std_profile_idc: StdVideoH264ProfileIdc,
    pub picture_layout: VideoDecodeH264PictureLayoutFlagsEXT,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for VideoDecodeH264ProfileEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            std_profile_idc: StdVideoH264ProfileIdc::default(),
            picture_layout: VideoDecodeH264PictureLayoutFlagsEXT::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for VideoDecodeH264ProfileEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::VIDEO_DECODE_H264_PROFILE_EXT;
}
unsafe impl ExtendsVideoProfileKHR for VideoDecodeH264ProfileEXT<'_> {}
unsafe impl ExtendsQueryPoolCreateInfo for VideoDecodeH264ProfileEXT<'_> {}
impl<'a> VideoDecodeH264ProfileEXT<'a> {
    #[inline]
    pub fn std_profile_idc(mut self, std_profile_idc: StdVideoH264ProfileIdc) -> Self {
        self.std_profile_idc = std_profile_idc;
        self
    }
    #[inline]
    pub fn picture_layout(mut self, picture_layout: VideoDecodeH264PictureLayoutFlagsEXT) -> Self {
        self.picture_layout = picture_layout;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoDecodeH264CapabilitiesEXT.html>"]
pub struct VideoDecodeH264CapabilitiesEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub max_level: StdVideoH264Level,
    pub field_offset_granularity: Offset2D,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for VideoDecodeH264CapabilitiesEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            max_level: StdVideoH264Level::default(),
            field_offset_granularity: Offset2D::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for VideoDecodeH264CapabilitiesEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::VIDEO_DECODE_H264_CAPABILITIES_EXT;
}
unsafe impl ExtendsVideoDecodeCapabilitiesKHR for VideoDecodeH264CapabilitiesEXT<'_> {}
impl<'a> VideoDecodeH264CapabilitiesEXT<'a> {
    #[inline]
    pub fn max_level(mut self, max_level: StdVideoH264Level) -> Self {
        self.max_level = max_level;
        self
    }
    #[inline]
    pub fn field_offset_granularity(mut self, field_offset_granularity: Offset2D) -> Self {
        self.field_offset_granularity = field_offset_granularity;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoDecodeH264SessionParametersAddInfoEXT.html>"]
pub struct VideoDecodeH264SessionParametersAddInfoEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub sps_std_count: u32,
    pub p_sps_std: *const StdVideoH264SequenceParameterSet,
    pub pps_std_count: u32,
    pub p_pps_std: *const StdVideoH264PictureParameterSet,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for VideoDecodeH264SessionParametersAddInfoEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            sps_std_count: u32::default(),
            p_sps_std: ::std::ptr::null(),
            pps_std_count: u32::default(),
            p_pps_std: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for VideoDecodeH264SessionParametersAddInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::VIDEO_DECODE_H264_SESSION_PARAMETERS_ADD_INFO_EXT;
}
unsafe impl ExtendsVideoSessionParametersUpdateInfoKHR
    for VideoDecodeH264SessionParametersAddInfoEXT<'_>
{
}
impl<'a> VideoDecodeH264SessionParametersAddInfoEXT<'a> {
    #[inline]
    pub fn sps_std(mut self, sps_std: &'a [StdVideoH264SequenceParameterSet]) -> Self {
        self.sps_std_count = sps_std.len() as _;
        self.p_sps_std = sps_std.as_ptr();
        self
    }
    #[inline]
    pub fn pps_std(mut self, pps_std: &'a [StdVideoH264PictureParameterSet]) -> Self {
        self.pps_std_count = pps_std.len() as _;
        self.p_pps_std = pps_std.as_ptr();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoDecodeH264SessionParametersCreateInfoEXT.html>"]
pub struct VideoDecodeH264SessionParametersCreateInfoEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub max_sps_std_count: u32,
    pub max_pps_std_count: u32,
    pub p_parameters_add_info: *const VideoDecodeH264SessionParametersAddInfoEXT<'a>,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for VideoDecodeH264SessionParametersCreateInfoEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            max_sps_std_count: u32::default(),
            max_pps_std_count: u32::default(),
            p_parameters_add_info: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for VideoDecodeH264SessionParametersCreateInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::VIDEO_DECODE_H264_SESSION_PARAMETERS_CREATE_INFO_EXT;
}
unsafe impl ExtendsVideoSessionParametersCreateInfoKHR
    for VideoDecodeH264SessionParametersCreateInfoEXT<'_>
{
}
impl<'a> VideoDecodeH264SessionParametersCreateInfoEXT<'a> {
    #[inline]
    pub fn max_sps_std_count(mut self, max_sps_std_count: u32) -> Self {
        self.max_sps_std_count = max_sps_std_count;
        self
    }
    #[inline]
    pub fn max_pps_std_count(mut self, max_pps_std_count: u32) -> Self {
        self.max_pps_std_count = max_pps_std_count;
        self
    }
    #[inline]
    pub fn parameters_add_info(
        mut self,
        parameters_add_info: &'a VideoDecodeH264SessionParametersAddInfoEXT<'a>,
    ) -> Self {
        self.p_parameters_add_info = parameters_add_info;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoDecodeH264PictureInfoEXT.html>"]
pub struct VideoDecodeH264PictureInfoEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub p_std_picture_info: *const StdVideoDecodeH264PictureInfo,
    pub slices_count: u32,
    pub p_slices_data_offsets: *const u32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for VideoDecodeH264PictureInfoEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            p_std_picture_info: ::std::ptr::null(),
            slices_count: u32::default(),
            p_slices_data_offsets: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for VideoDecodeH264PictureInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::VIDEO_DECODE_H264_PICTURE_INFO_EXT;
}
unsafe impl ExtendsVideoDecodeInfoKHR for VideoDecodeH264PictureInfoEXT<'_> {}
pub unsafe trait ExtendsVideoDecodeH264PictureInfoEXT {}
impl<'a> VideoDecodeH264PictureInfoEXT<'a> {
    #[inline]
    pub fn std_picture_info(mut self, std_picture_info: &'a StdVideoDecodeH264PictureInfo) -> Self {
        self.p_std_picture_info = std_picture_info;
        self
    }
    #[inline]
    pub fn slices_data_offsets(mut self, slices_data_offsets: &'a [u32]) -> Self {
        self.slices_count = slices_data_offsets.len() as _;
        self.p_slices_data_offsets = slices_data_offsets.as_ptr();
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `x.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsVideoDecodeH264PictureInfoEXT>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.p_next as _;
            self.p_next = next_ptr;
        }
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoDecodeH264DpbSlotInfoEXT.html>"]
pub struct VideoDecodeH264DpbSlotInfoEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub p_std_reference_info: *const StdVideoDecodeH264ReferenceInfo,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for VideoDecodeH264DpbSlotInfoEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            p_std_reference_info: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for VideoDecodeH264DpbSlotInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::VIDEO_DECODE_H264_DPB_SLOT_INFO_EXT;
}
unsafe impl ExtendsVideoReferenceSlotKHR for VideoDecodeH264DpbSlotInfoEXT<'_> {}
impl<'a> VideoDecodeH264DpbSlotInfoEXT<'a> {
    #[inline]
    pub fn std_reference_info(
        mut self,
        std_reference_info: &'a StdVideoDecodeH264ReferenceInfo,
    ) -> Self {
        self.p_std_reference_info = std_reference_info;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoDecodeH264MvcEXT.html>"]
pub struct VideoDecodeH264MvcEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub p_std_mvc: *const StdVideoDecodeH264Mvc,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for VideoDecodeH264MvcEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            p_std_mvc: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for VideoDecodeH264MvcEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::VIDEO_DECODE_H264_MVC_EXT;
}
unsafe impl ExtendsVideoDecodeH264PictureInfoEXT for VideoDecodeH264MvcEXT<'_> {}
impl<'a> VideoDecodeH264MvcEXT<'a> {
    #[inline]
    pub fn std_mvc(mut self, std_mvc: &'a StdVideoDecodeH264Mvc) -> Self {
        self.p_std_mvc = std_mvc;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoDecodeH265ProfileEXT.html>"]
pub struct VideoDecodeH265ProfileEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub std_profile_idc: StdVideoH265ProfileIdc,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for VideoDecodeH265ProfileEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            std_profile_idc: StdVideoH265ProfileIdc::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for VideoDecodeH265ProfileEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::VIDEO_DECODE_H265_PROFILE_EXT;
}
unsafe impl ExtendsVideoProfileKHR for VideoDecodeH265ProfileEXT<'_> {}
unsafe impl ExtendsQueryPoolCreateInfo for VideoDecodeH265ProfileEXT<'_> {}
impl<'a> VideoDecodeH265ProfileEXT<'a> {
    #[inline]
    pub fn std_profile_idc(mut self, std_profile_idc: StdVideoH265ProfileIdc) -> Self {
        self.std_profile_idc = std_profile_idc;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoDecodeH265CapabilitiesEXT.html>"]
pub struct VideoDecodeH265CapabilitiesEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub max_level: StdVideoH265Level,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for VideoDecodeH265CapabilitiesEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            max_level: StdVideoH265Level::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for VideoDecodeH265CapabilitiesEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::VIDEO_DECODE_H265_CAPABILITIES_EXT;
}
unsafe impl ExtendsVideoDecodeCapabilitiesKHR for VideoDecodeH265CapabilitiesEXT<'_> {}
impl<'a> VideoDecodeH265CapabilitiesEXT<'a> {
    #[inline]
    pub fn max_level(mut self, max_level: StdVideoH265Level) -> Self {
        self.max_level = max_level;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoDecodeH265SessionParametersAddInfoEXT.html>"]
pub struct VideoDecodeH265SessionParametersAddInfoEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub vps_std_count: u32,
    pub p_vps_std: *const StdVideoH265VideoParameterSet,
    pub sps_std_count: u32,
    pub p_sps_std: *const StdVideoH265SequenceParameterSet,
    pub pps_std_count: u32,
    pub p_pps_std: *const StdVideoH265PictureParameterSet,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for VideoDecodeH265SessionParametersAddInfoEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            vps_std_count: u32::default(),
            p_vps_std: ::std::ptr::null(),
            sps_std_count: u32::default(),
            p_sps_std: ::std::ptr::null(),
            pps_std_count: u32::default(),
            p_pps_std: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for VideoDecodeH265SessionParametersAddInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::VIDEO_DECODE_H265_SESSION_PARAMETERS_ADD_INFO_EXT;
}
unsafe impl ExtendsVideoSessionParametersUpdateInfoKHR
    for VideoDecodeH265SessionParametersAddInfoEXT<'_>
{
}
impl<'a> VideoDecodeH265SessionParametersAddInfoEXT<'a> {
    #[inline]
    pub fn vps_std(mut self, vps_std: &'a [StdVideoH265VideoParameterSet]) -> Self {
        self.vps_std_count = vps_std.len() as _;
        self.p_vps_std = vps_std.as_ptr();
        self
    }
    #[inline]
    pub fn sps_std(mut self, sps_std: &'a [StdVideoH265SequenceParameterSet]) -> Self {
        self.sps_std_count = sps_std.len() as _;
        self.p_sps_std = sps_std.as_ptr();
        self
    }
    #[inline]
    pub fn pps_std(mut self, pps_std: &'a [StdVideoH265PictureParameterSet]) -> Self {
        self.pps_std_count = pps_std.len() as _;
        self.p_pps_std = pps_std.as_ptr();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoDecodeH265SessionParametersCreateInfoEXT.html>"]
pub struct VideoDecodeH265SessionParametersCreateInfoEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub max_vps_std_count: u32,
    pub max_sps_std_count: u32,
    pub max_pps_std_count: u32,
    pub p_parameters_add_info: *const VideoDecodeH265SessionParametersAddInfoEXT<'a>,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for VideoDecodeH265SessionParametersCreateInfoEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            max_vps_std_count: u32::default(),
            max_sps_std_count: u32::default(),
            max_pps_std_count: u32::default(),
            p_parameters_add_info: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for VideoDecodeH265SessionParametersCreateInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::VIDEO_DECODE_H265_SESSION_PARAMETERS_CREATE_INFO_EXT;
}
unsafe impl ExtendsVideoSessionParametersCreateInfoKHR
    for VideoDecodeH265SessionParametersCreateInfoEXT<'_>
{
}
impl<'a> VideoDecodeH265SessionParametersCreateInfoEXT<'a> {
    #[inline]
    pub fn max_vps_std_count(mut self, max_vps_std_count: u32) -> Self {
        self.max_vps_std_count = max_vps_std_count;
        self
    }
    #[inline]
    pub fn max_sps_std_count(mut self, max_sps_std_count: u32) -> Self {
        self.max_sps_std_count = max_sps_std_count;
        self
    }
    #[inline]
    pub fn max_pps_std_count(mut self, max_pps_std_count: u32) -> Self {
        self.max_pps_std_count = max_pps_std_count;
        self
    }
    #[inline]
    pub fn parameters_add_info(
        mut self,
        parameters_add_info: &'a VideoDecodeH265SessionParametersAddInfoEXT<'a>,
    ) -> Self {
        self.p_parameters_add_info = parameters_add_info;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoDecodeH265PictureInfoEXT.html>"]
pub struct VideoDecodeH265PictureInfoEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub p_std_picture_info: *mut StdVideoDecodeH265PictureInfo,
    pub slices_count: u32,
    pub p_slices_data_offsets: *const u32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for VideoDecodeH265PictureInfoEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            p_std_picture_info: ::std::ptr::null_mut(),
            slices_count: u32::default(),
            p_slices_data_offsets: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for VideoDecodeH265PictureInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::VIDEO_DECODE_H265_PICTURE_INFO_EXT;
}
unsafe impl ExtendsVideoDecodeInfoKHR for VideoDecodeH265PictureInfoEXT<'_> {}
impl<'a> VideoDecodeH265PictureInfoEXT<'a> {
    #[inline]
    pub fn std_picture_info(
        mut self,
        std_picture_info: &'a mut StdVideoDecodeH265PictureInfo,
    ) -> Self {
        self.p_std_picture_info = std_picture_info;
        self
    }
    #[inline]
    pub fn slices_data_offsets(mut self, slices_data_offsets: &'a [u32]) -> Self {
        self.slices_count = slices_data_offsets.len() as _;
        self.p_slices_data_offsets = slices_data_offsets.as_ptr();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoDecodeH265DpbSlotInfoEXT.html>"]
pub struct VideoDecodeH265DpbSlotInfoEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub p_std_reference_info: *const StdVideoDecodeH265ReferenceInfo,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for VideoDecodeH265DpbSlotInfoEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            p_std_reference_info: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for VideoDecodeH265DpbSlotInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::VIDEO_DECODE_H265_DPB_SLOT_INFO_EXT;
}
unsafe impl ExtendsVideoReferenceSlotKHR for VideoDecodeH265DpbSlotInfoEXT<'_> {}
impl<'a> VideoDecodeH265DpbSlotInfoEXT<'a> {
    #[inline]
    pub fn std_reference_info(
        mut self,
        std_reference_info: &'a StdVideoDecodeH265ReferenceInfo,
    ) -> Self {
        self.p_std_reference_info = std_reference_info;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoSessionCreateInfoKHR.html>"]
pub struct VideoSessionCreateInfoKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub queue_family_index: u32,
    pub flags: VideoSessionCreateFlagsKHR,
    pub p_video_profile: *const VideoProfileKHR<'a>,
    pub picture_format: Format,
    pub max_coded_extent: Extent2D,
    pub reference_pictures_format: Format,
    pub max_reference_pictures_slots_count: u32,
    pub max_reference_pictures_active_count: u32,
    pub p_std_header_version: *const ExtensionProperties,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for VideoSessionCreateInfoKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            queue_family_index: u32::default(),
            flags: VideoSessionCreateFlagsKHR::default(),
            p_video_profile: ::std::ptr::null(),
            picture_format: Format::default(),
            max_coded_extent: Extent2D::default(),
            reference_pictures_format: Format::default(),
            max_reference_pictures_slots_count: u32::default(),
            max_reference_pictures_active_count: u32::default(),
            p_std_header_version: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for VideoSessionCreateInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::VIDEO_SESSION_CREATE_INFO_KHR;
}
impl<'a> VideoSessionCreateInfoKHR<'a> {
    #[inline]
    pub fn queue_family_index(mut self, queue_family_index: u32) -> Self {
        self.queue_family_index = queue_family_index;
        self
    }
    #[inline]
    pub fn flags(mut self, flags: VideoSessionCreateFlagsKHR) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn video_profile(mut self, video_profile: &'a VideoProfileKHR<'a>) -> Self {
        self.p_video_profile = video_profile;
        self
    }
    #[inline]
    pub fn picture_format(mut self, picture_format: Format) -> Self {
        self.picture_format = picture_format;
        self
    }
    #[inline]
    pub fn max_coded_extent(mut self, max_coded_extent: Extent2D) -> Self {
        self.max_coded_extent = max_coded_extent;
        self
    }
    #[inline]
    pub fn reference_pictures_format(mut self, reference_pictures_format: Format) -> Self {
        self.reference_pictures_format = reference_pictures_format;
        self
    }
    #[inline]
    pub fn max_reference_pictures_slots_count(
        mut self,
        max_reference_pictures_slots_count: u32,
    ) -> Self {
        self.max_reference_pictures_slots_count = max_reference_pictures_slots_count;
        self
    }
    #[inline]
    pub fn max_reference_pictures_active_count(
        mut self,
        max_reference_pictures_active_count: u32,
    ) -> Self {
        self.max_reference_pictures_active_count = max_reference_pictures_active_count;
        self
    }
    #[inline]
    pub fn std_header_version(mut self, std_header_version: &'a ExtensionProperties) -> Self {
        self.p_std_header_version = std_header_version;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoSessionParametersCreateInfoKHR.html>"]
pub struct VideoSessionParametersCreateInfoKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub video_session_parameters_template: VideoSessionParametersKHR,
    pub video_session: VideoSessionKHR,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for VideoSessionParametersCreateInfoKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            video_session_parameters_template: VideoSessionParametersKHR::default(),
            video_session: VideoSessionKHR::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for VideoSessionParametersCreateInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::VIDEO_SESSION_PARAMETERS_CREATE_INFO_KHR;
}
pub unsafe trait ExtendsVideoSessionParametersCreateInfoKHR {}
impl<'a> VideoSessionParametersCreateInfoKHR<'a> {
    #[inline]
    pub fn video_session_parameters_template(
        mut self,
        video_session_parameters_template: VideoSessionParametersKHR,
    ) -> Self {
        self.video_session_parameters_template = video_session_parameters_template;
        self
    }
    #[inline]
    pub fn video_session(mut self, video_session: VideoSessionKHR) -> Self {
        self.video_session = video_session;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `x.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsVideoSessionParametersCreateInfoKHR>(
        mut self,
        next: &'a mut T,
    ) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.p_next as _;
            self.p_next = next_ptr;
        }
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoSessionParametersUpdateInfoKHR.html>"]
pub struct VideoSessionParametersUpdateInfoKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub update_sequence_count: u32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for VideoSessionParametersUpdateInfoKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            update_sequence_count: u32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for VideoSessionParametersUpdateInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::VIDEO_SESSION_PARAMETERS_UPDATE_INFO_KHR;
}
pub unsafe trait ExtendsVideoSessionParametersUpdateInfoKHR {}
impl<'a> VideoSessionParametersUpdateInfoKHR<'a> {
    #[inline]
    pub fn update_sequence_count(mut self, update_sequence_count: u32) -> Self {
        self.update_sequence_count = update_sequence_count;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `x.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsVideoSessionParametersUpdateInfoKHR>(
        mut self,
        next: &'a mut T,
    ) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.p_next as _;
            self.p_next = next_ptr;
        }
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoBeginCodingInfoKHR.html>"]
pub struct VideoBeginCodingInfoKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: VideoBeginCodingFlagsKHR,
    pub codec_quality_preset: VideoCodingQualityPresetFlagsKHR,
    pub video_session: VideoSessionKHR,
    pub video_session_parameters: VideoSessionParametersKHR,
    pub reference_slot_count: u32,
    pub p_reference_slots: *const VideoReferenceSlotKHR<'a>,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for VideoBeginCodingInfoKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: VideoBeginCodingFlagsKHR::default(),
            codec_quality_preset: VideoCodingQualityPresetFlagsKHR::default(),
            video_session: VideoSessionKHR::default(),
            video_session_parameters: VideoSessionParametersKHR::default(),
            reference_slot_count: u32::default(),
            p_reference_slots: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for VideoBeginCodingInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::VIDEO_BEGIN_CODING_INFO_KHR;
}
impl<'a> VideoBeginCodingInfoKHR<'a> {
    #[inline]
    pub fn flags(mut self, flags: VideoBeginCodingFlagsKHR) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn codec_quality_preset(
        mut self,
        codec_quality_preset: VideoCodingQualityPresetFlagsKHR,
    ) -> Self {
        self.codec_quality_preset = codec_quality_preset;
        self
    }
    #[inline]
    pub fn video_session(mut self, video_session: VideoSessionKHR) -> Self {
        self.video_session = video_session;
        self
    }
    #[inline]
    pub fn video_session_parameters(
        mut self,
        video_session_parameters: VideoSessionParametersKHR,
    ) -> Self {
        self.video_session_parameters = video_session_parameters;
        self
    }
    #[inline]
    pub fn reference_slots(mut self, reference_slots: &'a [VideoReferenceSlotKHR]) -> Self {
        self.reference_slot_count = reference_slots.len() as _;
        self.p_reference_slots = reference_slots.as_ptr();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoEndCodingInfoKHR.html>"]
pub struct VideoEndCodingInfoKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: VideoEndCodingFlagsKHR,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for VideoEndCodingInfoKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: VideoEndCodingFlagsKHR::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for VideoEndCodingInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::VIDEO_END_CODING_INFO_KHR;
}
impl<'a> VideoEndCodingInfoKHR<'a> {
    #[inline]
    pub fn flags(mut self, flags: VideoEndCodingFlagsKHR) -> Self {
        self.flags = flags;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoCodingControlInfoKHR.html>"]
pub struct VideoCodingControlInfoKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: VideoCodingControlFlagsKHR,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for VideoCodingControlInfoKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: VideoCodingControlFlagsKHR::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for VideoCodingControlInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::VIDEO_CODING_CONTROL_INFO_KHR;
}
pub unsafe trait ExtendsVideoCodingControlInfoKHR {}
impl<'a> VideoCodingControlInfoKHR<'a> {
    #[inline]
    pub fn flags(mut self, flags: VideoCodingControlFlagsKHR) -> Self {
        self.flags = flags;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `x.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsVideoCodingControlInfoKHR>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.p_next as _;
            self.p_next = next_ptr;
        }
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoEncodeInfoKHR.html>"]
pub struct VideoEncodeInfoKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: VideoEncodeFlagsKHR,
    pub quality_level: u32,
    pub dst_bitstream_buffer: Buffer,
    pub dst_bitstream_buffer_offset: DeviceSize,
    pub dst_bitstream_buffer_max_range: DeviceSize,
    pub src_picture_resource: VideoPictureResourceKHR<'a>,
    pub p_setup_reference_slot: *const VideoReferenceSlotKHR<'a>,
    pub reference_slot_count: u32,
    pub p_reference_slots: *const VideoReferenceSlotKHR<'a>,
    pub preceding_externally_encoded_bytes: u32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for VideoEncodeInfoKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: VideoEncodeFlagsKHR::default(),
            quality_level: u32::default(),
            dst_bitstream_buffer: Buffer::default(),
            dst_bitstream_buffer_offset: DeviceSize::default(),
            dst_bitstream_buffer_max_range: DeviceSize::default(),
            src_picture_resource: VideoPictureResourceKHR::default(),
            p_setup_reference_slot: ::std::ptr::null(),
            reference_slot_count: u32::default(),
            p_reference_slots: ::std::ptr::null(),
            preceding_externally_encoded_bytes: u32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for VideoEncodeInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::VIDEO_ENCODE_INFO_KHR;
}
pub unsafe trait ExtendsVideoEncodeInfoKHR {}
impl<'a> VideoEncodeInfoKHR<'a> {
    #[inline]
    pub fn flags(mut self, flags: VideoEncodeFlagsKHR) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn quality_level(mut self, quality_level: u32) -> Self {
        self.quality_level = quality_level;
        self
    }
    #[inline]
    pub fn dst_bitstream_buffer(mut self, dst_bitstream_buffer: Buffer) -> Self {
        self.dst_bitstream_buffer = dst_bitstream_buffer;
        self
    }
    #[inline]
    pub fn dst_bitstream_buffer_offset(mut self, dst_bitstream_buffer_offset: DeviceSize) -> Self {
        self.dst_bitstream_buffer_offset = dst_bitstream_buffer_offset;
        self
    }
    #[inline]
    pub fn dst_bitstream_buffer_max_range(
        mut self,
        dst_bitstream_buffer_max_range: DeviceSize,
    ) -> Self {
        self.dst_bitstream_buffer_max_range = dst_bitstream_buffer_max_range;
        self
    }
    #[inline]
    pub fn src_picture_resource(
        mut self,
        src_picture_resource: VideoPictureResourceKHR<'a>,
    ) -> Self {
        self.src_picture_resource = src_picture_resource;
        self
    }
    #[inline]
    pub fn setup_reference_slot(
        mut self,
        setup_reference_slot: &'a VideoReferenceSlotKHR<'a>,
    ) -> Self {
        self.p_setup_reference_slot = setup_reference_slot;
        self
    }
    #[inline]
    pub fn reference_slots(mut self, reference_slots: &'a [VideoReferenceSlotKHR]) -> Self {
        self.reference_slot_count = reference_slots.len() as _;
        self.p_reference_slots = reference_slots.as_ptr();
        self
    }
    #[inline]
    pub fn preceding_externally_encoded_bytes(
        mut self,
        preceding_externally_encoded_bytes: u32,
    ) -> Self {
        self.preceding_externally_encoded_bytes = preceding_externally_encoded_bytes;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `x.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsVideoEncodeInfoKHR>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.p_next as _;
            self.p_next = next_ptr;
        }
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoEncodeRateControlInfoKHR.html>"]
pub struct VideoEncodeRateControlInfoKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: VideoEncodeRateControlFlagsKHR,
    pub rate_control_mode: VideoEncodeRateControlModeFlagsKHR,
    pub layer_count: u8,
    pub p_layer_configs: *const VideoEncodeRateControlLayerInfoKHR<'a>,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for VideoEncodeRateControlInfoKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: VideoEncodeRateControlFlagsKHR::default(),
            rate_control_mode: VideoEncodeRateControlModeFlagsKHR::default(),
            layer_count: u8::default(),
            p_layer_configs: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for VideoEncodeRateControlInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::VIDEO_ENCODE_RATE_CONTROL_INFO_KHR;
}
unsafe impl ExtendsVideoCodingControlInfoKHR for VideoEncodeRateControlInfoKHR<'_> {}
pub unsafe trait ExtendsVideoEncodeRateControlInfoKHR {}
impl<'a> VideoEncodeRateControlInfoKHR<'a> {
    #[inline]
    pub fn flags(mut self, flags: VideoEncodeRateControlFlagsKHR) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn rate_control_mode(
        mut self,
        rate_control_mode: VideoEncodeRateControlModeFlagsKHR,
    ) -> Self {
        self.rate_control_mode = rate_control_mode;
        self
    }
    #[inline]
    pub fn layer_configs(
        mut self,
        layer_configs: &'a [VideoEncodeRateControlLayerInfoKHR],
    ) -> Self {
        self.layer_count = layer_configs.len() as _;
        self.p_layer_configs = layer_configs.as_ptr();
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `x.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsVideoEncodeRateControlInfoKHR>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.p_next as _;
            self.p_next = next_ptr;
        }
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoEncodeRateControlLayerInfoKHR.html>"]
pub struct VideoEncodeRateControlLayerInfoKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub average_bitrate: u32,
    pub max_bitrate: u32,
    pub frame_rate_numerator: u32,
    pub frame_rate_denominator: u32,
    pub virtual_buffer_size_in_ms: u32,
    pub initial_virtual_buffer_size_in_ms: u32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for VideoEncodeRateControlLayerInfoKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            average_bitrate: u32::default(),
            max_bitrate: u32::default(),
            frame_rate_numerator: u32::default(),
            frame_rate_denominator: u32::default(),
            virtual_buffer_size_in_ms: u32::default(),
            initial_virtual_buffer_size_in_ms: u32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for VideoEncodeRateControlLayerInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::VIDEO_ENCODE_RATE_CONTROL_LAYER_INFO_KHR;
}
unsafe impl ExtendsVideoCodingControlInfoKHR for VideoEncodeRateControlLayerInfoKHR<'_> {}
pub unsafe trait ExtendsVideoEncodeRateControlLayerInfoKHR {}
impl<'a> VideoEncodeRateControlLayerInfoKHR<'a> {
    #[inline]
    pub fn average_bitrate(mut self, average_bitrate: u32) -> Self {
        self.average_bitrate = average_bitrate;
        self
    }
    #[inline]
    pub fn max_bitrate(mut self, max_bitrate: u32) -> Self {
        self.max_bitrate = max_bitrate;
        self
    }
    #[inline]
    pub fn frame_rate_numerator(mut self, frame_rate_numerator: u32) -> Self {
        self.frame_rate_numerator = frame_rate_numerator;
        self
    }
    #[inline]
    pub fn frame_rate_denominator(mut self, frame_rate_denominator: u32) -> Self {
        self.frame_rate_denominator = frame_rate_denominator;
        self
    }
    #[inline]
    pub fn virtual_buffer_size_in_ms(mut self, virtual_buffer_size_in_ms: u32) -> Self {
        self.virtual_buffer_size_in_ms = virtual_buffer_size_in_ms;
        self
    }
    #[inline]
    pub fn initial_virtual_buffer_size_in_ms(
        mut self,
        initial_virtual_buffer_size_in_ms: u32,
    ) -> Self {
        self.initial_virtual_buffer_size_in_ms = initial_virtual_buffer_size_in_ms;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `x.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsVideoEncodeRateControlLayerInfoKHR>(
        mut self,
        next: &'a mut T,
    ) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.p_next as _;
            self.p_next = next_ptr;
        }
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoEncodeCapabilitiesKHR.html>"]
pub struct VideoEncodeCapabilitiesKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub flags: VideoEncodeCapabilityFlagsKHR,
    pub rate_control_modes: VideoEncodeRateControlModeFlagsKHR,
    pub rate_control_layer_count: u8,
    pub quality_level_count: u8,
    pub input_image_data_fill_alignment: Extent2D,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for VideoEncodeCapabilitiesKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            flags: VideoEncodeCapabilityFlagsKHR::default(),
            rate_control_modes: VideoEncodeRateControlModeFlagsKHR::default(),
            rate_control_layer_count: u8::default(),
            quality_level_count: u8::default(),
            input_image_data_fill_alignment: Extent2D::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for VideoEncodeCapabilitiesKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::VIDEO_ENCODE_CAPABILITIES_KHR;
}
unsafe impl ExtendsVideoCapabilitiesKHR for VideoEncodeCapabilitiesKHR<'_> {}
pub unsafe trait ExtendsVideoEncodeCapabilitiesKHR {}
impl<'a> VideoEncodeCapabilitiesKHR<'a> {
    #[inline]
    pub fn flags(mut self, flags: VideoEncodeCapabilityFlagsKHR) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn rate_control_modes(
        mut self,
        rate_control_modes: VideoEncodeRateControlModeFlagsKHR,
    ) -> Self {
        self.rate_control_modes = rate_control_modes;
        self
    }
    #[inline]
    pub fn rate_control_layer_count(mut self, rate_control_layer_count: u8) -> Self {
        self.rate_control_layer_count = rate_control_layer_count;
        self
    }
    #[inline]
    pub fn quality_level_count(mut self, quality_level_count: u8) -> Self {
        self.quality_level_count = quality_level_count;
        self
    }
    #[inline]
    pub fn input_image_data_fill_alignment(
        mut self,
        input_image_data_fill_alignment: Extent2D,
    ) -> Self {
        self.input_image_data_fill_alignment = input_image_data_fill_alignment;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `x.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsVideoEncodeCapabilitiesKHR>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*mut T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.p_next as _;
            self.p_next = next_ptr;
        }
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoEncodeH264CapabilitiesEXT.html>"]
pub struct VideoEncodeH264CapabilitiesEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub flags: VideoEncodeH264CapabilityFlagsEXT,
    pub input_mode_flags: VideoEncodeH264InputModeFlagsEXT,
    pub output_mode_flags: VideoEncodeH264OutputModeFlagsEXT,
    pub max_p_picture_l0_reference_count: u8,
    pub max_b_picture_l0_reference_count: u8,
    pub max_l1_reference_count: u8,
    pub motion_vectors_over_pic_boundaries_flag: Bool32,
    pub max_bytes_per_pic_denom: u32,
    pub max_bits_per_mb_denom: u32,
    pub log2_max_mv_length_horizontal: u32,
    pub log2_max_mv_length_vertical: u32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for VideoEncodeH264CapabilitiesEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            flags: VideoEncodeH264CapabilityFlagsEXT::default(),
            input_mode_flags: VideoEncodeH264InputModeFlagsEXT::default(),
            output_mode_flags: VideoEncodeH264OutputModeFlagsEXT::default(),
            max_p_picture_l0_reference_count: u8::default(),
            max_b_picture_l0_reference_count: u8::default(),
            max_l1_reference_count: u8::default(),
            motion_vectors_over_pic_boundaries_flag: Bool32::default(),
            max_bytes_per_pic_denom: u32::default(),
            max_bits_per_mb_denom: u32::default(),
            log2_max_mv_length_horizontal: u32::default(),
            log2_max_mv_length_vertical: u32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for VideoEncodeH264CapabilitiesEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::VIDEO_ENCODE_H264_CAPABILITIES_EXT;
}
unsafe impl ExtendsVideoEncodeCapabilitiesKHR for VideoEncodeH264CapabilitiesEXT<'_> {}
impl<'a> VideoEncodeH264CapabilitiesEXT<'a> {
    #[inline]
    pub fn flags(mut self, flags: VideoEncodeH264CapabilityFlagsEXT) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn input_mode_flags(mut self, input_mode_flags: VideoEncodeH264InputModeFlagsEXT) -> Self {
        self.input_mode_flags = input_mode_flags;
        self
    }
    #[inline]
    pub fn output_mode_flags(
        mut self,
        output_mode_flags: VideoEncodeH264OutputModeFlagsEXT,
    ) -> Self {
        self.output_mode_flags = output_mode_flags;
        self
    }
    #[inline]
    pub fn max_p_picture_l0_reference_count(
        mut self,
        max_p_picture_l0_reference_count: u8,
    ) -> Self {
        self.max_p_picture_l0_reference_count = max_p_picture_l0_reference_count;
        self
    }
    #[inline]
    pub fn max_b_picture_l0_reference_count(
        mut self,
        max_b_picture_l0_reference_count: u8,
    ) -> Self {
        self.max_b_picture_l0_reference_count = max_b_picture_l0_reference_count;
        self
    }
    #[inline]
    pub fn max_l1_reference_count(mut self, max_l1_reference_count: u8) -> Self {
        self.max_l1_reference_count = max_l1_reference_count;
        self
    }
    #[inline]
    pub fn motion_vectors_over_pic_boundaries_flag(
        mut self,
        motion_vectors_over_pic_boundaries_flag: bool,
    ) -> Self {
        self.motion_vectors_over_pic_boundaries_flag =
            motion_vectors_over_pic_boundaries_flag.into();
        self
    }
    #[inline]
    pub fn max_bytes_per_pic_denom(mut self, max_bytes_per_pic_denom: u32) -> Self {
        self.max_bytes_per_pic_denom = max_bytes_per_pic_denom;
        self
    }
    #[inline]
    pub fn max_bits_per_mb_denom(mut self, max_bits_per_mb_denom: u32) -> Self {
        self.max_bits_per_mb_denom = max_bits_per_mb_denom;
        self
    }
    #[inline]
    pub fn log2_max_mv_length_horizontal(mut self, log2_max_mv_length_horizontal: u32) -> Self {
        self.log2_max_mv_length_horizontal = log2_max_mv_length_horizontal;
        self
    }
    #[inline]
    pub fn log2_max_mv_length_vertical(mut self, log2_max_mv_length_vertical: u32) -> Self {
        self.log2_max_mv_length_vertical = log2_max_mv_length_vertical;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoEncodeH264SessionParametersAddInfoEXT.html>"]
pub struct VideoEncodeH264SessionParametersAddInfoEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub sps_std_count: u32,
    pub p_sps_std: *const StdVideoH264SequenceParameterSet,
    pub pps_std_count: u32,
    pub p_pps_std: *const StdVideoH264PictureParameterSet,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for VideoEncodeH264SessionParametersAddInfoEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            sps_std_count: u32::default(),
            p_sps_std: ::std::ptr::null(),
            pps_std_count: u32::default(),
            p_pps_std: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for VideoEncodeH264SessionParametersAddInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::VIDEO_ENCODE_H264_SESSION_PARAMETERS_ADD_INFO_EXT;
}
unsafe impl ExtendsVideoSessionParametersUpdateInfoKHR
    for VideoEncodeH264SessionParametersAddInfoEXT<'_>
{
}
impl<'a> VideoEncodeH264SessionParametersAddInfoEXT<'a> {
    #[inline]
    pub fn sps_std(mut self, sps_std: &'a [StdVideoH264SequenceParameterSet]) -> Self {
        self.sps_std_count = sps_std.len() as _;
        self.p_sps_std = sps_std.as_ptr();
        self
    }
    #[inline]
    pub fn pps_std(mut self, pps_std: &'a [StdVideoH264PictureParameterSet]) -> Self {
        self.pps_std_count = pps_std.len() as _;
        self.p_pps_std = pps_std.as_ptr();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoEncodeH264SessionParametersCreateInfoEXT.html>"]
pub struct VideoEncodeH264SessionParametersCreateInfoEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub max_sps_std_count: u32,
    pub max_pps_std_count: u32,
    pub p_parameters_add_info: *const VideoEncodeH264SessionParametersAddInfoEXT<'a>,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for VideoEncodeH264SessionParametersCreateInfoEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            max_sps_std_count: u32::default(),
            max_pps_std_count: u32::default(),
            p_parameters_add_info: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for VideoEncodeH264SessionParametersCreateInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::VIDEO_ENCODE_H264_SESSION_PARAMETERS_CREATE_INFO_EXT;
}
unsafe impl ExtendsVideoSessionParametersCreateInfoKHR
    for VideoEncodeH264SessionParametersCreateInfoEXT<'_>
{
}
impl<'a> VideoEncodeH264SessionParametersCreateInfoEXT<'a> {
    #[inline]
    pub fn max_sps_std_count(mut self, max_sps_std_count: u32) -> Self {
        self.max_sps_std_count = max_sps_std_count;
        self
    }
    #[inline]
    pub fn max_pps_std_count(mut self, max_pps_std_count: u32) -> Self {
        self.max_pps_std_count = max_pps_std_count;
        self
    }
    #[inline]
    pub fn parameters_add_info(
        mut self,
        parameters_add_info: &'a VideoEncodeH264SessionParametersAddInfoEXT<'a>,
    ) -> Self {
        self.p_parameters_add_info = parameters_add_info;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoEncodeH264DpbSlotInfoEXT.html>"]
pub struct VideoEncodeH264DpbSlotInfoEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub slot_index: i8,
    pub p_std_reference_info: *const StdVideoEncodeH264ReferenceInfo,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for VideoEncodeH264DpbSlotInfoEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            slot_index: i8::default(),
            p_std_reference_info: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for VideoEncodeH264DpbSlotInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::VIDEO_ENCODE_H264_DPB_SLOT_INFO_EXT;
}
impl<'a> VideoEncodeH264DpbSlotInfoEXT<'a> {
    #[inline]
    pub fn slot_index(mut self, slot_index: i8) -> Self {
        self.slot_index = slot_index;
        self
    }
    #[inline]
    pub fn std_reference_info(
        mut self,
        std_reference_info: &'a StdVideoEncodeH264ReferenceInfo,
    ) -> Self {
        self.p_std_reference_info = std_reference_info;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoEncodeH264VclFrameInfoEXT.html>"]
pub struct VideoEncodeH264VclFrameInfoEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub p_reference_final_lists: *const VideoEncodeH264ReferenceListsEXT<'a>,
    pub nalu_slice_entry_count: u32,
    pub p_nalu_slice_entries: *const VideoEncodeH264NaluSliceEXT<'a>,
    pub p_current_picture_info: *const StdVideoEncodeH264PictureInfo,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for VideoEncodeH264VclFrameInfoEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            p_reference_final_lists: ::std::ptr::null(),
            nalu_slice_entry_count: u32::default(),
            p_nalu_slice_entries: ::std::ptr::null(),
            p_current_picture_info: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for VideoEncodeH264VclFrameInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::VIDEO_ENCODE_H264_VCL_FRAME_INFO_EXT;
}
unsafe impl ExtendsVideoEncodeInfoKHR for VideoEncodeH264VclFrameInfoEXT<'_> {}
impl<'a> VideoEncodeH264VclFrameInfoEXT<'a> {
    #[inline]
    pub fn reference_final_lists(
        mut self,
        reference_final_lists: &'a VideoEncodeH264ReferenceListsEXT<'a>,
    ) -> Self {
        self.p_reference_final_lists = reference_final_lists;
        self
    }
    #[inline]
    pub fn nalu_slice_entries(
        mut self,
        nalu_slice_entries: &'a [VideoEncodeH264NaluSliceEXT],
    ) -> Self {
        self.nalu_slice_entry_count = nalu_slice_entries.len() as _;
        self.p_nalu_slice_entries = nalu_slice_entries.as_ptr();
        self
    }
    #[inline]
    pub fn current_picture_info(
        mut self,
        current_picture_info: &'a StdVideoEncodeH264PictureInfo,
    ) -> Self {
        self.p_current_picture_info = current_picture_info;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoEncodeH264ReferenceListsEXT.html>"]
pub struct VideoEncodeH264ReferenceListsEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub reference_list0_entry_count: u8,
    pub p_reference_list0_entries: *const VideoEncodeH264DpbSlotInfoEXT<'a>,
    pub reference_list1_entry_count: u8,
    pub p_reference_list1_entries: *const VideoEncodeH264DpbSlotInfoEXT<'a>,
    pub p_mem_mgmt_ctrl_operations: *const StdVideoEncodeH264RefMemMgmtCtrlOperations,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for VideoEncodeH264ReferenceListsEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            reference_list0_entry_count: u8::default(),
            p_reference_list0_entries: ::std::ptr::null(),
            reference_list1_entry_count: u8::default(),
            p_reference_list1_entries: ::std::ptr::null(),
            p_mem_mgmt_ctrl_operations: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for VideoEncodeH264ReferenceListsEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::VIDEO_ENCODE_H264_REFERENCE_LISTS_EXT;
}
impl<'a> VideoEncodeH264ReferenceListsEXT<'a> {
    #[inline]
    pub fn reference_list0_entries(
        mut self,
        reference_list0_entries: &'a [VideoEncodeH264DpbSlotInfoEXT],
    ) -> Self {
        self.reference_list0_entry_count = reference_list0_entries.len() as _;
        self.p_reference_list0_entries = reference_list0_entries.as_ptr();
        self
    }
    #[inline]
    pub fn reference_list1_entries(
        mut self,
        reference_list1_entries: &'a [VideoEncodeH264DpbSlotInfoEXT],
    ) -> Self {
        self.reference_list1_entry_count = reference_list1_entries.len() as _;
        self.p_reference_list1_entries = reference_list1_entries.as_ptr();
        self
    }
    #[inline]
    pub fn mem_mgmt_ctrl_operations(
        mut self,
        mem_mgmt_ctrl_operations: &'a StdVideoEncodeH264RefMemMgmtCtrlOperations,
    ) -> Self {
        self.p_mem_mgmt_ctrl_operations = mem_mgmt_ctrl_operations;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoEncodeH264EmitPictureParametersEXT.html>"]
pub struct VideoEncodeH264EmitPictureParametersEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub sps_id: u8,
    pub emit_sps_enable: Bool32,
    pub pps_id_entry_count: u32,
    pub pps_id_entries: *const u8,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for VideoEncodeH264EmitPictureParametersEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            sps_id: u8::default(),
            emit_sps_enable: Bool32::default(),
            pps_id_entry_count: u32::default(),
            pps_id_entries: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for VideoEncodeH264EmitPictureParametersEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::VIDEO_ENCODE_H264_EMIT_PICTURE_PARAMETERS_EXT;
}
unsafe impl ExtendsVideoEncodeInfoKHR for VideoEncodeH264EmitPictureParametersEXT<'_> {}
impl<'a> VideoEncodeH264EmitPictureParametersEXT<'a> {
    #[inline]
    pub fn sps_id(mut self, sps_id: u8) -> Self {
        self.sps_id = sps_id;
        self
    }
    #[inline]
    pub fn emit_sps_enable(mut self, emit_sps_enable: bool) -> Self {
        self.emit_sps_enable = emit_sps_enable.into();
        self
    }
    #[inline]
    pub fn pps_id_entries(mut self, pps_id_entries: &'a [u8]) -> Self {
        self.pps_id_entry_count = pps_id_entries.len() as _;
        self.pps_id_entries = pps_id_entries.as_ptr();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoEncodeH264ProfileEXT.html>"]
pub struct VideoEncodeH264ProfileEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub std_profile_idc: StdVideoH264ProfileIdc,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for VideoEncodeH264ProfileEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            std_profile_idc: StdVideoH264ProfileIdc::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for VideoEncodeH264ProfileEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::VIDEO_ENCODE_H264_PROFILE_EXT;
}
unsafe impl ExtendsVideoProfileKHR for VideoEncodeH264ProfileEXT<'_> {}
unsafe impl ExtendsQueryPoolCreateInfo for VideoEncodeH264ProfileEXT<'_> {}
impl<'a> VideoEncodeH264ProfileEXT<'a> {
    #[inline]
    pub fn std_profile_idc(mut self, std_profile_idc: StdVideoH264ProfileIdc) -> Self {
        self.std_profile_idc = std_profile_idc;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoEncodeH264NaluSliceEXT.html>"]
pub struct VideoEncodeH264NaluSliceEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub mb_count: u32,
    pub p_reference_final_lists: *const VideoEncodeH264ReferenceListsEXT<'a>,
    pub p_slice_header_std: *const StdVideoEncodeH264SliceHeader,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for VideoEncodeH264NaluSliceEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            mb_count: u32::default(),
            p_reference_final_lists: ::std::ptr::null(),
            p_slice_header_std: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for VideoEncodeH264NaluSliceEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::VIDEO_ENCODE_H264_NALU_SLICE_EXT;
}
impl<'a> VideoEncodeH264NaluSliceEXT<'a> {
    #[inline]
    pub fn mb_count(mut self, mb_count: u32) -> Self {
        self.mb_count = mb_count;
        self
    }
    #[inline]
    pub fn reference_final_lists(
        mut self,
        reference_final_lists: &'a VideoEncodeH264ReferenceListsEXT<'a>,
    ) -> Self {
        self.p_reference_final_lists = reference_final_lists;
        self
    }
    #[inline]
    pub fn slice_header_std(mut self, slice_header_std: &'a StdVideoEncodeH264SliceHeader) -> Self {
        self.p_slice_header_std = slice_header_std;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoEncodeH264RateControlInfoEXT.html>"]
pub struct VideoEncodeH264RateControlInfoEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub gop_frame_count: u32,
    pub idr_period: u32,
    pub consecutive_b_frame_count: u32,
    pub rate_control_structure: VideoEncodeH264RateControlStructureFlagsEXT,
    pub temporal_layer_count: u8,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for VideoEncodeH264RateControlInfoEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            gop_frame_count: u32::default(),
            idr_period: u32::default(),
            consecutive_b_frame_count: u32::default(),
            rate_control_structure: VideoEncodeH264RateControlStructureFlagsEXT::default(),
            temporal_layer_count: u8::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for VideoEncodeH264RateControlInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::VIDEO_ENCODE_H264_RATE_CONTROL_INFO_EXT;
}
unsafe impl ExtendsVideoEncodeRateControlInfoKHR for VideoEncodeH264RateControlInfoEXT<'_> {}
impl<'a> VideoEncodeH264RateControlInfoEXT<'a> {
    #[inline]
    pub fn gop_frame_count(mut self, gop_frame_count: u32) -> Self {
        self.gop_frame_count = gop_frame_count;
        self
    }
    #[inline]
    pub fn idr_period(mut self, idr_period: u32) -> Self {
        self.idr_period = idr_period;
        self
    }
    #[inline]
    pub fn consecutive_b_frame_count(mut self, consecutive_b_frame_count: u32) -> Self {
        self.consecutive_b_frame_count = consecutive_b_frame_count;
        self
    }
    #[inline]
    pub fn rate_control_structure(
        mut self,
        rate_control_structure: VideoEncodeH264RateControlStructureFlagsEXT,
    ) -> Self {
        self.rate_control_structure = rate_control_structure;
        self
    }
    #[inline]
    pub fn temporal_layer_count(mut self, temporal_layer_count: u8) -> Self {
        self.temporal_layer_count = temporal_layer_count;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoEncodeH264QpEXT.html>"]
pub struct VideoEncodeH264QpEXT {
    pub qp_i: i32,
    pub qp_p: i32,
    pub qp_b: i32,
}
impl VideoEncodeH264QpEXT {
    #[inline]
    pub fn qp_i(mut self, qp_i: i32) -> Self {
        self.qp_i = qp_i;
        self
    }
    #[inline]
    pub fn qp_p(mut self, qp_p: i32) -> Self {
        self.qp_p = qp_p;
        self
    }
    #[inline]
    pub fn qp_b(mut self, qp_b: i32) -> Self {
        self.qp_b = qp_b;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoEncodeH264FrameSizeEXT.html>"]
pub struct VideoEncodeH264FrameSizeEXT {
    pub frame_i_size: u32,
    pub frame_p_size: u32,
    pub frame_b_size: u32,
}
impl VideoEncodeH264FrameSizeEXT {
    #[inline]
    pub fn frame_i_size(mut self, frame_i_size: u32) -> Self {
        self.frame_i_size = frame_i_size;
        self
    }
    #[inline]
    pub fn frame_p_size(mut self, frame_p_size: u32) -> Self {
        self.frame_p_size = frame_p_size;
        self
    }
    #[inline]
    pub fn frame_b_size(mut self, frame_b_size: u32) -> Self {
        self.frame_b_size = frame_b_size;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoEncodeH264RateControlLayerInfoEXT.html>"]
pub struct VideoEncodeH264RateControlLayerInfoEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub temporal_layer_id: u8,
    pub use_initial_rc_qp: Bool32,
    pub initial_rc_qp: VideoEncodeH264QpEXT,
    pub use_min_qp: Bool32,
    pub min_qp: VideoEncodeH264QpEXT,
    pub use_max_qp: Bool32,
    pub max_qp: VideoEncodeH264QpEXT,
    pub use_max_frame_size: Bool32,
    pub max_frame_size: VideoEncodeH264FrameSizeEXT,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for VideoEncodeH264RateControlLayerInfoEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            temporal_layer_id: u8::default(),
            use_initial_rc_qp: Bool32::default(),
            initial_rc_qp: VideoEncodeH264QpEXT::default(),
            use_min_qp: Bool32::default(),
            min_qp: VideoEncodeH264QpEXT::default(),
            use_max_qp: Bool32::default(),
            max_qp: VideoEncodeH264QpEXT::default(),
            use_max_frame_size: Bool32::default(),
            max_frame_size: VideoEncodeH264FrameSizeEXT::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for VideoEncodeH264RateControlLayerInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::VIDEO_ENCODE_H264_RATE_CONTROL_LAYER_INFO_EXT;
}
unsafe impl ExtendsVideoEncodeRateControlLayerInfoKHR
    for VideoEncodeH264RateControlLayerInfoEXT<'_>
{
}
impl<'a> VideoEncodeH264RateControlLayerInfoEXT<'a> {
    #[inline]
    pub fn temporal_layer_id(mut self, temporal_layer_id: u8) -> Self {
        self.temporal_layer_id = temporal_layer_id;
        self
    }
    #[inline]
    pub fn use_initial_rc_qp(mut self, use_initial_rc_qp: bool) -> Self {
        self.use_initial_rc_qp = use_initial_rc_qp.into();
        self
    }
    #[inline]
    pub fn initial_rc_qp(mut self, initial_rc_qp: VideoEncodeH264QpEXT) -> Self {
        self.initial_rc_qp = initial_rc_qp;
        self
    }
    #[inline]
    pub fn use_min_qp(mut self, use_min_qp: bool) -> Self {
        self.use_min_qp = use_min_qp.into();
        self
    }
    #[inline]
    pub fn min_qp(mut self, min_qp: VideoEncodeH264QpEXT) -> Self {
        self.min_qp = min_qp;
        self
    }
    #[inline]
    pub fn use_max_qp(mut self, use_max_qp: bool) -> Self {
        self.use_max_qp = use_max_qp.into();
        self
    }
    #[inline]
    pub fn max_qp(mut self, max_qp: VideoEncodeH264QpEXT) -> Self {
        self.max_qp = max_qp;
        self
    }
    #[inline]
    pub fn use_max_frame_size(mut self, use_max_frame_size: bool) -> Self {
        self.use_max_frame_size = use_max_frame_size.into();
        self
    }
    #[inline]
    pub fn max_frame_size(mut self, max_frame_size: VideoEncodeH264FrameSizeEXT) -> Self {
        self.max_frame_size = max_frame_size;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoEncodeH265CapabilitiesEXT.html>"]
pub struct VideoEncodeH265CapabilitiesEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub flags: VideoEncodeH265CapabilityFlagsEXT,
    pub input_mode_flags: VideoEncodeH265InputModeFlagsEXT,
    pub output_mode_flags: VideoEncodeH265OutputModeFlagsEXT,
    pub ctb_sizes: VideoEncodeH265CtbSizeFlagsEXT,
    pub transform_block_sizes: VideoEncodeH265TransformBlockSizeFlagsEXT,
    pub max_p_picture_l0_reference_count: u8,
    pub max_b_picture_l0_reference_count: u8,
    pub max_l1_reference_count: u8,
    pub max_sub_layers_count: u8,
    pub min_log2_min_luma_coding_block_size_minus3: u8,
    pub max_log2_min_luma_coding_block_size_minus3: u8,
    pub min_log2_min_luma_transform_block_size_minus2: u8,
    pub max_log2_min_luma_transform_block_size_minus2: u8,
    pub min_max_transform_hierarchy_depth_inter: u8,
    pub max_max_transform_hierarchy_depth_inter: u8,
    pub min_max_transform_hierarchy_depth_intra: u8,
    pub max_max_transform_hierarchy_depth_intra: u8,
    pub max_diff_cu_qp_delta_depth: u8,
    pub min_max_num_merge_cand: u8,
    pub max_max_num_merge_cand: u8,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for VideoEncodeH265CapabilitiesEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            flags: VideoEncodeH265CapabilityFlagsEXT::default(),
            input_mode_flags: VideoEncodeH265InputModeFlagsEXT::default(),
            output_mode_flags: VideoEncodeH265OutputModeFlagsEXT::default(),
            ctb_sizes: VideoEncodeH265CtbSizeFlagsEXT::default(),
            transform_block_sizes: VideoEncodeH265TransformBlockSizeFlagsEXT::default(),
            max_p_picture_l0_reference_count: u8::default(),
            max_b_picture_l0_reference_count: u8::default(),
            max_l1_reference_count: u8::default(),
            max_sub_layers_count: u8::default(),
            min_log2_min_luma_coding_block_size_minus3: u8::default(),
            max_log2_min_luma_coding_block_size_minus3: u8::default(),
            min_log2_min_luma_transform_block_size_minus2: u8::default(),
            max_log2_min_luma_transform_block_size_minus2: u8::default(),
            min_max_transform_hierarchy_depth_inter: u8::default(),
            max_max_transform_hierarchy_depth_inter: u8::default(),
            min_max_transform_hierarchy_depth_intra: u8::default(),
            max_max_transform_hierarchy_depth_intra: u8::default(),
            max_diff_cu_qp_delta_depth: u8::default(),
            min_max_num_merge_cand: u8::default(),
            max_max_num_merge_cand: u8::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for VideoEncodeH265CapabilitiesEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::VIDEO_ENCODE_H265_CAPABILITIES_EXT;
}
unsafe impl ExtendsVideoEncodeCapabilitiesKHR for VideoEncodeH265CapabilitiesEXT<'_> {}
impl<'a> VideoEncodeH265CapabilitiesEXT<'a> {
    #[inline]
    pub fn flags(mut self, flags: VideoEncodeH265CapabilityFlagsEXT) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn input_mode_flags(mut self, input_mode_flags: VideoEncodeH265InputModeFlagsEXT) -> Self {
        self.input_mode_flags = input_mode_flags;
        self
    }
    #[inline]
    pub fn output_mode_flags(
        mut self,
        output_mode_flags: VideoEncodeH265OutputModeFlagsEXT,
    ) -> Self {
        self.output_mode_flags = output_mode_flags;
        self
    }
    #[inline]
    pub fn ctb_sizes(mut self, ctb_sizes: VideoEncodeH265CtbSizeFlagsEXT) -> Self {
        self.ctb_sizes = ctb_sizes;
        self
    }
    #[inline]
    pub fn transform_block_sizes(
        mut self,
        transform_block_sizes: VideoEncodeH265TransformBlockSizeFlagsEXT,
    ) -> Self {
        self.transform_block_sizes = transform_block_sizes;
        self
    }
    #[inline]
    pub fn max_p_picture_l0_reference_count(
        mut self,
        max_p_picture_l0_reference_count: u8,
    ) -> Self {
        self.max_p_picture_l0_reference_count = max_p_picture_l0_reference_count;
        self
    }
    #[inline]
    pub fn max_b_picture_l0_reference_count(
        mut self,
        max_b_picture_l0_reference_count: u8,
    ) -> Self {
        self.max_b_picture_l0_reference_count = max_b_picture_l0_reference_count;
        self
    }
    #[inline]
    pub fn max_l1_reference_count(mut self, max_l1_reference_count: u8) -> Self {
        self.max_l1_reference_count = max_l1_reference_count;
        self
    }
    #[inline]
    pub fn max_sub_layers_count(mut self, max_sub_layers_count: u8) -> Self {
        self.max_sub_layers_count = max_sub_layers_count;
        self
    }
    #[inline]
    pub fn min_log2_min_luma_coding_block_size_minus3(
        mut self,
        min_log2_min_luma_coding_block_size_minus3: u8,
    ) -> Self {
        self.min_log2_min_luma_coding_block_size_minus3 =
            min_log2_min_luma_coding_block_size_minus3;
        self
    }
    #[inline]
    pub fn max_log2_min_luma_coding_block_size_minus3(
        mut self,
        max_log2_min_luma_coding_block_size_minus3: u8,
    ) -> Self {
        self.max_log2_min_luma_coding_block_size_minus3 =
            max_log2_min_luma_coding_block_size_minus3;
        self
    }
    #[inline]
    pub fn min_log2_min_luma_transform_block_size_minus2(
        mut self,
        min_log2_min_luma_transform_block_size_minus2: u8,
    ) -> Self {
        self.min_log2_min_luma_transform_block_size_minus2 =
            min_log2_min_luma_transform_block_size_minus2;
        self
    }
    #[inline]
    pub fn max_log2_min_luma_transform_block_size_minus2(
        mut self,
        max_log2_min_luma_transform_block_size_minus2: u8,
    ) -> Self {
        self.max_log2_min_luma_transform_block_size_minus2 =
            max_log2_min_luma_transform_block_size_minus2;
        self
    }
    #[inline]
    pub fn min_max_transform_hierarchy_depth_inter(
        mut self,
        min_max_transform_hierarchy_depth_inter: u8,
    ) -> Self {
        self.min_max_transform_hierarchy_depth_inter = min_max_transform_hierarchy_depth_inter;
        self
    }
    #[inline]
    pub fn max_max_transform_hierarchy_depth_inter(
        mut self,
        max_max_transform_hierarchy_depth_inter: u8,
    ) -> Self {
        self.max_max_transform_hierarchy_depth_inter = max_max_transform_hierarchy_depth_inter;
        self
    }
    #[inline]
    pub fn min_max_transform_hierarchy_depth_intra(
        mut self,
        min_max_transform_hierarchy_depth_intra: u8,
    ) -> Self {
        self.min_max_transform_hierarchy_depth_intra = min_max_transform_hierarchy_depth_intra;
        self
    }
    #[inline]
    pub fn max_max_transform_hierarchy_depth_intra(
        mut self,
        max_max_transform_hierarchy_depth_intra: u8,
    ) -> Self {
        self.max_max_transform_hierarchy_depth_intra = max_max_transform_hierarchy_depth_intra;
        self
    }
    #[inline]
    pub fn max_diff_cu_qp_delta_depth(mut self, max_diff_cu_qp_delta_depth: u8) -> Self {
        self.max_diff_cu_qp_delta_depth = max_diff_cu_qp_delta_depth;
        self
    }
    #[inline]
    pub fn min_max_num_merge_cand(mut self, min_max_num_merge_cand: u8) -> Self {
        self.min_max_num_merge_cand = min_max_num_merge_cand;
        self
    }
    #[inline]
    pub fn max_max_num_merge_cand(mut self, max_max_num_merge_cand: u8) -> Self {
        self.max_max_num_merge_cand = max_max_num_merge_cand;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoEncodeH265SessionParametersAddInfoEXT.html>"]
pub struct VideoEncodeH265SessionParametersAddInfoEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub vps_std_count: u32,
    pub p_vps_std: *const StdVideoH265VideoParameterSet,
    pub sps_std_count: u32,
    pub p_sps_std: *const StdVideoH265SequenceParameterSet,
    pub pps_std_count: u32,
    pub p_pps_std: *const StdVideoH265PictureParameterSet,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for VideoEncodeH265SessionParametersAddInfoEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            vps_std_count: u32::default(),
            p_vps_std: ::std::ptr::null(),
            sps_std_count: u32::default(),
            p_sps_std: ::std::ptr::null(),
            pps_std_count: u32::default(),
            p_pps_std: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for VideoEncodeH265SessionParametersAddInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::VIDEO_ENCODE_H265_SESSION_PARAMETERS_ADD_INFO_EXT;
}
unsafe impl ExtendsVideoSessionParametersUpdateInfoKHR
    for VideoEncodeH265SessionParametersAddInfoEXT<'_>
{
}
impl<'a> VideoEncodeH265SessionParametersAddInfoEXT<'a> {
    #[inline]
    pub fn vps_std(mut self, vps_std: &'a [StdVideoH265VideoParameterSet]) -> Self {
        self.vps_std_count = vps_std.len() as _;
        self.p_vps_std = vps_std.as_ptr();
        self
    }
    #[inline]
    pub fn sps_std(mut self, sps_std: &'a [StdVideoH265SequenceParameterSet]) -> Self {
        self.sps_std_count = sps_std.len() as _;
        self.p_sps_std = sps_std.as_ptr();
        self
    }
    #[inline]
    pub fn pps_std(mut self, pps_std: &'a [StdVideoH265PictureParameterSet]) -> Self {
        self.pps_std_count = pps_std.len() as _;
        self.p_pps_std = pps_std.as_ptr();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoEncodeH265SessionParametersCreateInfoEXT.html>"]
pub struct VideoEncodeH265SessionParametersCreateInfoEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub max_vps_std_count: u32,
    pub max_sps_std_count: u32,
    pub max_pps_std_count: u32,
    pub p_parameters_add_info: *const VideoEncodeH265SessionParametersAddInfoEXT<'a>,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for VideoEncodeH265SessionParametersCreateInfoEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            max_vps_std_count: u32::default(),
            max_sps_std_count: u32::default(),
            max_pps_std_count: u32::default(),
            p_parameters_add_info: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for VideoEncodeH265SessionParametersCreateInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::VIDEO_ENCODE_H265_SESSION_PARAMETERS_CREATE_INFO_EXT;
}
unsafe impl ExtendsVideoSessionParametersCreateInfoKHR
    for VideoEncodeH265SessionParametersCreateInfoEXT<'_>
{
}
impl<'a> VideoEncodeH265SessionParametersCreateInfoEXT<'a> {
    #[inline]
    pub fn max_vps_std_count(mut self, max_vps_std_count: u32) -> Self {
        self.max_vps_std_count = max_vps_std_count;
        self
    }
    #[inline]
    pub fn max_sps_std_count(mut self, max_sps_std_count: u32) -> Self {
        self.max_sps_std_count = max_sps_std_count;
        self
    }
    #[inline]
    pub fn max_pps_std_count(mut self, max_pps_std_count: u32) -> Self {
        self.max_pps_std_count = max_pps_std_count;
        self
    }
    #[inline]
    pub fn parameters_add_info(
        mut self,
        parameters_add_info: &'a VideoEncodeH265SessionParametersAddInfoEXT<'a>,
    ) -> Self {
        self.p_parameters_add_info = parameters_add_info;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoEncodeH265VclFrameInfoEXT.html>"]
pub struct VideoEncodeH265VclFrameInfoEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub p_reference_final_lists: *const VideoEncodeH265ReferenceListsEXT<'a>,
    pub nalu_slice_segment_entry_count: u32,
    pub p_nalu_slice_segment_entries: *const VideoEncodeH265NaluSliceSegmentEXT<'a>,
    pub p_current_picture_info: *const StdVideoEncodeH265PictureInfo,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for VideoEncodeH265VclFrameInfoEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            p_reference_final_lists: ::std::ptr::null(),
            nalu_slice_segment_entry_count: u32::default(),
            p_nalu_slice_segment_entries: ::std::ptr::null(),
            p_current_picture_info: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for VideoEncodeH265VclFrameInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::VIDEO_ENCODE_H265_VCL_FRAME_INFO_EXT;
}
unsafe impl ExtendsVideoEncodeInfoKHR for VideoEncodeH265VclFrameInfoEXT<'_> {}
impl<'a> VideoEncodeH265VclFrameInfoEXT<'a> {
    #[inline]
    pub fn reference_final_lists(
        mut self,
        reference_final_lists: &'a VideoEncodeH265ReferenceListsEXT<'a>,
    ) -> Self {
        self.p_reference_final_lists = reference_final_lists;
        self
    }
    #[inline]
    pub fn nalu_slice_segment_entries(
        mut self,
        nalu_slice_segment_entries: &'a [VideoEncodeH265NaluSliceSegmentEXT],
    ) -> Self {
        self.nalu_slice_segment_entry_count = nalu_slice_segment_entries.len() as _;
        self.p_nalu_slice_segment_entries = nalu_slice_segment_entries.as_ptr();
        self
    }
    #[inline]
    pub fn current_picture_info(
        mut self,
        current_picture_info: &'a StdVideoEncodeH265PictureInfo,
    ) -> Self {
        self.p_current_picture_info = current_picture_info;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoEncodeH265EmitPictureParametersEXT.html>"]
pub struct VideoEncodeH265EmitPictureParametersEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub vps_id: u8,
    pub sps_id: u8,
    pub emit_vps_enable: Bool32,
    pub emit_sps_enable: Bool32,
    pub pps_id_entry_count: u32,
    pub pps_id_entries: *const u8,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for VideoEncodeH265EmitPictureParametersEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            vps_id: u8::default(),
            sps_id: u8::default(),
            emit_vps_enable: Bool32::default(),
            emit_sps_enable: Bool32::default(),
            pps_id_entry_count: u32::default(),
            pps_id_entries: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for VideoEncodeH265EmitPictureParametersEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::VIDEO_ENCODE_H265_EMIT_PICTURE_PARAMETERS_EXT;
}
unsafe impl ExtendsVideoEncodeInfoKHR for VideoEncodeH265EmitPictureParametersEXT<'_> {}
impl<'a> VideoEncodeH265EmitPictureParametersEXT<'a> {
    #[inline]
    pub fn vps_id(mut self, vps_id: u8) -> Self {
        self.vps_id = vps_id;
        self
    }
    #[inline]
    pub fn sps_id(mut self, sps_id: u8) -> Self {
        self.sps_id = sps_id;
        self
    }
    #[inline]
    pub fn emit_vps_enable(mut self, emit_vps_enable: bool) -> Self {
        self.emit_vps_enable = emit_vps_enable.into();
        self
    }
    #[inline]
    pub fn emit_sps_enable(mut self, emit_sps_enable: bool) -> Self {
        self.emit_sps_enable = emit_sps_enable.into();
        self
    }
    #[inline]
    pub fn pps_id_entries(mut self, pps_id_entries: &'a [u8]) -> Self {
        self.pps_id_entry_count = pps_id_entries.len() as _;
        self.pps_id_entries = pps_id_entries.as_ptr();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoEncodeH265NaluSliceSegmentEXT.html>"]
pub struct VideoEncodeH265NaluSliceSegmentEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub ctb_count: u32,
    pub p_reference_final_lists: *const VideoEncodeH265ReferenceListsEXT<'a>,
    pub p_slice_segment_header_std: *const StdVideoEncodeH265SliceSegmentHeader,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for VideoEncodeH265NaluSliceSegmentEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            ctb_count: u32::default(),
            p_reference_final_lists: ::std::ptr::null(),
            p_slice_segment_header_std: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for VideoEncodeH265NaluSliceSegmentEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::VIDEO_ENCODE_H265_NALU_SLICE_SEGMENT_EXT;
}
impl<'a> VideoEncodeH265NaluSliceSegmentEXT<'a> {
    #[inline]
    pub fn ctb_count(mut self, ctb_count: u32) -> Self {
        self.ctb_count = ctb_count;
        self
    }
    #[inline]
    pub fn reference_final_lists(
        mut self,
        reference_final_lists: &'a VideoEncodeH265ReferenceListsEXT<'a>,
    ) -> Self {
        self.p_reference_final_lists = reference_final_lists;
        self
    }
    #[inline]
    pub fn slice_segment_header_std(
        mut self,
        slice_segment_header_std: &'a StdVideoEncodeH265SliceSegmentHeader,
    ) -> Self {
        self.p_slice_segment_header_std = slice_segment_header_std;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoEncodeH265RateControlInfoEXT.html>"]
pub struct VideoEncodeH265RateControlInfoEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub gop_frame_count: u32,
    pub idr_period: u32,
    pub consecutive_b_frame_count: u32,
    pub rate_control_structure: VideoEncodeH265RateControlStructureFlagsEXT,
    pub sub_layer_count: u8,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for VideoEncodeH265RateControlInfoEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            gop_frame_count: u32::default(),
            idr_period: u32::default(),
            consecutive_b_frame_count: u32::default(),
            rate_control_structure: VideoEncodeH265RateControlStructureFlagsEXT::default(),
            sub_layer_count: u8::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for VideoEncodeH265RateControlInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::VIDEO_ENCODE_H265_RATE_CONTROL_INFO_EXT;
}
unsafe impl ExtendsVideoEncodeRateControlInfoKHR for VideoEncodeH265RateControlInfoEXT<'_> {}
impl<'a> VideoEncodeH265RateControlInfoEXT<'a> {
    #[inline]
    pub fn gop_frame_count(mut self, gop_frame_count: u32) -> Self {
        self.gop_frame_count = gop_frame_count;
        self
    }
    #[inline]
    pub fn idr_period(mut self, idr_period: u32) -> Self {
        self.idr_period = idr_period;
        self
    }
    #[inline]
    pub fn consecutive_b_frame_count(mut self, consecutive_b_frame_count: u32) -> Self {
        self.consecutive_b_frame_count = consecutive_b_frame_count;
        self
    }
    #[inline]
    pub fn rate_control_structure(
        mut self,
        rate_control_structure: VideoEncodeH265RateControlStructureFlagsEXT,
    ) -> Self {
        self.rate_control_structure = rate_control_structure;
        self
    }
    #[inline]
    pub fn sub_layer_count(mut self, sub_layer_count: u8) -> Self {
        self.sub_layer_count = sub_layer_count;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoEncodeH265QpEXT.html>"]
pub struct VideoEncodeH265QpEXT {
    pub qp_i: i32,
    pub qp_p: i32,
    pub qp_b: i32,
}
impl VideoEncodeH265QpEXT {
    #[inline]
    pub fn qp_i(mut self, qp_i: i32) -> Self {
        self.qp_i = qp_i;
        self
    }
    #[inline]
    pub fn qp_p(mut self, qp_p: i32) -> Self {
        self.qp_p = qp_p;
        self
    }
    #[inline]
    pub fn qp_b(mut self, qp_b: i32) -> Self {
        self.qp_b = qp_b;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoEncodeH265FrameSizeEXT.html>"]
pub struct VideoEncodeH265FrameSizeEXT {
    pub frame_i_size: u32,
    pub frame_p_size: u32,
    pub frame_b_size: u32,
}
impl VideoEncodeH265FrameSizeEXT {
    #[inline]
    pub fn frame_i_size(mut self, frame_i_size: u32) -> Self {
        self.frame_i_size = frame_i_size;
        self
    }
    #[inline]
    pub fn frame_p_size(mut self, frame_p_size: u32) -> Self {
        self.frame_p_size = frame_p_size;
        self
    }
    #[inline]
    pub fn frame_b_size(mut self, frame_b_size: u32) -> Self {
        self.frame_b_size = frame_b_size;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoEncodeH265RateControlLayerInfoEXT.html>"]
pub struct VideoEncodeH265RateControlLayerInfoEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub temporal_id: u8,
    pub use_initial_rc_qp: Bool32,
    pub initial_rc_qp: VideoEncodeH265QpEXT,
    pub use_min_qp: Bool32,
    pub min_qp: VideoEncodeH265QpEXT,
    pub use_max_qp: Bool32,
    pub max_qp: VideoEncodeH265QpEXT,
    pub use_max_frame_size: Bool32,
    pub max_frame_size: VideoEncodeH265FrameSizeEXT,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for VideoEncodeH265RateControlLayerInfoEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            temporal_id: u8::default(),
            use_initial_rc_qp: Bool32::default(),
            initial_rc_qp: VideoEncodeH265QpEXT::default(),
            use_min_qp: Bool32::default(),
            min_qp: VideoEncodeH265QpEXT::default(),
            use_max_qp: Bool32::default(),
            max_qp: VideoEncodeH265QpEXT::default(),
            use_max_frame_size: Bool32::default(),
            max_frame_size: VideoEncodeH265FrameSizeEXT::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for VideoEncodeH265RateControlLayerInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::VIDEO_ENCODE_H265_RATE_CONTROL_LAYER_INFO_EXT;
}
unsafe impl ExtendsVideoEncodeRateControlLayerInfoKHR
    for VideoEncodeH265RateControlLayerInfoEXT<'_>
{
}
impl<'a> VideoEncodeH265RateControlLayerInfoEXT<'a> {
    #[inline]
    pub fn temporal_id(mut self, temporal_id: u8) -> Self {
        self.temporal_id = temporal_id;
        self
    }
    #[inline]
    pub fn use_initial_rc_qp(mut self, use_initial_rc_qp: bool) -> Self {
        self.use_initial_rc_qp = use_initial_rc_qp.into();
        self
    }
    #[inline]
    pub fn initial_rc_qp(mut self, initial_rc_qp: VideoEncodeH265QpEXT) -> Self {
        self.initial_rc_qp = initial_rc_qp;
        self
    }
    #[inline]
    pub fn use_min_qp(mut self, use_min_qp: bool) -> Self {
        self.use_min_qp = use_min_qp.into();
        self
    }
    #[inline]
    pub fn min_qp(mut self, min_qp: VideoEncodeH265QpEXT) -> Self {
        self.min_qp = min_qp;
        self
    }
    #[inline]
    pub fn use_max_qp(mut self, use_max_qp: bool) -> Self {
        self.use_max_qp = use_max_qp.into();
        self
    }
    #[inline]
    pub fn max_qp(mut self, max_qp: VideoEncodeH265QpEXT) -> Self {
        self.max_qp = max_qp;
        self
    }
    #[inline]
    pub fn use_max_frame_size(mut self, use_max_frame_size: bool) -> Self {
        self.use_max_frame_size = use_max_frame_size.into();
        self
    }
    #[inline]
    pub fn max_frame_size(mut self, max_frame_size: VideoEncodeH265FrameSizeEXT) -> Self {
        self.max_frame_size = max_frame_size;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoEncodeH265ProfileEXT.html>"]
pub struct VideoEncodeH265ProfileEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub std_profile_idc: StdVideoH265ProfileIdc,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for VideoEncodeH265ProfileEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            std_profile_idc: StdVideoH265ProfileIdc::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for VideoEncodeH265ProfileEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::VIDEO_ENCODE_H265_PROFILE_EXT;
}
unsafe impl ExtendsVideoProfileKHR for VideoEncodeH265ProfileEXT<'_> {}
unsafe impl ExtendsQueryPoolCreateInfo for VideoEncodeH265ProfileEXT<'_> {}
impl<'a> VideoEncodeH265ProfileEXT<'a> {
    #[inline]
    pub fn std_profile_idc(mut self, std_profile_idc: StdVideoH265ProfileIdc) -> Self {
        self.std_profile_idc = std_profile_idc;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoEncodeH265DpbSlotInfoEXT.html>"]
pub struct VideoEncodeH265DpbSlotInfoEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub slot_index: i8,
    pub p_std_reference_info: *const StdVideoEncodeH265ReferenceInfo,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for VideoEncodeH265DpbSlotInfoEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            slot_index: i8::default(),
            p_std_reference_info: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for VideoEncodeH265DpbSlotInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::VIDEO_ENCODE_H265_DPB_SLOT_INFO_EXT;
}
impl<'a> VideoEncodeH265DpbSlotInfoEXT<'a> {
    #[inline]
    pub fn slot_index(mut self, slot_index: i8) -> Self {
        self.slot_index = slot_index;
        self
    }
    #[inline]
    pub fn std_reference_info(
        mut self,
        std_reference_info: &'a StdVideoEncodeH265ReferenceInfo,
    ) -> Self {
        self.p_std_reference_info = std_reference_info;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoEncodeH265ReferenceListsEXT.html>"]
pub struct VideoEncodeH265ReferenceListsEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub reference_list0_entry_count: u8,
    pub p_reference_list0_entries: *const VideoEncodeH265DpbSlotInfoEXT<'a>,
    pub reference_list1_entry_count: u8,
    pub p_reference_list1_entries: *const VideoEncodeH265DpbSlotInfoEXT<'a>,
    pub p_reference_modifications: *const StdVideoEncodeH265ReferenceModifications,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for VideoEncodeH265ReferenceListsEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            reference_list0_entry_count: u8::default(),
            p_reference_list0_entries: ::std::ptr::null(),
            reference_list1_entry_count: u8::default(),
            p_reference_list1_entries: ::std::ptr::null(),
            p_reference_modifications: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for VideoEncodeH265ReferenceListsEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::VIDEO_ENCODE_H265_REFERENCE_LISTS_EXT;
}
impl<'a> VideoEncodeH265ReferenceListsEXT<'a> {
    #[inline]
    pub fn reference_list0_entries(
        mut self,
        reference_list0_entries: &'a [VideoEncodeH265DpbSlotInfoEXT],
    ) -> Self {
        self.reference_list0_entry_count = reference_list0_entries.len() as _;
        self.p_reference_list0_entries = reference_list0_entries.as_ptr();
        self
    }
    #[inline]
    pub fn reference_list1_entries(
        mut self,
        reference_list1_entries: &'a [VideoEncodeH265DpbSlotInfoEXT],
    ) -> Self {
        self.reference_list1_entry_count = reference_list1_entries.len() as _;
        self.p_reference_list1_entries = reference_list1_entries.as_ptr();
        self
    }
    #[inline]
    pub fn reference_modifications(
        mut self,
        reference_modifications: &'a StdVideoEncodeH265ReferenceModifications,
    ) -> Self {
        self.p_reference_modifications = reference_modifications;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceInheritedViewportScissorFeaturesNV.html>"]
pub struct PhysicalDeviceInheritedViewportScissorFeaturesNV<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub inherited_viewport_scissor2_d: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceInheritedViewportScissorFeaturesNV<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            inherited_viewport_scissor2_d: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceInheritedViewportScissorFeaturesNV<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV;
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceInheritedViewportScissorFeaturesNV<'_>
{
}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceInheritedViewportScissorFeaturesNV<'_> {}
impl<'a> PhysicalDeviceInheritedViewportScissorFeaturesNV<'a> {
    #[inline]
    pub fn inherited_viewport_scissor2_d(mut self, inherited_viewport_scissor2_d: bool) -> Self {
        self.inherited_viewport_scissor2_d = inherited_viewport_scissor2_d.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandBufferInheritanceViewportScissorInfoNV.html>"]
pub struct CommandBufferInheritanceViewportScissorInfoNV<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub viewport_scissor2_d: Bool32,
    pub viewport_depth_count: u32,
    pub p_viewport_depths: *const Viewport,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for CommandBufferInheritanceViewportScissorInfoNV<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            viewport_scissor2_d: Bool32::default(),
            viewport_depth_count: u32::default(),
            p_viewport_depths: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for CommandBufferInheritanceViewportScissorInfoNV<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV;
}
unsafe impl ExtendsCommandBufferInheritanceInfo
    for CommandBufferInheritanceViewportScissorInfoNV<'_>
{
}
impl<'a> CommandBufferInheritanceViewportScissorInfoNV<'a> {
    #[inline]
    pub fn viewport_scissor2_d(mut self, viewport_scissor2_d: bool) -> Self {
        self.viewport_scissor2_d = viewport_scissor2_d.into();
        self
    }
    #[inline]
    pub fn viewport_depth_count(mut self, viewport_depth_count: u32) -> Self {
        self.viewport_depth_count = viewport_depth_count;
        self
    }
    #[inline]
    pub fn viewport_depths(mut self, viewport_depths: &'a Viewport) -> Self {
        self.p_viewport_depths = viewport_depths;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT.html>"]
pub struct PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub ycbcr2plane444_formats: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            ycbcr2plane444_formats: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT;
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT<'_> {}
impl<'a> PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT<'a> {
    #[inline]
    pub fn ycbcr2plane444_formats(mut self, ycbcr2plane444_formats: bool) -> Self {
        self.ycbcr2plane444_formats = ycbcr2plane444_formats.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceProvokingVertexFeaturesEXT.html>"]
pub struct PhysicalDeviceProvokingVertexFeaturesEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub provoking_vertex_last: Bool32,
    pub transform_feedback_preserves_provoking_vertex: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceProvokingVertexFeaturesEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            provoking_vertex_last: Bool32::default(),
            transform_feedback_preserves_provoking_vertex: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceProvokingVertexFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT;
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceProvokingVertexFeaturesEXT<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceProvokingVertexFeaturesEXT<'_> {}
impl<'a> PhysicalDeviceProvokingVertexFeaturesEXT<'a> {
    #[inline]
    pub fn provoking_vertex_last(mut self, provoking_vertex_last: bool) -> Self {
        self.provoking_vertex_last = provoking_vertex_last.into();
        self
    }
    #[inline]
    pub fn transform_feedback_preserves_provoking_vertex(
        mut self,
        transform_feedback_preserves_provoking_vertex: bool,
    ) -> Self {
        self.transform_feedback_preserves_provoking_vertex =
            transform_feedback_preserves_provoking_vertex.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceProvokingVertexPropertiesEXT.html>"]
pub struct PhysicalDeviceProvokingVertexPropertiesEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub provoking_vertex_mode_per_pipeline: Bool32,
    pub transform_feedback_preserves_triangle_fan_provoking_vertex: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceProvokingVertexPropertiesEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            provoking_vertex_mode_per_pipeline: Bool32::default(),
            transform_feedback_preserves_triangle_fan_provoking_vertex: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceProvokingVertexPropertiesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT;
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceProvokingVertexPropertiesEXT<'_> {}
impl<'a> PhysicalDeviceProvokingVertexPropertiesEXT<'a> {
    #[inline]
    pub fn provoking_vertex_mode_per_pipeline(
        mut self,
        provoking_vertex_mode_per_pipeline: bool,
    ) -> Self {
        self.provoking_vertex_mode_per_pipeline = provoking_vertex_mode_per_pipeline.into();
        self
    }
    #[inline]
    pub fn transform_feedback_preserves_triangle_fan_provoking_vertex(
        mut self,
        transform_feedback_preserves_triangle_fan_provoking_vertex: bool,
    ) -> Self {
        self.transform_feedback_preserves_triangle_fan_provoking_vertex =
            transform_feedback_preserves_triangle_fan_provoking_vertex.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineRasterizationProvokingVertexStateCreateInfoEXT.html>"]
pub struct PipelineRasterizationProvokingVertexStateCreateInfoEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub provoking_vertex_mode: ProvokingVertexModeEXT,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PipelineRasterizationProvokingVertexStateCreateInfoEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            provoking_vertex_mode: ProvokingVertexModeEXT::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PipelineRasterizationProvokingVertexStateCreateInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT;
}
unsafe impl ExtendsPipelineRasterizationStateCreateInfo
    for PipelineRasterizationProvokingVertexStateCreateInfoEXT<'_>
{
}
impl<'a> PipelineRasterizationProvokingVertexStateCreateInfoEXT<'a> {
    #[inline]
    pub fn provoking_vertex_mode(mut self, provoking_vertex_mode: ProvokingVertexModeEXT) -> Self {
        self.provoking_vertex_mode = provoking_vertex_mode;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCuModuleCreateInfoNVX.html>"]
pub struct CuModuleCreateInfoNVX<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub data_size: usize,
    pub p_data: *const c_void,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for CuModuleCreateInfoNVX<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            data_size: usize::default(),
            p_data: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for CuModuleCreateInfoNVX<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::CU_MODULE_CREATE_INFO_NVX;
}
impl<'a> CuModuleCreateInfoNVX<'a> {
    #[inline]
    pub fn data(mut self, data: &'a [u8]) -> Self {
        self.data_size = data.len();
        self.p_data = data.as_ptr() as *const c_void;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCuFunctionCreateInfoNVX.html>"]
pub struct CuFunctionCreateInfoNVX<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub module: CuModuleNVX,
    pub p_name: *const c_char,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for CuFunctionCreateInfoNVX<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            module: CuModuleNVX::default(),
            p_name: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for CuFunctionCreateInfoNVX<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::CU_FUNCTION_CREATE_INFO_NVX;
}
impl<'a> CuFunctionCreateInfoNVX<'a> {
    #[inline]
    pub fn module(mut self, module: CuModuleNVX) -> Self {
        self.module = module;
        self
    }
    #[inline]
    pub fn name(mut self, name: &'a ::std::ffi::CStr) -> Self {
        self.p_name = name.as_ptr();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCuLaunchInfoNVX.html>"]
pub struct CuLaunchInfoNVX<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub function: CuFunctionNVX,
    pub grid_dim_x: u32,
    pub grid_dim_y: u32,
    pub grid_dim_z: u32,
    pub block_dim_x: u32,
    pub block_dim_y: u32,
    pub block_dim_z: u32,
    pub shared_mem_bytes: u32,
    pub param_count: usize,
    pub p_params: *const *const c_void,
    pub extra_count: usize,
    pub p_extras: *const *const c_void,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for CuLaunchInfoNVX<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            function: CuFunctionNVX::default(),
            grid_dim_x: u32::default(),
            grid_dim_y: u32::default(),
            grid_dim_z: u32::default(),
            block_dim_x: u32::default(),
            block_dim_y: u32::default(),
            block_dim_z: u32::default(),
            shared_mem_bytes: u32::default(),
            param_count: usize::default(),
            p_params: ::std::ptr::null(),
            extra_count: usize::default(),
            p_extras: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for CuLaunchInfoNVX<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::CU_LAUNCH_INFO_NVX;
}
impl<'a> CuLaunchInfoNVX<'a> {
    #[inline]
    pub fn function(mut self, function: CuFunctionNVX) -> Self {
        self.function = function;
        self
    }
    #[inline]
    pub fn grid_dim_x(mut self, grid_dim_x: u32) -> Self {
        self.grid_dim_x = grid_dim_x;
        self
    }
    #[inline]
    pub fn grid_dim_y(mut self, grid_dim_y: u32) -> Self {
        self.grid_dim_y = grid_dim_y;
        self
    }
    #[inline]
    pub fn grid_dim_z(mut self, grid_dim_z: u32) -> Self {
        self.grid_dim_z = grid_dim_z;
        self
    }
    #[inline]
    pub fn block_dim_x(mut self, block_dim_x: u32) -> Self {
        self.block_dim_x = block_dim_x;
        self
    }
    #[inline]
    pub fn block_dim_y(mut self, block_dim_y: u32) -> Self {
        self.block_dim_y = block_dim_y;
        self
    }
    #[inline]
    pub fn block_dim_z(mut self, block_dim_z: u32) -> Self {
        self.block_dim_z = block_dim_z;
        self
    }
    #[inline]
    pub fn shared_mem_bytes(mut self, shared_mem_bytes: u32) -> Self {
        self.shared_mem_bytes = shared_mem_bytes;
        self
    }
    #[inline]
    pub fn params(mut self, params: &'a [*const c_void]) -> Self {
        self.param_count = params.len();
        self.p_params = params.as_ptr();
        self
    }
    #[inline]
    pub fn extras(mut self, extras: &'a [*const c_void]) -> Self {
        self.extra_count = extras.len();
        self.p_extras = extras.as_ptr();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderIntegerDotProductFeatures.html>"]
pub struct PhysicalDeviceShaderIntegerDotProductFeatures<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shader_integer_dot_product: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceShaderIntegerDotProductFeatures<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            shader_integer_dot_product: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceShaderIntegerDotProductFeatures<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES;
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceShaderIntegerDotProductFeatures<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceShaderIntegerDotProductFeatures<'_> {}
impl<'a> PhysicalDeviceShaderIntegerDotProductFeatures<'a> {
    #[inline]
    pub fn shader_integer_dot_product(mut self, shader_integer_dot_product: bool) -> Self {
        self.shader_integer_dot_product = shader_integer_dot_product.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderIntegerDotProductProperties.html>"]
pub struct PhysicalDeviceShaderIntegerDotProductProperties<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub integer_dot_product8_bit_unsigned_accelerated: Bool32,
    pub integer_dot_product8_bit_signed_accelerated: Bool32,
    pub integer_dot_product8_bit_mixed_signedness_accelerated: Bool32,
    pub integer_dot_product4x8_bit_packed_unsigned_accelerated: Bool32,
    pub integer_dot_product4x8_bit_packed_signed_accelerated: Bool32,
    pub integer_dot_product4x8_bit_packed_mixed_signedness_accelerated: Bool32,
    pub integer_dot_product16_bit_unsigned_accelerated: Bool32,
    pub integer_dot_product16_bit_signed_accelerated: Bool32,
    pub integer_dot_product16_bit_mixed_signedness_accelerated: Bool32,
    pub integer_dot_product32_bit_unsigned_accelerated: Bool32,
    pub integer_dot_product32_bit_signed_accelerated: Bool32,
    pub integer_dot_product32_bit_mixed_signedness_accelerated: Bool32,
    pub integer_dot_product64_bit_unsigned_accelerated: Bool32,
    pub integer_dot_product64_bit_signed_accelerated: Bool32,
    pub integer_dot_product64_bit_mixed_signedness_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating8_bit_signed_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated:
        Bool32,
    pub integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating16_bit_signed_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating32_bit_signed_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating64_bit_signed_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceShaderIntegerDotProductProperties<'_> {
    #[inline]
    fn default() -> Self {
        Self { s_type : Self :: STRUCTURE_TYPE , p_next : :: std :: ptr :: null_mut () , integer_dot_product8_bit_unsigned_accelerated : Bool32 :: default () , integer_dot_product8_bit_signed_accelerated : Bool32 :: default () , integer_dot_product8_bit_mixed_signedness_accelerated : Bool32 :: default () , integer_dot_product4x8_bit_packed_unsigned_accelerated : Bool32 :: default () , integer_dot_product4x8_bit_packed_signed_accelerated : Bool32 :: default () , integer_dot_product4x8_bit_packed_mixed_signedness_accelerated : Bool32 :: default () , integer_dot_product16_bit_unsigned_accelerated : Bool32 :: default () , integer_dot_product16_bit_signed_accelerated : Bool32 :: default () , integer_dot_product16_bit_mixed_signedness_accelerated : Bool32 :: default () , integer_dot_product32_bit_unsigned_accelerated : Bool32 :: default () , integer_dot_product32_bit_signed_accelerated : Bool32 :: default () , integer_dot_product32_bit_mixed_signedness_accelerated : Bool32 :: default () , integer_dot_product64_bit_unsigned_accelerated : Bool32 :: default () , integer_dot_product64_bit_signed_accelerated : Bool32 :: default () , integer_dot_product64_bit_mixed_signedness_accelerated : Bool32 :: default () , integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated : Bool32 :: default () , integer_dot_product_accumulating_saturating8_bit_signed_accelerated : Bool32 :: default () , integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated : Bool32 :: default () , integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated : Bool32 :: default () , integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated : Bool32 :: default () , integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated : Bool32 :: default () , integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated : Bool32 :: default () , integer_dot_product_accumulating_saturating16_bit_signed_accelerated : Bool32 :: default () , integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated : Bool32 :: default () , integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated : Bool32 :: default () , integer_dot_product_accumulating_saturating32_bit_signed_accelerated : Bool32 :: default () , integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated : Bool32 :: default () , integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated : Bool32 :: default () , integer_dot_product_accumulating_saturating64_bit_signed_accelerated : Bool32 :: default () , integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated : Bool32 :: default () , _marker : PhantomData , }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceShaderIntegerDotProductProperties<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES;
}
unsafe impl ExtendsPhysicalDeviceProperties2
    for PhysicalDeviceShaderIntegerDotProductProperties<'_>
{
}
impl<'a> PhysicalDeviceShaderIntegerDotProductProperties<'a> {
    #[inline]
    pub fn integer_dot_product8_bit_unsigned_accelerated(
        mut self,
        integer_dot_product8_bit_unsigned_accelerated: bool,
    ) -> Self {
        self.integer_dot_product8_bit_unsigned_accelerated =
            integer_dot_product8_bit_unsigned_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product8_bit_signed_accelerated(
        mut self,
        integer_dot_product8_bit_signed_accelerated: bool,
    ) -> Self {
        self.integer_dot_product8_bit_signed_accelerated =
            integer_dot_product8_bit_signed_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product8_bit_mixed_signedness_accelerated(
        mut self,
        integer_dot_product8_bit_mixed_signedness_accelerated: bool,
    ) -> Self {
        self.integer_dot_product8_bit_mixed_signedness_accelerated =
            integer_dot_product8_bit_mixed_signedness_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product4x8_bit_packed_unsigned_accelerated(
        mut self,
        integer_dot_product4x8_bit_packed_unsigned_accelerated: bool,
    ) -> Self {
        self.integer_dot_product4x8_bit_packed_unsigned_accelerated =
            integer_dot_product4x8_bit_packed_unsigned_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product4x8_bit_packed_signed_accelerated(
        mut self,
        integer_dot_product4x8_bit_packed_signed_accelerated: bool,
    ) -> Self {
        self.integer_dot_product4x8_bit_packed_signed_accelerated =
            integer_dot_product4x8_bit_packed_signed_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product4x8_bit_packed_mixed_signedness_accelerated(
        mut self,
        integer_dot_product4x8_bit_packed_mixed_signedness_accelerated: bool,
    ) -> Self {
        self.integer_dot_product4x8_bit_packed_mixed_signedness_accelerated =
            integer_dot_product4x8_bit_packed_mixed_signedness_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product16_bit_unsigned_accelerated(
        mut self,
        integer_dot_product16_bit_unsigned_accelerated: bool,
    ) -> Self {
        self.integer_dot_product16_bit_unsigned_accelerated =
            integer_dot_product16_bit_unsigned_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product16_bit_signed_accelerated(
        mut self,
        integer_dot_product16_bit_signed_accelerated: bool,
    ) -> Self {
        self.integer_dot_product16_bit_signed_accelerated =
            integer_dot_product16_bit_signed_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product16_bit_mixed_signedness_accelerated(
        mut self,
        integer_dot_product16_bit_mixed_signedness_accelerated: bool,
    ) -> Self {
        self.integer_dot_product16_bit_mixed_signedness_accelerated =
            integer_dot_product16_bit_mixed_signedness_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product32_bit_unsigned_accelerated(
        mut self,
        integer_dot_product32_bit_unsigned_accelerated: bool,
    ) -> Self {
        self.integer_dot_product32_bit_unsigned_accelerated =
            integer_dot_product32_bit_unsigned_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product32_bit_signed_accelerated(
        mut self,
        integer_dot_product32_bit_signed_accelerated: bool,
    ) -> Self {
        self.integer_dot_product32_bit_signed_accelerated =
            integer_dot_product32_bit_signed_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product32_bit_mixed_signedness_accelerated(
        mut self,
        integer_dot_product32_bit_mixed_signedness_accelerated: bool,
    ) -> Self {
        self.integer_dot_product32_bit_mixed_signedness_accelerated =
            integer_dot_product32_bit_mixed_signedness_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product64_bit_unsigned_accelerated(
        mut self,
        integer_dot_product64_bit_unsigned_accelerated: bool,
    ) -> Self {
        self.integer_dot_product64_bit_unsigned_accelerated =
            integer_dot_product64_bit_unsigned_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product64_bit_signed_accelerated(
        mut self,
        integer_dot_product64_bit_signed_accelerated: bool,
    ) -> Self {
        self.integer_dot_product64_bit_signed_accelerated =
            integer_dot_product64_bit_signed_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product64_bit_mixed_signedness_accelerated(
        mut self,
        integer_dot_product64_bit_mixed_signedness_accelerated: bool,
    ) -> Self {
        self.integer_dot_product64_bit_mixed_signedness_accelerated =
            integer_dot_product64_bit_mixed_signedness_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated(
        mut self,
        integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated: bool,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated =
            integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product_accumulating_saturating8_bit_signed_accelerated(
        mut self,
        integer_dot_product_accumulating_saturating8_bit_signed_accelerated: bool,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating8_bit_signed_accelerated =
            integer_dot_product_accumulating_saturating8_bit_signed_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated(
        mut self,
        integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated: bool,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated =
            integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated(
        mut self,
        integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated: bool,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated =
            integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated(
        mut self,
        integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated: bool,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated =
            integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated(
        mut self,
        integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated : bool,
    ) -> Self {
        self . integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated = integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated . into () ;
        self
    }
    #[inline]
    pub fn integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated(
        mut self,
        integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated: bool,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated =
            integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product_accumulating_saturating16_bit_signed_accelerated(
        mut self,
        integer_dot_product_accumulating_saturating16_bit_signed_accelerated: bool,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating16_bit_signed_accelerated =
            integer_dot_product_accumulating_saturating16_bit_signed_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated(
        mut self,
        integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated: bool,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated =
            integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated(
        mut self,
        integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated: bool,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated =
            integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product_accumulating_saturating32_bit_signed_accelerated(
        mut self,
        integer_dot_product_accumulating_saturating32_bit_signed_accelerated: bool,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating32_bit_signed_accelerated =
            integer_dot_product_accumulating_saturating32_bit_signed_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated(
        mut self,
        integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated: bool,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated =
            integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated(
        mut self,
        integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated: bool,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated =
            integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product_accumulating_saturating64_bit_signed_accelerated(
        mut self,
        integer_dot_product_accumulating_saturating64_bit_signed_accelerated: bool,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating64_bit_signed_accelerated =
            integer_dot_product_accumulating_saturating64_bit_signed_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated(
        mut self,
        integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated: bool,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated =
            integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDrmPropertiesEXT.html>"]
pub struct PhysicalDeviceDrmPropertiesEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub has_primary: Bool32,
    pub has_render: Bool32,
    pub primary_major: i64,
    pub primary_minor: i64,
    pub render_major: i64,
    pub render_minor: i64,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceDrmPropertiesEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            has_primary: Bool32::default(),
            has_render: Bool32::default(),
            primary_major: i64::default(),
            primary_minor: i64::default(),
            render_major: i64::default(),
            render_minor: i64::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceDrmPropertiesEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_DRM_PROPERTIES_EXT;
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceDrmPropertiesEXT<'_> {}
impl<'a> PhysicalDeviceDrmPropertiesEXT<'a> {
    #[inline]
    pub fn has_primary(mut self, has_primary: bool) -> Self {
        self.has_primary = has_primary.into();
        self
    }
    #[inline]
    pub fn has_render(mut self, has_render: bool) -> Self {
        self.has_render = has_render.into();
        self
    }
    #[inline]
    pub fn primary_major(mut self, primary_major: i64) -> Self {
        self.primary_major = primary_major;
        self
    }
    #[inline]
    pub fn primary_minor(mut self, primary_minor: i64) -> Self {
        self.primary_minor = primary_minor;
        self
    }
    #[inline]
    pub fn render_major(mut self, render_major: i64) -> Self {
        self.render_major = render_major;
        self
    }
    #[inline]
    pub fn render_minor(mut self, render_minor: i64) -> Self {
        self.render_minor = render_minor;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR.html>"]
pub struct PhysicalDeviceFragmentShaderBarycentricFeaturesKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub fragment_shader_barycentric: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceFragmentShaderBarycentricFeaturesKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            fragment_shader_barycentric: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceFragmentShaderBarycentricFeaturesKHR<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR;
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceFragmentShaderBarycentricFeaturesKHR<'_>
{
}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceFragmentShaderBarycentricFeaturesKHR<'_> {}
impl<'a> PhysicalDeviceFragmentShaderBarycentricFeaturesKHR<'a> {
    #[inline]
    pub fn fragment_shader_barycentric(mut self, fragment_shader_barycentric: bool) -> Self {
        self.fragment_shader_barycentric = fragment_shader_barycentric.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR.html>"]
pub struct PhysicalDeviceFragmentShaderBarycentricPropertiesKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub tri_strip_vertex_order_independent_of_provoking_vertex: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceFragmentShaderBarycentricPropertiesKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            tri_strip_vertex_order_independent_of_provoking_vertex: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceFragmentShaderBarycentricPropertiesKHR<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_PROPERTIES_KHR;
}
unsafe impl ExtendsPhysicalDeviceProperties2
    for PhysicalDeviceFragmentShaderBarycentricPropertiesKHR<'_>
{
}
impl<'a> PhysicalDeviceFragmentShaderBarycentricPropertiesKHR<'a> {
    #[inline]
    pub fn tri_strip_vertex_order_independent_of_provoking_vertex(
        mut self,
        tri_strip_vertex_order_independent_of_provoking_vertex: bool,
    ) -> Self {
        self.tri_strip_vertex_order_independent_of_provoking_vertex =
            tri_strip_vertex_order_independent_of_provoking_vertex.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceRayTracingMotionBlurFeaturesNV.html>"]
pub struct PhysicalDeviceRayTracingMotionBlurFeaturesNV<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub ray_tracing_motion_blur: Bool32,
    pub ray_tracing_motion_blur_pipeline_trace_rays_indirect: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceRayTracingMotionBlurFeaturesNV<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            ray_tracing_motion_blur: Bool32::default(),
            ray_tracing_motion_blur_pipeline_trace_rays_indirect: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceRayTracingMotionBlurFeaturesNV<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV;
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceRayTracingMotionBlurFeaturesNV<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceRayTracingMotionBlurFeaturesNV<'_> {}
impl<'a> PhysicalDeviceRayTracingMotionBlurFeaturesNV<'a> {
    #[inline]
    pub fn ray_tracing_motion_blur(mut self, ray_tracing_motion_blur: bool) -> Self {
        self.ray_tracing_motion_blur = ray_tracing_motion_blur.into();
        self
    }
    #[inline]
    pub fn ray_tracing_motion_blur_pipeline_trace_rays_indirect(
        mut self,
        ray_tracing_motion_blur_pipeline_trace_rays_indirect: bool,
    ) -> Self {
        self.ray_tracing_motion_blur_pipeline_trace_rays_indirect =
            ray_tracing_motion_blur_pipeline_trace_rays_indirect.into();
        self
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAccelerationStructureGeometryMotionTrianglesDataNV.html>"]
pub struct AccelerationStructureGeometryMotionTrianglesDataNV<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub vertex_data: DeviceOrHostAddressConstKHR,
    pub _marker: PhantomData<&'a ()>,
}
#[cfg(feature = "debug")]
impl fmt::Debug for AccelerationStructureGeometryMotionTrianglesDataNV<'_> {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("AccelerationStructureGeometryMotionTrianglesDataNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("vertex_data", &"union")
            .finish()
    }
}
impl ::std::default::Default for AccelerationStructureGeometryMotionTrianglesDataNV<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            vertex_data: DeviceOrHostAddressConstKHR::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for AccelerationStructureGeometryMotionTrianglesDataNV<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV;
}
unsafe impl ExtendsAccelerationStructureGeometryTrianglesDataKHR
    for AccelerationStructureGeometryMotionTrianglesDataNV<'_>
{
}
impl<'a> AccelerationStructureGeometryMotionTrianglesDataNV<'a> {
    #[inline]
    pub fn vertex_data(mut self, vertex_data: DeviceOrHostAddressConstKHR) -> Self {
        self.vertex_data = vertex_data;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAccelerationStructureMotionInfoNV.html>"]
pub struct AccelerationStructureMotionInfoNV<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub max_instances: u32,
    pub flags: AccelerationStructureMotionInfoFlagsNV,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for AccelerationStructureMotionInfoNV<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            max_instances: u32::default(),
            flags: AccelerationStructureMotionInfoFlagsNV::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for AccelerationStructureMotionInfoNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ACCELERATION_STRUCTURE_MOTION_INFO_NV;
}
unsafe impl ExtendsAccelerationStructureCreateInfoKHR for AccelerationStructureMotionInfoNV<'_> {}
impl<'a> AccelerationStructureMotionInfoNV<'a> {
    #[inline]
    pub fn max_instances(mut self, max_instances: u32) -> Self {
        self.max_instances = max_instances;
        self
    }
    #[inline]
    pub fn flags(mut self, flags: AccelerationStructureMotionInfoFlagsNV) -> Self {
        self.flags = flags;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSRTDataNV.html>"]
pub struct SRTDataNV {
    pub sx: f32,
    pub a: f32,
    pub b: f32,
    pub pvx: f32,
    pub sy: f32,
    pub c: f32,
    pub pvy: f32,
    pub sz: f32,
    pub pvz: f32,
    pub qx: f32,
    pub qy: f32,
    pub qz: f32,
    pub qw: f32,
    pub tx: f32,
    pub ty: f32,
    pub tz: f32,
}
impl SRTDataNV {
    #[inline]
    pub fn sx(mut self, sx: f32) -> Self {
        self.sx = sx;
        self
    }
    #[inline]
    pub fn a(mut self, a: f32) -> Self {
        self.a = a;
        self
    }
    #[inline]
    pub fn b(mut self, b: f32) -> Self {
        self.b = b;
        self
    }
    #[inline]
    pub fn pvx(mut self, pvx: f32) -> Self {
        self.pvx = pvx;
        self
    }
    #[inline]
    pub fn sy(mut self, sy: f32) -> Self {
        self.sy = sy;
        self
    }
    #[inline]
    pub fn c(mut self, c: f32) -> Self {
        self.c = c;
        self
    }
    #[inline]
    pub fn pvy(mut self, pvy: f32) -> Self {
        self.pvy = pvy;
        self
    }
    #[inline]
    pub fn sz(mut self, sz: f32) -> Self {
        self.sz = sz;
        self
    }
    #[inline]
    pub fn pvz(mut self, pvz: f32) -> Self {
        self.pvz = pvz;
        self
    }
    #[inline]
    pub fn qx(mut self, qx: f32) -> Self {
        self.qx = qx;
        self
    }
    #[inline]
    pub fn qy(mut self, qy: f32) -> Self {
        self.qy = qy;
        self
    }
    #[inline]
    pub fn qz(mut self, qz: f32) -> Self {
        self.qz = qz;
        self
    }
    #[inline]
    pub fn qw(mut self, qw: f32) -> Self {
        self.qw = qw;
        self
    }
    #[inline]
    pub fn tx(mut self, tx: f32) -> Self {
        self.tx = tx;
        self
    }
    #[inline]
    pub fn ty(mut self, ty: f32) -> Self {
        self.ty = ty;
        self
    }
    #[inline]
    pub fn tz(mut self, tz: f32) -> Self {
        self.tz = tz;
        self
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAccelerationStructureSRTMotionInstanceNV.html>"]
pub struct AccelerationStructureSRTMotionInstanceNV {
    pub transform_t0: SRTDataNV,
    pub transform_t1: SRTDataNV,
    #[doc = r" Use [`Packed24_8::new(instance_custom_index, mask)`][Packed24_8::new()] to construct this field"]
    pub instance_custom_index_and_mask: Packed24_8,
    #[doc = r" Use [`Packed24_8::new(instance_shader_binding_table_record_offset, flags)`][Packed24_8::new()] to construct this field"]
    pub instance_shader_binding_table_record_offset_and_flags: Packed24_8,
    pub acceleration_structure_reference: AccelerationStructureReferenceKHR,
}
#[repr(C)]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/AccelerationStructureMatrixMotionInstanceNV.html>"]
pub struct AccelerationStructureMatrixMotionInstanceNV {
    pub transform_t0: TransformMatrixKHR,
    pub transform_t1: TransformMatrixKHR,
    #[doc = r" Use [`Packed24_8::new(instance_custom_index, mask)`][Packed24_8::new()] to construct this field"]
    pub instance_custom_index_and_mask: Packed24_8,
    #[doc = r" Use [`Packed24_8::new(instance_shader_binding_table_record_offset, flags)`][Packed24_8::new()] to construct this field"]
    pub instance_shader_binding_table_record_offset_and_flags: Packed24_8,
    pub acceleration_structure_reference: AccelerationStructureReferenceKHR,
}
#[repr(C)]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAccelerationStructureMotionInstanceDataNV.html>"]
pub union AccelerationStructureMotionInstanceDataNV {
    pub static_instance: AccelerationStructureInstanceKHR,
    pub matrix_motion_instance: AccelerationStructureMatrixMotionInstanceNV,
    pub srt_motion_instance: AccelerationStructureSRTMotionInstanceNV,
}
impl ::std::default::Default for AccelerationStructureMotionInstanceDataNV {
    #[inline]
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAccelerationStructureMotionInstanceNV.html>"]
pub struct AccelerationStructureMotionInstanceNV {
    pub ty: AccelerationStructureMotionInstanceTypeNV,
    pub flags: AccelerationStructureMotionInstanceFlagsNV,
    pub data: AccelerationStructureMotionInstanceDataNV,
}
#[cfg(feature = "debug")]
impl fmt::Debug for AccelerationStructureMotionInstanceNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("AccelerationStructureMotionInstanceNV")
            .field("ty", &self.ty)
            .field("flags", &self.flags)
            .field("data", &"union")
            .finish()
    }
}
impl AccelerationStructureMotionInstanceNV {
    #[inline]
    pub fn ty(mut self, ty: AccelerationStructureMotionInstanceTypeNV) -> Self {
        self.ty = ty;
        self
    }
    #[inline]
    pub fn flags(mut self, flags: AccelerationStructureMotionInstanceFlagsNV) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn data(mut self, data: AccelerationStructureMotionInstanceDataNV) -> Self {
        self.data = data;
        self
    }
}
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRemoteAddressNV.html>"]
pub type RemoteAddressNV = c_void;
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryGetRemoteAddressInfoNV.html>"]
pub struct MemoryGetRemoteAddressInfoNV<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub memory: DeviceMemory,
    pub handle_type: ExternalMemoryHandleTypeFlags,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for MemoryGetRemoteAddressInfoNV<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            memory: DeviceMemory::default(),
            handle_type: ExternalMemoryHandleTypeFlags::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for MemoryGetRemoteAddressInfoNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::MEMORY_GET_REMOTE_ADDRESS_INFO_NV;
}
impl<'a> MemoryGetRemoteAddressInfoNV<'a> {
    #[inline]
    pub fn memory(mut self, memory: DeviceMemory) -> Self {
        self.memory = memory;
        self
    }
    #[inline]
    pub fn handle_type(mut self, handle_type: ExternalMemoryHandleTypeFlags) -> Self {
        self.handle_type = handle_type;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImportMemoryBufferCollectionFUCHSIA.html>"]
pub struct ImportMemoryBufferCollectionFUCHSIA<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub collection: BufferCollectionFUCHSIA,
    pub index: u32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for ImportMemoryBufferCollectionFUCHSIA<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            collection: BufferCollectionFUCHSIA::default(),
            index: u32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for ImportMemoryBufferCollectionFUCHSIA<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::IMPORT_MEMORY_BUFFER_COLLECTION_FUCHSIA;
}
unsafe impl ExtendsMemoryAllocateInfo for ImportMemoryBufferCollectionFUCHSIA<'_> {}
impl<'a> ImportMemoryBufferCollectionFUCHSIA<'a> {
    #[inline]
    pub fn collection(mut self, collection: BufferCollectionFUCHSIA) -> Self {
        self.collection = collection;
        self
    }
    #[inline]
    pub fn index(mut self, index: u32) -> Self {
        self.index = index;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferCollectionImageCreateInfoFUCHSIA.html>"]
pub struct BufferCollectionImageCreateInfoFUCHSIA<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub collection: BufferCollectionFUCHSIA,
    pub index: u32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for BufferCollectionImageCreateInfoFUCHSIA<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            collection: BufferCollectionFUCHSIA::default(),
            index: u32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for BufferCollectionImageCreateInfoFUCHSIA<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::BUFFER_COLLECTION_IMAGE_CREATE_INFO_FUCHSIA;
}
unsafe impl ExtendsImageCreateInfo for BufferCollectionImageCreateInfoFUCHSIA<'_> {}
impl<'a> BufferCollectionImageCreateInfoFUCHSIA<'a> {
    #[inline]
    pub fn collection(mut self, collection: BufferCollectionFUCHSIA) -> Self {
        self.collection = collection;
        self
    }
    #[inline]
    pub fn index(mut self, index: u32) -> Self {
        self.index = index;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferCollectionBufferCreateInfoFUCHSIA.html>"]
pub struct BufferCollectionBufferCreateInfoFUCHSIA<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub collection: BufferCollectionFUCHSIA,
    pub index: u32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for BufferCollectionBufferCreateInfoFUCHSIA<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            collection: BufferCollectionFUCHSIA::default(),
            index: u32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for BufferCollectionBufferCreateInfoFUCHSIA<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::BUFFER_COLLECTION_BUFFER_CREATE_INFO_FUCHSIA;
}
unsafe impl ExtendsBufferCreateInfo for BufferCollectionBufferCreateInfoFUCHSIA<'_> {}
impl<'a> BufferCollectionBufferCreateInfoFUCHSIA<'a> {
    #[inline]
    pub fn collection(mut self, collection: BufferCollectionFUCHSIA) -> Self {
        self.collection = collection;
        self
    }
    #[inline]
    pub fn index(mut self, index: u32) -> Self {
        self.index = index;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferCollectionCreateInfoFUCHSIA.html>"]
pub struct BufferCollectionCreateInfoFUCHSIA<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub collection_token: zx_handle_t,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for BufferCollectionCreateInfoFUCHSIA<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            collection_token: zx_handle_t::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for BufferCollectionCreateInfoFUCHSIA<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::BUFFER_COLLECTION_CREATE_INFO_FUCHSIA;
}
impl<'a> BufferCollectionCreateInfoFUCHSIA<'a> {
    #[inline]
    pub fn collection_token(mut self, collection_token: zx_handle_t) -> Self {
        self.collection_token = collection_token;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferCollectionPropertiesFUCHSIA.html>"]
pub struct BufferCollectionPropertiesFUCHSIA<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub memory_type_bits: u32,
    pub buffer_count: u32,
    pub create_info_index: u32,
    pub sysmem_pixel_format: u64,
    pub format_features: FormatFeatureFlags,
    pub sysmem_color_space_index: SysmemColorSpaceFUCHSIA<'a>,
    pub sampler_ycbcr_conversion_components: ComponentMapping,
    pub suggested_ycbcr_model: SamplerYcbcrModelConversion,
    pub suggested_ycbcr_range: SamplerYcbcrRange,
    pub suggested_x_chroma_offset: ChromaLocation,
    pub suggested_y_chroma_offset: ChromaLocation,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for BufferCollectionPropertiesFUCHSIA<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            memory_type_bits: u32::default(),
            buffer_count: u32::default(),
            create_info_index: u32::default(),
            sysmem_pixel_format: u64::default(),
            format_features: FormatFeatureFlags::default(),
            sysmem_color_space_index: SysmemColorSpaceFUCHSIA::default(),
            sampler_ycbcr_conversion_components: ComponentMapping::default(),
            suggested_ycbcr_model: SamplerYcbcrModelConversion::default(),
            suggested_ycbcr_range: SamplerYcbcrRange::default(),
            suggested_x_chroma_offset: ChromaLocation::default(),
            suggested_y_chroma_offset: ChromaLocation::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for BufferCollectionPropertiesFUCHSIA<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::BUFFER_COLLECTION_PROPERTIES_FUCHSIA;
}
impl<'a> BufferCollectionPropertiesFUCHSIA<'a> {
    #[inline]
    pub fn memory_type_bits(mut self, memory_type_bits: u32) -> Self {
        self.memory_type_bits = memory_type_bits;
        self
    }
    #[inline]
    pub fn buffer_count(mut self, buffer_count: u32) -> Self {
        self.buffer_count = buffer_count;
        self
    }
    #[inline]
    pub fn create_info_index(mut self, create_info_index: u32) -> Self {
        self.create_info_index = create_info_index;
        self
    }
    #[inline]
    pub fn sysmem_pixel_format(mut self, sysmem_pixel_format: u64) -> Self {
        self.sysmem_pixel_format = sysmem_pixel_format;
        self
    }
    #[inline]
    pub fn format_features(mut self, format_features: FormatFeatureFlags) -> Self {
        self.format_features = format_features;
        self
    }
    #[inline]
    pub fn sysmem_color_space_index(
        mut self,
        sysmem_color_space_index: SysmemColorSpaceFUCHSIA<'a>,
    ) -> Self {
        self.sysmem_color_space_index = sysmem_color_space_index;
        self
    }
    #[inline]
    pub fn sampler_ycbcr_conversion_components(
        mut self,
        sampler_ycbcr_conversion_components: ComponentMapping,
    ) -> Self {
        self.sampler_ycbcr_conversion_components = sampler_ycbcr_conversion_components;
        self
    }
    #[inline]
    pub fn suggested_ycbcr_model(
        mut self,
        suggested_ycbcr_model: SamplerYcbcrModelConversion,
    ) -> Self {
        self.suggested_ycbcr_model = suggested_ycbcr_model;
        self
    }
    #[inline]
    pub fn suggested_ycbcr_range(mut self, suggested_ycbcr_range: SamplerYcbcrRange) -> Self {
        self.suggested_ycbcr_range = suggested_ycbcr_range;
        self
    }
    #[inline]
    pub fn suggested_x_chroma_offset(mut self, suggested_x_chroma_offset: ChromaLocation) -> Self {
        self.suggested_x_chroma_offset = suggested_x_chroma_offset;
        self
    }
    #[inline]
    pub fn suggested_y_chroma_offset(mut self, suggested_y_chroma_offset: ChromaLocation) -> Self {
        self.suggested_y_chroma_offset = suggested_y_chroma_offset;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferConstraintsInfoFUCHSIA.html>"]
pub struct BufferConstraintsInfoFUCHSIA<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub create_info: BufferCreateInfo<'a>,
    pub required_format_features: FormatFeatureFlags,
    pub buffer_collection_constraints: BufferCollectionConstraintsInfoFUCHSIA<'a>,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for BufferConstraintsInfoFUCHSIA<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            create_info: BufferCreateInfo::default(),
            required_format_features: FormatFeatureFlags::default(),
            buffer_collection_constraints: BufferCollectionConstraintsInfoFUCHSIA::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for BufferConstraintsInfoFUCHSIA<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::BUFFER_CONSTRAINTS_INFO_FUCHSIA;
}
impl<'a> BufferConstraintsInfoFUCHSIA<'a> {
    #[inline]
    pub fn create_info(mut self, create_info: BufferCreateInfo<'a>) -> Self {
        self.create_info = create_info;
        self
    }
    #[inline]
    pub fn required_format_features(
        mut self,
        required_format_features: FormatFeatureFlags,
    ) -> Self {
        self.required_format_features = required_format_features;
        self
    }
    #[inline]
    pub fn buffer_collection_constraints(
        mut self,
        buffer_collection_constraints: BufferCollectionConstraintsInfoFUCHSIA<'a>,
    ) -> Self {
        self.buffer_collection_constraints = buffer_collection_constraints;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSysmemColorSpaceFUCHSIA.html>"]
pub struct SysmemColorSpaceFUCHSIA<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub color_space: u32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for SysmemColorSpaceFUCHSIA<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            color_space: u32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for SysmemColorSpaceFUCHSIA<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::SYSMEM_COLOR_SPACE_FUCHSIA;
}
impl<'a> SysmemColorSpaceFUCHSIA<'a> {
    #[inline]
    pub fn color_space(mut self, color_space: u32) -> Self {
        self.color_space = color_space;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageFormatConstraintsInfoFUCHSIA.html>"]
pub struct ImageFormatConstraintsInfoFUCHSIA<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub image_create_info: ImageCreateInfo<'a>,
    pub required_format_features: FormatFeatureFlags,
    pub flags: ImageFormatConstraintsFlagsFUCHSIA,
    pub sysmem_pixel_format: u64,
    pub color_space_count: u32,
    pub p_color_spaces: *const SysmemColorSpaceFUCHSIA<'a>,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for ImageFormatConstraintsInfoFUCHSIA<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            image_create_info: ImageCreateInfo::default(),
            required_format_features: FormatFeatureFlags::default(),
            flags: ImageFormatConstraintsFlagsFUCHSIA::default(),
            sysmem_pixel_format: u64::default(),
            color_space_count: u32::default(),
            p_color_spaces: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for ImageFormatConstraintsInfoFUCHSIA<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::IMAGE_FORMAT_CONSTRAINTS_INFO_FUCHSIA;
}
impl<'a> ImageFormatConstraintsInfoFUCHSIA<'a> {
    #[inline]
    pub fn image_create_info(mut self, image_create_info: ImageCreateInfo<'a>) -> Self {
        self.image_create_info = image_create_info;
        self
    }
    #[inline]
    pub fn required_format_features(
        mut self,
        required_format_features: FormatFeatureFlags,
    ) -> Self {
        self.required_format_features = required_format_features;
        self
    }
    #[inline]
    pub fn flags(mut self, flags: ImageFormatConstraintsFlagsFUCHSIA) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn sysmem_pixel_format(mut self, sysmem_pixel_format: u64) -> Self {
        self.sysmem_pixel_format = sysmem_pixel_format;
        self
    }
    #[inline]
    pub fn color_spaces(mut self, color_spaces: &'a [SysmemColorSpaceFUCHSIA]) -> Self {
        self.color_space_count = color_spaces.len() as _;
        self.p_color_spaces = color_spaces.as_ptr();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageConstraintsInfoFUCHSIA.html>"]
pub struct ImageConstraintsInfoFUCHSIA<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub format_constraints_count: u32,
    pub p_format_constraints: *const ImageFormatConstraintsInfoFUCHSIA<'a>,
    pub buffer_collection_constraints: BufferCollectionConstraintsInfoFUCHSIA<'a>,
    pub flags: ImageConstraintsInfoFlagsFUCHSIA,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for ImageConstraintsInfoFUCHSIA<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            format_constraints_count: u32::default(),
            p_format_constraints: ::std::ptr::null(),
            buffer_collection_constraints: BufferCollectionConstraintsInfoFUCHSIA::default(),
            flags: ImageConstraintsInfoFlagsFUCHSIA::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for ImageConstraintsInfoFUCHSIA<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::IMAGE_CONSTRAINTS_INFO_FUCHSIA;
}
impl<'a> ImageConstraintsInfoFUCHSIA<'a> {
    #[inline]
    pub fn format_constraints(
        mut self,
        format_constraints: &'a [ImageFormatConstraintsInfoFUCHSIA],
    ) -> Self {
        self.format_constraints_count = format_constraints.len() as _;
        self.p_format_constraints = format_constraints.as_ptr();
        self
    }
    #[inline]
    pub fn buffer_collection_constraints(
        mut self,
        buffer_collection_constraints: BufferCollectionConstraintsInfoFUCHSIA<'a>,
    ) -> Self {
        self.buffer_collection_constraints = buffer_collection_constraints;
        self
    }
    #[inline]
    pub fn flags(mut self, flags: ImageConstraintsInfoFlagsFUCHSIA) -> Self {
        self.flags = flags;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferCollectionConstraintsInfoFUCHSIA.html>"]
pub struct BufferCollectionConstraintsInfoFUCHSIA<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub min_buffer_count: u32,
    pub max_buffer_count: u32,
    pub min_buffer_count_for_camping: u32,
    pub min_buffer_count_for_dedicated_slack: u32,
    pub min_buffer_count_for_shared_slack: u32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for BufferCollectionConstraintsInfoFUCHSIA<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            min_buffer_count: u32::default(),
            max_buffer_count: u32::default(),
            min_buffer_count_for_camping: u32::default(),
            min_buffer_count_for_dedicated_slack: u32::default(),
            min_buffer_count_for_shared_slack: u32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for BufferCollectionConstraintsInfoFUCHSIA<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::BUFFER_COLLECTION_CONSTRAINTS_INFO_FUCHSIA;
}
impl<'a> BufferCollectionConstraintsInfoFUCHSIA<'a> {
    #[inline]
    pub fn min_buffer_count(mut self, min_buffer_count: u32) -> Self {
        self.min_buffer_count = min_buffer_count;
        self
    }
    #[inline]
    pub fn max_buffer_count(mut self, max_buffer_count: u32) -> Self {
        self.max_buffer_count = max_buffer_count;
        self
    }
    #[inline]
    pub fn min_buffer_count_for_camping(mut self, min_buffer_count_for_camping: u32) -> Self {
        self.min_buffer_count_for_camping = min_buffer_count_for_camping;
        self
    }
    #[inline]
    pub fn min_buffer_count_for_dedicated_slack(
        mut self,
        min_buffer_count_for_dedicated_slack: u32,
    ) -> Self {
        self.min_buffer_count_for_dedicated_slack = min_buffer_count_for_dedicated_slack;
        self
    }
    #[inline]
    pub fn min_buffer_count_for_shared_slack(
        mut self,
        min_buffer_count_for_shared_slack: u32,
    ) -> Self {
        self.min_buffer_count_for_shared_slack = min_buffer_count_for_shared_slack;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT.html>"]
pub struct PhysicalDeviceRGBA10X6FormatsFeaturesEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub format_rgba10x6_without_y_cb_cr_sampler: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceRGBA10X6FormatsFeaturesEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            format_rgba10x6_without_y_cb_cr_sampler: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceRGBA10X6FormatsFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT;
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceRGBA10X6FormatsFeaturesEXT<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceRGBA10X6FormatsFeaturesEXT<'_> {}
impl<'a> PhysicalDeviceRGBA10X6FormatsFeaturesEXT<'a> {
    #[inline]
    pub fn format_rgba10x6_without_y_cb_cr_sampler(
        mut self,
        format_rgba10x6_without_y_cb_cr_sampler: bool,
    ) -> Self {
        self.format_rgba10x6_without_y_cb_cr_sampler =
            format_rgba10x6_without_y_cb_cr_sampler.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFormatProperties3.html>"]
pub struct FormatProperties3<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub linear_tiling_features: FormatFeatureFlags2,
    pub optimal_tiling_features: FormatFeatureFlags2,
    pub buffer_features: FormatFeatureFlags2,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for FormatProperties3<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            linear_tiling_features: FormatFeatureFlags2::default(),
            optimal_tiling_features: FormatFeatureFlags2::default(),
            buffer_features: FormatFeatureFlags2::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for FormatProperties3<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::FORMAT_PROPERTIES_3;
}
unsafe impl ExtendsFormatProperties2 for FormatProperties3<'_> {}
impl<'a> FormatProperties3<'a> {
    #[inline]
    pub fn linear_tiling_features(mut self, linear_tiling_features: FormatFeatureFlags2) -> Self {
        self.linear_tiling_features = linear_tiling_features;
        self
    }
    #[inline]
    pub fn optimal_tiling_features(mut self, optimal_tiling_features: FormatFeatureFlags2) -> Self {
        self.optimal_tiling_features = optimal_tiling_features;
        self
    }
    #[inline]
    pub fn buffer_features(mut self, buffer_features: FormatFeatureFlags2) -> Self {
        self.buffer_features = buffer_features;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDrmFormatModifierPropertiesList2EXT.html>"]
pub struct DrmFormatModifierPropertiesList2EXT<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub drm_format_modifier_count: u32,
    pub p_drm_format_modifier_properties: *mut DrmFormatModifierProperties2EXT,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for DrmFormatModifierPropertiesList2EXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            drm_format_modifier_count: u32::default(),
            p_drm_format_modifier_properties: ::std::ptr::null_mut(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for DrmFormatModifierPropertiesList2EXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT;
}
unsafe impl ExtendsFormatProperties2 for DrmFormatModifierPropertiesList2EXT<'_> {}
impl<'a> DrmFormatModifierPropertiesList2EXT<'a> {
    #[inline]
    pub fn drm_format_modifier_properties(
        mut self,
        drm_format_modifier_properties: &'a mut [DrmFormatModifierProperties2EXT],
    ) -> Self {
        self.drm_format_modifier_count = drm_format_modifier_properties.len() as _;
        self.p_drm_format_modifier_properties = drm_format_modifier_properties.as_mut_ptr();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDrmFormatModifierProperties2EXT.html>"]
pub struct DrmFormatModifierProperties2EXT {
    pub drm_format_modifier: u64,
    pub drm_format_modifier_plane_count: u32,
    pub drm_format_modifier_tiling_features: FormatFeatureFlags2,
}
impl DrmFormatModifierProperties2EXT {
    #[inline]
    pub fn drm_format_modifier(mut self, drm_format_modifier: u64) -> Self {
        self.drm_format_modifier = drm_format_modifier;
        self
    }
    #[inline]
    pub fn drm_format_modifier_plane_count(mut self, drm_format_modifier_plane_count: u32) -> Self {
        self.drm_format_modifier_plane_count = drm_format_modifier_plane_count;
        self
    }
    #[inline]
    pub fn drm_format_modifier_tiling_features(
        mut self,
        drm_format_modifier_tiling_features: FormatFeatureFlags2,
    ) -> Self {
        self.drm_format_modifier_tiling_features = drm_format_modifier_tiling_features;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAndroidHardwareBufferFormatProperties2ANDROID.html>"]
pub struct AndroidHardwareBufferFormatProperties2ANDROID<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub format: Format,
    pub external_format: u64,
    pub format_features: FormatFeatureFlags2,
    pub sampler_ycbcr_conversion_components: ComponentMapping,
    pub suggested_ycbcr_model: SamplerYcbcrModelConversion,
    pub suggested_ycbcr_range: SamplerYcbcrRange,
    pub suggested_x_chroma_offset: ChromaLocation,
    pub suggested_y_chroma_offset: ChromaLocation,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for AndroidHardwareBufferFormatProperties2ANDROID<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            format: Format::default(),
            external_format: u64::default(),
            format_features: FormatFeatureFlags2::default(),
            sampler_ycbcr_conversion_components: ComponentMapping::default(),
            suggested_ycbcr_model: SamplerYcbcrModelConversion::default(),
            suggested_ycbcr_range: SamplerYcbcrRange::default(),
            suggested_x_chroma_offset: ChromaLocation::default(),
            suggested_y_chroma_offset: ChromaLocation::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for AndroidHardwareBufferFormatProperties2ANDROID<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_2_ANDROID;
}
unsafe impl ExtendsAndroidHardwareBufferPropertiesANDROID
    for AndroidHardwareBufferFormatProperties2ANDROID<'_>
{
}
impl<'a> AndroidHardwareBufferFormatProperties2ANDROID<'a> {
    #[inline]
    pub fn format(mut self, format: Format) -> Self {
        self.format = format;
        self
    }
    #[inline]
    pub fn external_format(mut self, external_format: u64) -> Self {
        self.external_format = external_format;
        self
    }
    #[inline]
    pub fn format_features(mut self, format_features: FormatFeatureFlags2) -> Self {
        self.format_features = format_features;
        self
    }
    #[inline]
    pub fn sampler_ycbcr_conversion_components(
        mut self,
        sampler_ycbcr_conversion_components: ComponentMapping,
    ) -> Self {
        self.sampler_ycbcr_conversion_components = sampler_ycbcr_conversion_components;
        self
    }
    #[inline]
    pub fn suggested_ycbcr_model(
        mut self,
        suggested_ycbcr_model: SamplerYcbcrModelConversion,
    ) -> Self {
        self.suggested_ycbcr_model = suggested_ycbcr_model;
        self
    }
    #[inline]
    pub fn suggested_ycbcr_range(mut self, suggested_ycbcr_range: SamplerYcbcrRange) -> Self {
        self.suggested_ycbcr_range = suggested_ycbcr_range;
        self
    }
    #[inline]
    pub fn suggested_x_chroma_offset(mut self, suggested_x_chroma_offset: ChromaLocation) -> Self {
        self.suggested_x_chroma_offset = suggested_x_chroma_offset;
        self
    }
    #[inline]
    pub fn suggested_y_chroma_offset(mut self, suggested_y_chroma_offset: ChromaLocation) -> Self {
        self.suggested_y_chroma_offset = suggested_y_chroma_offset;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineRenderingCreateInfo.html>"]
pub struct PipelineRenderingCreateInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub view_mask: u32,
    pub color_attachment_count: u32,
    pub p_color_attachment_formats: *const Format,
    pub depth_attachment_format: Format,
    pub stencil_attachment_format: Format,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PipelineRenderingCreateInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            view_mask: u32::default(),
            color_attachment_count: u32::default(),
            p_color_attachment_formats: ::std::ptr::null(),
            depth_attachment_format: Format::default(),
            stencil_attachment_format: Format::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PipelineRenderingCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PIPELINE_RENDERING_CREATE_INFO;
}
unsafe impl ExtendsGraphicsPipelineCreateInfo for PipelineRenderingCreateInfo<'_> {}
impl<'a> PipelineRenderingCreateInfo<'a> {
    #[inline]
    pub fn view_mask(mut self, view_mask: u32) -> Self {
        self.view_mask = view_mask;
        self
    }
    #[inline]
    pub fn color_attachment_formats(mut self, color_attachment_formats: &'a [Format]) -> Self {
        self.color_attachment_count = color_attachment_formats.len() as _;
        self.p_color_attachment_formats = color_attachment_formats.as_ptr();
        self
    }
    #[inline]
    pub fn depth_attachment_format(mut self, depth_attachment_format: Format) -> Self {
        self.depth_attachment_format = depth_attachment_format;
        self
    }
    #[inline]
    pub fn stencil_attachment_format(mut self, stencil_attachment_format: Format) -> Self {
        self.stencil_attachment_format = stencil_attachment_format;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderingInfo.html>"]
pub struct RenderingInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: RenderingFlags,
    pub render_area: Rect2D,
    pub layer_count: u32,
    pub view_mask: u32,
    pub color_attachment_count: u32,
    pub p_color_attachments: *const RenderingAttachmentInfo<'a>,
    pub p_depth_attachment: *const RenderingAttachmentInfo<'a>,
    pub p_stencil_attachment: *const RenderingAttachmentInfo<'a>,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for RenderingInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: RenderingFlags::default(),
            render_area: Rect2D::default(),
            layer_count: u32::default(),
            view_mask: u32::default(),
            color_attachment_count: u32::default(),
            p_color_attachments: ::std::ptr::null(),
            p_depth_attachment: ::std::ptr::null(),
            p_stencil_attachment: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for RenderingInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::RENDERING_INFO;
}
pub unsafe trait ExtendsRenderingInfo {}
impl<'a> RenderingInfo<'a> {
    #[inline]
    pub fn flags(mut self, flags: RenderingFlags) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn render_area(mut self, render_area: Rect2D) -> Self {
        self.render_area = render_area;
        self
    }
    #[inline]
    pub fn layer_count(mut self, layer_count: u32) -> Self {
        self.layer_count = layer_count;
        self
    }
    #[inline]
    pub fn view_mask(mut self, view_mask: u32) -> Self {
        self.view_mask = view_mask;
        self
    }
    #[inline]
    pub fn color_attachments(mut self, color_attachments: &'a [RenderingAttachmentInfo]) -> Self {
        self.color_attachment_count = color_attachments.len() as _;
        self.p_color_attachments = color_attachments.as_ptr();
        self
    }
    #[inline]
    pub fn depth_attachment(mut self, depth_attachment: &'a RenderingAttachmentInfo<'a>) -> Self {
        self.p_depth_attachment = depth_attachment;
        self
    }
    #[inline]
    pub fn stencil_attachment(
        mut self,
        stencil_attachment: &'a RenderingAttachmentInfo<'a>,
    ) -> Self {
        self.p_stencil_attachment = stencil_attachment;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `x.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsRenderingInfo>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.p_next as _;
            self.p_next = next_ptr;
        }
        self
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderingAttachmentInfo.html>"]
pub struct RenderingAttachmentInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub image_view: ImageView,
    pub image_layout: ImageLayout,
    pub resolve_mode: ResolveModeFlags,
    pub resolve_image_view: ImageView,
    pub resolve_image_layout: ImageLayout,
    pub load_op: AttachmentLoadOp,
    pub store_op: AttachmentStoreOp,
    pub clear_value: ClearValue,
    pub _marker: PhantomData<&'a ()>,
}
#[cfg(feature = "debug")]
impl fmt::Debug for RenderingAttachmentInfo<'_> {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("RenderingAttachmentInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("image_view", &self.image_view)
            .field("image_layout", &self.image_layout)
            .field("resolve_mode", &self.resolve_mode)
            .field("resolve_image_view", &self.resolve_image_view)
            .field("resolve_image_layout", &self.resolve_image_layout)
            .field("load_op", &self.load_op)
            .field("store_op", &self.store_op)
            .field("clear_value", &"union")
            .finish()
    }
}
impl ::std::default::Default for RenderingAttachmentInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            image_view: ImageView::default(),
            image_layout: ImageLayout::default(),
            resolve_mode: ResolveModeFlags::default(),
            resolve_image_view: ImageView::default(),
            resolve_image_layout: ImageLayout::default(),
            load_op: AttachmentLoadOp::default(),
            store_op: AttachmentStoreOp::default(),
            clear_value: ClearValue::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for RenderingAttachmentInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::RENDERING_ATTACHMENT_INFO;
}
impl<'a> RenderingAttachmentInfo<'a> {
    #[inline]
    pub fn image_view(mut self, image_view: ImageView) -> Self {
        self.image_view = image_view;
        self
    }
    #[inline]
    pub fn image_layout(mut self, image_layout: ImageLayout) -> Self {
        self.image_layout = image_layout;
        self
    }
    #[inline]
    pub fn resolve_mode(mut self, resolve_mode: ResolveModeFlags) -> Self {
        self.resolve_mode = resolve_mode;
        self
    }
    #[inline]
    pub fn resolve_image_view(mut self, resolve_image_view: ImageView) -> Self {
        self.resolve_image_view = resolve_image_view;
        self
    }
    #[inline]
    pub fn resolve_image_layout(mut self, resolve_image_layout: ImageLayout) -> Self {
        self.resolve_image_layout = resolve_image_layout;
        self
    }
    #[inline]
    pub fn load_op(mut self, load_op: AttachmentLoadOp) -> Self {
        self.load_op = load_op;
        self
    }
    #[inline]
    pub fn store_op(mut self, store_op: AttachmentStoreOp) -> Self {
        self.store_op = store_op;
        self
    }
    #[inline]
    pub fn clear_value(mut self, clear_value: ClearValue) -> Self {
        self.clear_value = clear_value;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderingFragmentShadingRateAttachmentInfoKHR.html>"]
pub struct RenderingFragmentShadingRateAttachmentInfoKHR<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub image_view: ImageView,
    pub image_layout: ImageLayout,
    pub shading_rate_attachment_texel_size: Extent2D,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for RenderingFragmentShadingRateAttachmentInfoKHR<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            image_view: ImageView::default(),
            image_layout: ImageLayout::default(),
            shading_rate_attachment_texel_size: Extent2D::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for RenderingFragmentShadingRateAttachmentInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR;
}
unsafe impl ExtendsRenderingInfo for RenderingFragmentShadingRateAttachmentInfoKHR<'_> {}
impl<'a> RenderingFragmentShadingRateAttachmentInfoKHR<'a> {
    #[inline]
    pub fn image_view(mut self, image_view: ImageView) -> Self {
        self.image_view = image_view;
        self
    }
    #[inline]
    pub fn image_layout(mut self, image_layout: ImageLayout) -> Self {
        self.image_layout = image_layout;
        self
    }
    #[inline]
    pub fn shading_rate_attachment_texel_size(
        mut self,
        shading_rate_attachment_texel_size: Extent2D,
    ) -> Self {
        self.shading_rate_attachment_texel_size = shading_rate_attachment_texel_size;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderingFragmentDensityMapAttachmentInfoEXT.html>"]
pub struct RenderingFragmentDensityMapAttachmentInfoEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub image_view: ImageView,
    pub image_layout: ImageLayout,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for RenderingFragmentDensityMapAttachmentInfoEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            image_view: ImageView::default(),
            image_layout: ImageLayout::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for RenderingFragmentDensityMapAttachmentInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT;
}
unsafe impl ExtendsRenderingInfo for RenderingFragmentDensityMapAttachmentInfoEXT<'_> {}
impl<'a> RenderingFragmentDensityMapAttachmentInfoEXT<'a> {
    #[inline]
    pub fn image_view(mut self, image_view: ImageView) -> Self {
        self.image_view = image_view;
        self
    }
    #[inline]
    pub fn image_layout(mut self, image_layout: ImageLayout) -> Self {
        self.image_layout = image_layout;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDynamicRenderingFeatures.html>"]
pub struct PhysicalDeviceDynamicRenderingFeatures<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub dynamic_rendering: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceDynamicRenderingFeatures<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            dynamic_rendering: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceDynamicRenderingFeatures<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES;
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceDynamicRenderingFeatures<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceDynamicRenderingFeatures<'_> {}
impl<'a> PhysicalDeviceDynamicRenderingFeatures<'a> {
    #[inline]
    pub fn dynamic_rendering(mut self, dynamic_rendering: bool) -> Self {
        self.dynamic_rendering = dynamic_rendering.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandBufferInheritanceRenderingInfo.html>"]
pub struct CommandBufferInheritanceRenderingInfo<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: RenderingFlags,
    pub view_mask: u32,
    pub color_attachment_count: u32,
    pub p_color_attachment_formats: *const Format,
    pub depth_attachment_format: Format,
    pub stencil_attachment_format: Format,
    pub rasterization_samples: SampleCountFlags,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for CommandBufferInheritanceRenderingInfo<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: RenderingFlags::default(),
            view_mask: u32::default(),
            color_attachment_count: u32::default(),
            p_color_attachment_formats: ::std::ptr::null(),
            depth_attachment_format: Format::default(),
            stencil_attachment_format: Format::default(),
            rasterization_samples: SampleCountFlags::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for CommandBufferInheritanceRenderingInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::COMMAND_BUFFER_INHERITANCE_RENDERING_INFO;
}
unsafe impl ExtendsCommandBufferInheritanceInfo for CommandBufferInheritanceRenderingInfo<'_> {}
impl<'a> CommandBufferInheritanceRenderingInfo<'a> {
    #[inline]
    pub fn flags(mut self, flags: RenderingFlags) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn view_mask(mut self, view_mask: u32) -> Self {
        self.view_mask = view_mask;
        self
    }
    #[inline]
    pub fn color_attachment_formats(mut self, color_attachment_formats: &'a [Format]) -> Self {
        self.color_attachment_count = color_attachment_formats.len() as _;
        self.p_color_attachment_formats = color_attachment_formats.as_ptr();
        self
    }
    #[inline]
    pub fn depth_attachment_format(mut self, depth_attachment_format: Format) -> Self {
        self.depth_attachment_format = depth_attachment_format;
        self
    }
    #[inline]
    pub fn stencil_attachment_format(mut self, stencil_attachment_format: Format) -> Self {
        self.stencil_attachment_format = stencil_attachment_format;
        self
    }
    #[inline]
    pub fn rasterization_samples(mut self, rasterization_samples: SampleCountFlags) -> Self {
        self.rasterization_samples = rasterization_samples;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAttachmentSampleCountInfoAMD.html>"]
pub struct AttachmentSampleCountInfoAMD<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub color_attachment_count: u32,
    pub p_color_attachment_samples: *const SampleCountFlags,
    pub depth_stencil_attachment_samples: SampleCountFlags,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for AttachmentSampleCountInfoAMD<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            color_attachment_count: u32::default(),
            p_color_attachment_samples: ::std::ptr::null(),
            depth_stencil_attachment_samples: SampleCountFlags::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for AttachmentSampleCountInfoAMD<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ATTACHMENT_SAMPLE_COUNT_INFO_AMD;
}
unsafe impl ExtendsCommandBufferInheritanceInfo for AttachmentSampleCountInfoAMD<'_> {}
unsafe impl ExtendsGraphicsPipelineCreateInfo for AttachmentSampleCountInfoAMD<'_> {}
impl<'a> AttachmentSampleCountInfoAMD<'a> {
    #[inline]
    pub fn color_attachment_samples(
        mut self,
        color_attachment_samples: &'a [SampleCountFlags],
    ) -> Self {
        self.color_attachment_count = color_attachment_samples.len() as _;
        self.p_color_attachment_samples = color_attachment_samples.as_ptr();
        self
    }
    #[inline]
    pub fn depth_stencil_attachment_samples(
        mut self,
        depth_stencil_attachment_samples: SampleCountFlags,
    ) -> Self {
        self.depth_stencil_attachment_samples = depth_stencil_attachment_samples;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMultiviewPerViewAttributesInfoNVX.html>"]
pub struct MultiviewPerViewAttributesInfoNVX<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub per_view_attributes: Bool32,
    pub per_view_attributes_position_x_only: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for MultiviewPerViewAttributesInfoNVX<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            per_view_attributes: Bool32::default(),
            per_view_attributes_position_x_only: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for MultiviewPerViewAttributesInfoNVX<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX;
}
unsafe impl ExtendsCommandBufferInheritanceInfo for MultiviewPerViewAttributesInfoNVX<'_> {}
unsafe impl ExtendsGraphicsPipelineCreateInfo for MultiviewPerViewAttributesInfoNVX<'_> {}
unsafe impl ExtendsRenderingInfo for MultiviewPerViewAttributesInfoNVX<'_> {}
impl<'a> MultiviewPerViewAttributesInfoNVX<'a> {
    #[inline]
    pub fn per_view_attributes(mut self, per_view_attributes: bool) -> Self {
        self.per_view_attributes = per_view_attributes.into();
        self
    }
    #[inline]
    pub fn per_view_attributes_position_x_only(
        mut self,
        per_view_attributes_position_x_only: bool,
    ) -> Self {
        self.per_view_attributes_position_x_only = per_view_attributes_position_x_only.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceImageViewMinLodFeaturesEXT.html>"]
pub struct PhysicalDeviceImageViewMinLodFeaturesEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub min_lod: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceImageViewMinLodFeaturesEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            min_lod: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceImageViewMinLodFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT;
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceImageViewMinLodFeaturesEXT<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceImageViewMinLodFeaturesEXT<'_> {}
impl<'a> PhysicalDeviceImageViewMinLodFeaturesEXT<'a> {
    #[inline]
    pub fn min_lod(mut self, min_lod: bool) -> Self {
        self.min_lod = min_lod.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageViewMinLodCreateInfoEXT.html>"]
pub struct ImageViewMinLodCreateInfoEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub min_lod: f32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for ImageViewMinLodCreateInfoEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            min_lod: f32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for ImageViewMinLodCreateInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::IMAGE_VIEW_MIN_LOD_CREATE_INFO_EXT;
}
unsafe impl ExtendsImageViewCreateInfo for ImageViewMinLodCreateInfoEXT<'_> {}
impl<'a> ImageViewMinLodCreateInfoEXT<'a> {
    #[inline]
    pub fn min_lod(mut self, min_lod: f32) -> Self {
        self.min_lod = min_lod;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesARM.html>"]
pub struct PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesARM<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub rasterization_order_color_attachment_access: Bool32,
    pub rasterization_order_depth_attachment_access: Bool32,
    pub rasterization_order_stencil_attachment_access: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesARM<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            rasterization_order_color_attachment_access: Bool32::default(),
            rasterization_order_depth_attachment_access: Bool32::default(),
            rasterization_order_stencil_attachment_access: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure
    for PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesARM<'a>
{
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_ARM;
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesARM<'_>
{
}
unsafe impl ExtendsDeviceCreateInfo
    for PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesARM<'_>
{
}
impl<'a> PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesARM<'a> {
    #[inline]
    pub fn rasterization_order_color_attachment_access(
        mut self,
        rasterization_order_color_attachment_access: bool,
    ) -> Self {
        self.rasterization_order_color_attachment_access =
            rasterization_order_color_attachment_access.into();
        self
    }
    #[inline]
    pub fn rasterization_order_depth_attachment_access(
        mut self,
        rasterization_order_depth_attachment_access: bool,
    ) -> Self {
        self.rasterization_order_depth_attachment_access =
            rasterization_order_depth_attachment_access.into();
        self
    }
    #[inline]
    pub fn rasterization_order_stencil_attachment_access(
        mut self,
        rasterization_order_stencil_attachment_access: bool,
    ) -> Self {
        self.rasterization_order_stencil_attachment_access =
            rasterization_order_stencil_attachment_access.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceLinearColorAttachmentFeaturesNV.html>"]
pub struct PhysicalDeviceLinearColorAttachmentFeaturesNV<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub linear_color_attachment: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceLinearColorAttachmentFeaturesNV<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            linear_color_attachment: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceLinearColorAttachmentFeaturesNV<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV;
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceLinearColorAttachmentFeaturesNV<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceLinearColorAttachmentFeaturesNV<'_> {}
impl<'a> PhysicalDeviceLinearColorAttachmentFeaturesNV<'a> {
    #[inline]
    pub fn linear_color_attachment(mut self, linear_color_attachment: bool) -> Self {
        self.linear_color_attachment = linear_color_attachment.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT.html>"]
pub struct PhysicalDeviceGraphicsPipelineLibraryFeaturesEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub graphics_pipeline_library: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceGraphicsPipelineLibraryFeaturesEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            graphics_pipeline_library: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceGraphicsPipelineLibraryFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT;
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceGraphicsPipelineLibraryFeaturesEXT<'_>
{
}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceGraphicsPipelineLibraryFeaturesEXT<'_> {}
impl<'a> PhysicalDeviceGraphicsPipelineLibraryFeaturesEXT<'a> {
    #[inline]
    pub fn graphics_pipeline_library(mut self, graphics_pipeline_library: bool) -> Self {
        self.graphics_pipeline_library = graphics_pipeline_library.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT.html>"]
pub struct PhysicalDeviceGraphicsPipelineLibraryPropertiesEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub graphics_pipeline_library_fast_linking: Bool32,
    pub graphics_pipeline_library_independent_interpolation_decoration: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceGraphicsPipelineLibraryPropertiesEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            graphics_pipeline_library_fast_linking: Bool32::default(),
            graphics_pipeline_library_independent_interpolation_decoration: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceGraphicsPipelineLibraryPropertiesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT;
}
unsafe impl ExtendsPhysicalDeviceProperties2
    for PhysicalDeviceGraphicsPipelineLibraryPropertiesEXT<'_>
{
}
impl<'a> PhysicalDeviceGraphicsPipelineLibraryPropertiesEXT<'a> {
    #[inline]
    pub fn graphics_pipeline_library_fast_linking(
        mut self,
        graphics_pipeline_library_fast_linking: bool,
    ) -> Self {
        self.graphics_pipeline_library_fast_linking = graphics_pipeline_library_fast_linking.into();
        self
    }
    #[inline]
    pub fn graphics_pipeline_library_independent_interpolation_decoration(
        mut self,
        graphics_pipeline_library_independent_interpolation_decoration: bool,
    ) -> Self {
        self.graphics_pipeline_library_independent_interpolation_decoration =
            graphics_pipeline_library_independent_interpolation_decoration.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkGraphicsPipelineLibraryCreateInfoEXT.html>"]
pub struct GraphicsPipelineLibraryCreateInfoEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub flags: GraphicsPipelineLibraryFlagsEXT,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for GraphicsPipelineLibraryCreateInfoEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            flags: GraphicsPipelineLibraryFlagsEXT::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for GraphicsPipelineLibraryCreateInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT;
}
unsafe impl ExtendsGraphicsPipelineCreateInfo for GraphicsPipelineLibraryCreateInfoEXT<'_> {}
impl<'a> GraphicsPipelineLibraryCreateInfoEXT<'a> {
    #[inline]
    pub fn flags(mut self, flags: GraphicsPipelineLibraryFlagsEXT) -> Self {
        self.flags = flags;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE.html>"]
pub struct PhysicalDeviceDescriptorSetHostMappingFeaturesVALVE<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub descriptor_set_host_mapping: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceDescriptorSetHostMappingFeaturesVALVE<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            descriptor_set_host_mapping: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceDescriptorSetHostMappingFeaturesVALVE<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE;
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceDescriptorSetHostMappingFeaturesVALVE<'_>
{
}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceDescriptorSetHostMappingFeaturesVALVE<'_> {}
impl<'a> PhysicalDeviceDescriptorSetHostMappingFeaturesVALVE<'a> {
    #[inline]
    pub fn descriptor_set_host_mapping(mut self, descriptor_set_host_mapping: bool) -> Self {
        self.descriptor_set_host_mapping = descriptor_set_host_mapping.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorSetBindingReferenceVALVE.html>"]
pub struct DescriptorSetBindingReferenceVALVE<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub descriptor_set_layout: DescriptorSetLayout,
    pub binding: u32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for DescriptorSetBindingReferenceVALVE<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            descriptor_set_layout: DescriptorSetLayout::default(),
            binding: u32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for DescriptorSetBindingReferenceVALVE<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DESCRIPTOR_SET_BINDING_REFERENCE_VALVE;
}
impl<'a> DescriptorSetBindingReferenceVALVE<'a> {
    #[inline]
    pub fn descriptor_set_layout(mut self, descriptor_set_layout: DescriptorSetLayout) -> Self {
        self.descriptor_set_layout = descriptor_set_layout;
        self
    }
    #[inline]
    pub fn binding(mut self, binding: u32) -> Self {
        self.binding = binding;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorSetLayoutHostMappingInfoVALVE.html>"]
pub struct DescriptorSetLayoutHostMappingInfoVALVE<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub descriptor_offset: usize,
    pub descriptor_size: u32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for DescriptorSetLayoutHostMappingInfoVALVE<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            descriptor_offset: usize::default(),
            descriptor_size: u32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for DescriptorSetLayoutHostMappingInfoVALVE<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::DESCRIPTOR_SET_LAYOUT_HOST_MAPPING_INFO_VALVE;
}
impl<'a> DescriptorSetLayoutHostMappingInfoVALVE<'a> {
    #[inline]
    pub fn descriptor_offset(mut self, descriptor_offset: usize) -> Self {
        self.descriptor_offset = descriptor_offset;
        self
    }
    #[inline]
    pub fn descriptor_size(mut self, descriptor_size: u32) -> Self {
        self.descriptor_size = descriptor_size;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT.html>"]
pub struct PhysicalDeviceShaderModuleIdentifierFeaturesEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shader_module_identifier: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceShaderModuleIdentifierFeaturesEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            shader_module_identifier: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceShaderModuleIdentifierFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT;
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceShaderModuleIdentifierFeaturesEXT<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceShaderModuleIdentifierFeaturesEXT<'_> {}
impl<'a> PhysicalDeviceShaderModuleIdentifierFeaturesEXT<'a> {
    #[inline]
    pub fn shader_module_identifier(mut self, shader_module_identifier: bool) -> Self {
        self.shader_module_identifier = shader_module_identifier.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT.html>"]
pub struct PhysicalDeviceShaderModuleIdentifierPropertiesEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shader_module_identifier_algorithm_uuid: [u8; UUID_SIZE],
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceShaderModuleIdentifierPropertiesEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            shader_module_identifier_algorithm_uuid: unsafe { ::std::mem::zeroed() },
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceShaderModuleIdentifierPropertiesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_PROPERTIES_EXT;
}
unsafe impl ExtendsPhysicalDeviceProperties2
    for PhysicalDeviceShaderModuleIdentifierPropertiesEXT<'_>
{
}
impl<'a> PhysicalDeviceShaderModuleIdentifierPropertiesEXT<'a> {
    #[inline]
    pub fn shader_module_identifier_algorithm_uuid(
        mut self,
        shader_module_identifier_algorithm_uuid: [u8; UUID_SIZE],
    ) -> Self {
        self.shader_module_identifier_algorithm_uuid = shader_module_identifier_algorithm_uuid;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineShaderStageModuleIdentifierCreateInfoEXT.html>"]
pub struct PipelineShaderStageModuleIdentifierCreateInfoEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub identifier_size: u32,
    pub p_identifier: *const u8,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PipelineShaderStageModuleIdentifierCreateInfoEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            identifier_size: u32::default(),
            p_identifier: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PipelineShaderStageModuleIdentifierCreateInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT;
}
unsafe impl ExtendsPipelineShaderStageCreateInfo
    for PipelineShaderStageModuleIdentifierCreateInfoEXT<'_>
{
}
impl<'a> PipelineShaderStageModuleIdentifierCreateInfoEXT<'a> {
    #[inline]
    pub fn identifier(mut self, identifier: &'a [u8]) -> Self {
        self.identifier_size = identifier.len() as _;
        self.p_identifier = identifier.as_ptr();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkShaderModuleIdentifierEXT.html>"]
pub struct ShaderModuleIdentifierEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub identifier_size: u32,
    pub identifier: [u8; MAX_SHADER_MODULE_IDENTIFIER_SIZE_EXT],
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for ShaderModuleIdentifierEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            identifier_size: u32::default(),
            identifier: unsafe { ::std::mem::zeroed() },
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for ShaderModuleIdentifierEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::SHADER_MODULE_IDENTIFIER_EXT;
}
impl<'a> ShaderModuleIdentifierEXT<'a> {
    #[inline]
    pub fn identifier_size(mut self, identifier_size: u32) -> Self {
        self.identifier_size = identifier_size;
        self
    }
    #[inline]
    pub fn identifier(mut self, identifier: [u8; MAX_SHADER_MODULE_IDENTIFIER_SIZE_EXT]) -> Self {
        self.identifier = identifier;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageCompressionControlEXT.html>"]
pub struct ImageCompressionControlEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: ImageCompressionFlagsEXT,
    pub compression_control_plane_count: u32,
    pub p_fixed_rate_flags: *mut ImageCompressionFixedRateFlagsEXT,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for ImageCompressionControlEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: ImageCompressionFlagsEXT::default(),
            compression_control_plane_count: u32::default(),
            p_fixed_rate_flags: ::std::ptr::null_mut(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for ImageCompressionControlEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::IMAGE_COMPRESSION_CONTROL_EXT;
}
unsafe impl ExtendsImageCreateInfo for ImageCompressionControlEXT<'_> {}
unsafe impl ExtendsSwapchainCreateInfoKHR for ImageCompressionControlEXT<'_> {}
unsafe impl ExtendsPhysicalDeviceImageFormatInfo2 for ImageCompressionControlEXT<'_> {}
impl<'a> ImageCompressionControlEXT<'a> {
    #[inline]
    pub fn flags(mut self, flags: ImageCompressionFlagsEXT) -> Self {
        self.flags = flags;
        self
    }
    #[inline]
    pub fn fixed_rate_flags(
        mut self,
        fixed_rate_flags: &'a mut [ImageCompressionFixedRateFlagsEXT],
    ) -> Self {
        self.compression_control_plane_count = fixed_rate_flags.len() as _;
        self.p_fixed_rate_flags = fixed_rate_flags.as_mut_ptr();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceImageCompressionControlFeaturesEXT.html>"]
pub struct PhysicalDeviceImageCompressionControlFeaturesEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub image_compression_control: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceImageCompressionControlFeaturesEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            image_compression_control: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceImageCompressionControlFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT;
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceImageCompressionControlFeaturesEXT<'_>
{
}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceImageCompressionControlFeaturesEXT<'_> {}
impl<'a> PhysicalDeviceImageCompressionControlFeaturesEXT<'a> {
    #[inline]
    pub fn image_compression_control(mut self, image_compression_control: bool) -> Self {
        self.image_compression_control = image_compression_control.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageCompressionPropertiesEXT.html>"]
pub struct ImageCompressionPropertiesEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub image_compression_flags: ImageCompressionFlagsEXT,
    pub image_compression_fixed_rate_flags: ImageCompressionFixedRateFlagsEXT,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for ImageCompressionPropertiesEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            image_compression_flags: ImageCompressionFlagsEXT::default(),
            image_compression_fixed_rate_flags: ImageCompressionFixedRateFlagsEXT::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for ImageCompressionPropertiesEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::IMAGE_COMPRESSION_PROPERTIES_EXT;
}
unsafe impl ExtendsImageFormatProperties2 for ImageCompressionPropertiesEXT<'_> {}
unsafe impl ExtendsSurfaceFormat2KHR for ImageCompressionPropertiesEXT<'_> {}
unsafe impl ExtendsSubresourceLayout2EXT for ImageCompressionPropertiesEXT<'_> {}
impl<'a> ImageCompressionPropertiesEXT<'a> {
    #[inline]
    pub fn image_compression_flags(
        mut self,
        image_compression_flags: ImageCompressionFlagsEXT,
    ) -> Self {
        self.image_compression_flags = image_compression_flags;
        self
    }
    #[inline]
    pub fn image_compression_fixed_rate_flags(
        mut self,
        image_compression_fixed_rate_flags: ImageCompressionFixedRateFlagsEXT,
    ) -> Self {
        self.image_compression_fixed_rate_flags = image_compression_fixed_rate_flags;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT.html>"]
pub struct PhysicalDeviceImageCompressionControlSwapchainFeaturesEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub image_compression_control_swapchain: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceImageCompressionControlSwapchainFeaturesEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            image_compression_control_swapchain: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceImageCompressionControlSwapchainFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT;
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceImageCompressionControlSwapchainFeaturesEXT<'_>
{
}
unsafe impl ExtendsDeviceCreateInfo
    for PhysicalDeviceImageCompressionControlSwapchainFeaturesEXT<'_>
{
}
impl<'a> PhysicalDeviceImageCompressionControlSwapchainFeaturesEXT<'a> {
    #[inline]
    pub fn image_compression_control_swapchain(
        mut self,
        image_compression_control_swapchain: bool,
    ) -> Self {
        self.image_compression_control_swapchain = image_compression_control_swapchain.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageSubresource2EXT.html>"]
pub struct ImageSubresource2EXT<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub image_subresource: ImageSubresource,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for ImageSubresource2EXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            image_subresource: ImageSubresource::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for ImageSubresource2EXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::IMAGE_SUBRESOURCE_2_EXT;
}
impl<'a> ImageSubresource2EXT<'a> {
    #[inline]
    pub fn image_subresource(mut self, image_subresource: ImageSubresource) -> Self {
        self.image_subresource = image_subresource;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSubresourceLayout2EXT.html>"]
pub struct SubresourceLayout2EXT<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub subresource_layout: SubresourceLayout,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for SubresourceLayout2EXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            subresource_layout: SubresourceLayout::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for SubresourceLayout2EXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::SUBRESOURCE_LAYOUT_2_EXT;
}
pub unsafe trait ExtendsSubresourceLayout2EXT {}
impl<'a> SubresourceLayout2EXT<'a> {
    #[inline]
    pub fn subresource_layout(mut self, subresource_layout: SubresourceLayout) -> Self {
        self.subresource_layout = subresource_layout;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `x.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsSubresourceLayout2EXT>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*mut T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.p_next as _;
            self.p_next = next_ptr;
        }
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderPassCreationControlEXT.html>"]
pub struct RenderPassCreationControlEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub disallow_merging: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for RenderPassCreationControlEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            disallow_merging: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for RenderPassCreationControlEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::RENDER_PASS_CREATION_CONTROL_EXT;
}
unsafe impl ExtendsRenderPassCreateInfo2 for RenderPassCreationControlEXT<'_> {}
unsafe impl ExtendsSubpassDescription2 for RenderPassCreationControlEXT<'_> {}
impl<'a> RenderPassCreationControlEXT<'a> {
    #[inline]
    pub fn disallow_merging(mut self, disallow_merging: bool) -> Self {
        self.disallow_merging = disallow_merging.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderPassCreationFeedbackInfoEXT.html>"]
pub struct RenderPassCreationFeedbackInfoEXT {
    pub post_merge_subpass_count: u32,
}
impl RenderPassCreationFeedbackInfoEXT {
    #[inline]
    pub fn post_merge_subpass_count(mut self, post_merge_subpass_count: u32) -> Self {
        self.post_merge_subpass_count = post_merge_subpass_count;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderPassCreationFeedbackCreateInfoEXT.html>"]
pub struct RenderPassCreationFeedbackCreateInfoEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub p_render_pass_feedback: *mut RenderPassCreationFeedbackInfoEXT,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for RenderPassCreationFeedbackCreateInfoEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            p_render_pass_feedback: ::std::ptr::null_mut(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for RenderPassCreationFeedbackCreateInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::RENDER_PASS_CREATION_FEEDBACK_CREATE_INFO_EXT;
}
unsafe impl ExtendsRenderPassCreateInfo2 for RenderPassCreationFeedbackCreateInfoEXT<'_> {}
impl<'a> RenderPassCreationFeedbackCreateInfoEXT<'a> {
    #[inline]
    pub fn render_pass_feedback(
        mut self,
        render_pass_feedback: &'a mut RenderPassCreationFeedbackInfoEXT,
    ) -> Self {
        self.p_render_pass_feedback = render_pass_feedback;
        self
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderPassSubpassFeedbackInfoEXT.html>"]
pub struct RenderPassSubpassFeedbackInfoEXT {
    pub subpass_merge_status: SubpassMergeStatusEXT,
    pub description: [c_char; MAX_DESCRIPTION_SIZE],
    pub post_merge_index: u32,
}
#[cfg(feature = "debug")]
impl fmt::Debug for RenderPassSubpassFeedbackInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("RenderPassSubpassFeedbackInfoEXT")
            .field("subpass_merge_status", &self.subpass_merge_status)
            .field("description", &unsafe {
                ::std::ffi::CStr::from_ptr(self.description.as_ptr())
            })
            .field("post_merge_index", &self.post_merge_index)
            .finish()
    }
}
impl ::std::default::Default for RenderPassSubpassFeedbackInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            subpass_merge_status: SubpassMergeStatusEXT::default(),
            description: unsafe { ::std::mem::zeroed() },
            post_merge_index: u32::default(),
        }
    }
}
impl RenderPassSubpassFeedbackInfoEXT {
    #[inline]
    pub fn subpass_merge_status(mut self, subpass_merge_status: SubpassMergeStatusEXT) -> Self {
        self.subpass_merge_status = subpass_merge_status;
        self
    }
    #[inline]
    pub fn description(mut self, description: [c_char; MAX_DESCRIPTION_SIZE]) -> Self {
        self.description = description;
        self
    }
    #[inline]
    pub fn post_merge_index(mut self, post_merge_index: u32) -> Self {
        self.post_merge_index = post_merge_index;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderPassSubpassFeedbackCreateInfoEXT.html>"]
pub struct RenderPassSubpassFeedbackCreateInfoEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub p_subpass_feedback: *mut RenderPassSubpassFeedbackInfoEXT,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for RenderPassSubpassFeedbackCreateInfoEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            p_subpass_feedback: ::std::ptr::null_mut(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for RenderPassSubpassFeedbackCreateInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::RENDER_PASS_SUBPASS_FEEDBACK_CREATE_INFO_EXT;
}
unsafe impl ExtendsSubpassDescription2 for RenderPassSubpassFeedbackCreateInfoEXT<'_> {}
impl<'a> RenderPassSubpassFeedbackCreateInfoEXT<'a> {
    #[inline]
    pub fn subpass_feedback(
        mut self,
        subpass_feedback: &'a mut RenderPassSubpassFeedbackInfoEXT,
    ) -> Self {
        self.p_subpass_feedback = subpass_feedback;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT.html>"]
pub struct PhysicalDeviceSubpassMergeFeedbackFeaturesEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub subpass_merge_feedback: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceSubpassMergeFeedbackFeaturesEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            subpass_merge_feedback: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceSubpassMergeFeedbackFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT;
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceSubpassMergeFeedbackFeaturesEXT<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceSubpassMergeFeedbackFeaturesEXT<'_> {}
impl<'a> PhysicalDeviceSubpassMergeFeedbackFeaturesEXT<'a> {
    #[inline]
    pub fn subpass_merge_feedback(mut self, subpass_merge_feedback: bool) -> Self {
        self.subpass_merge_feedback = subpass_merge_feedback.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelinePropertiesIdentifierEXT.html>"]
pub struct PipelinePropertiesIdentifierEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub pipeline_identifier: [u8; UUID_SIZE],
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PipelinePropertiesIdentifierEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            pipeline_identifier: unsafe { ::std::mem::zeroed() },
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PipelinePropertiesIdentifierEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PIPELINE_PROPERTIES_IDENTIFIER_EXT;
}
impl<'a> PipelinePropertiesIdentifierEXT<'a> {
    #[inline]
    pub fn pipeline_identifier(mut self, pipeline_identifier: [u8; UUID_SIZE]) -> Self {
        self.pipeline_identifier = pipeline_identifier;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePipelinePropertiesFeaturesEXT.html>"]
pub struct PhysicalDevicePipelinePropertiesFeaturesEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub pipeline_properties_identifier: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDevicePipelinePropertiesFeaturesEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            pipeline_properties_identifier: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDevicePipelinePropertiesFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT;
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDevicePipelinePropertiesFeaturesEXT<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDevicePipelinePropertiesFeaturesEXT<'_> {}
impl<'a> PhysicalDevicePipelinePropertiesFeaturesEXT<'a> {
    #[inline]
    pub fn pipeline_properties_identifier(mut self, pipeline_properties_identifier: bool) -> Self {
        self.pipeline_properties_identifier = pipeline_properties_identifier.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD.html>"]
pub struct PhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shader_early_and_late_fragment_tests: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            shader_early_and_late_fragment_tests: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD;
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD<'_>
{
}
unsafe impl ExtendsDeviceCreateInfo
    for PhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD<'_>
{
}
impl<'a> PhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD<'a> {
    #[inline]
    pub fn shader_early_and_late_fragment_tests(
        mut self,
        shader_early_and_late_fragment_tests: bool,
    ) -> Self {
        self.shader_early_and_late_fragment_tests = shader_early_and_late_fragment_tests.into();
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExportMetalObjectCreateInfoEXT.html>"]
pub struct ExportMetalObjectCreateInfoEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub export_object_type: ExportMetalObjectTypeFlagsEXT,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for ExportMetalObjectCreateInfoEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            export_object_type: ExportMetalObjectTypeFlagsEXT::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for ExportMetalObjectCreateInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::EXPORT_METAL_OBJECT_CREATE_INFO_EXT;
}
unsafe impl ExtendsInstanceCreateInfo for ExportMetalObjectCreateInfoEXT<'_> {}
unsafe impl ExtendsMemoryAllocateInfo for ExportMetalObjectCreateInfoEXT<'_> {}
unsafe impl ExtendsImageCreateInfo for ExportMetalObjectCreateInfoEXT<'_> {}
unsafe impl ExtendsImageViewCreateInfo for ExportMetalObjectCreateInfoEXT<'_> {}
unsafe impl ExtendsBufferViewCreateInfo for ExportMetalObjectCreateInfoEXT<'_> {}
unsafe impl ExtendsSemaphoreCreateInfo for ExportMetalObjectCreateInfoEXT<'_> {}
unsafe impl ExtendsEventCreateInfo for ExportMetalObjectCreateInfoEXT<'_> {}
impl<'a> ExportMetalObjectCreateInfoEXT<'a> {
    #[inline]
    pub fn export_object_type(mut self, export_object_type: ExportMetalObjectTypeFlagsEXT) -> Self {
        self.export_object_type = export_object_type;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExportMetalObjectsInfoEXT.html>"]
pub struct ExportMetalObjectsInfoEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for ExportMetalObjectsInfoEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for ExportMetalObjectsInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::EXPORT_METAL_OBJECTS_INFO_EXT;
}
pub unsafe trait ExtendsExportMetalObjectsInfoEXT {}
impl<'a> ExportMetalObjectsInfoEXT<'a> {
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `x.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsExportMetalObjectsInfoEXT>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.p_next as _;
            self.p_next = next_ptr;
        }
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExportMetalDeviceInfoEXT.html>"]
pub struct ExportMetalDeviceInfoEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub mtl_device: MTLDevice_id,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for ExportMetalDeviceInfoEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            mtl_device: unsafe { ::std::mem::zeroed() },
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for ExportMetalDeviceInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::EXPORT_METAL_DEVICE_INFO_EXT;
}
unsafe impl ExtendsExportMetalObjectsInfoEXT for ExportMetalDeviceInfoEXT<'_> {}
impl<'a> ExportMetalDeviceInfoEXT<'a> {
    #[inline]
    pub fn mtl_device(mut self, mtl_device: MTLDevice_id) -> Self {
        self.mtl_device = mtl_device;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExportMetalCommandQueueInfoEXT.html>"]
pub struct ExportMetalCommandQueueInfoEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub queue: Queue,
    pub mtl_command_queue: MTLCommandQueue_id,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for ExportMetalCommandQueueInfoEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            queue: Queue::default(),
            mtl_command_queue: unsafe { ::std::mem::zeroed() },
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for ExportMetalCommandQueueInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::EXPORT_METAL_COMMAND_QUEUE_INFO_EXT;
}
unsafe impl ExtendsExportMetalObjectsInfoEXT for ExportMetalCommandQueueInfoEXT<'_> {}
impl<'a> ExportMetalCommandQueueInfoEXT<'a> {
    #[inline]
    pub fn queue(mut self, queue: Queue) -> Self {
        self.queue = queue;
        self
    }
    #[inline]
    pub fn mtl_command_queue(mut self, mtl_command_queue: MTLCommandQueue_id) -> Self {
        self.mtl_command_queue = mtl_command_queue;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExportMetalBufferInfoEXT.html>"]
pub struct ExportMetalBufferInfoEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub memory: DeviceMemory,
    pub mtl_buffer: MTLBuffer_id,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for ExportMetalBufferInfoEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            memory: DeviceMemory::default(),
            mtl_buffer: unsafe { ::std::mem::zeroed() },
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for ExportMetalBufferInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::EXPORT_METAL_BUFFER_INFO_EXT;
}
unsafe impl ExtendsExportMetalObjectsInfoEXT for ExportMetalBufferInfoEXT<'_> {}
impl<'a> ExportMetalBufferInfoEXT<'a> {
    #[inline]
    pub fn memory(mut self, memory: DeviceMemory) -> Self {
        self.memory = memory;
        self
    }
    #[inline]
    pub fn mtl_buffer(mut self, mtl_buffer: MTLBuffer_id) -> Self {
        self.mtl_buffer = mtl_buffer;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImportMetalBufferInfoEXT.html>"]
pub struct ImportMetalBufferInfoEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub mtl_buffer: MTLBuffer_id,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for ImportMetalBufferInfoEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            mtl_buffer: unsafe { ::std::mem::zeroed() },
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for ImportMetalBufferInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::IMPORT_METAL_BUFFER_INFO_EXT;
}
unsafe impl ExtendsMemoryAllocateInfo for ImportMetalBufferInfoEXT<'_> {}
impl<'a> ImportMetalBufferInfoEXT<'a> {
    #[inline]
    pub fn mtl_buffer(mut self, mtl_buffer: MTLBuffer_id) -> Self {
        self.mtl_buffer = mtl_buffer;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExportMetalTextureInfoEXT.html>"]
pub struct ExportMetalTextureInfoEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub image: Image,
    pub image_view: ImageView,
    pub buffer_view: BufferView,
    pub plane: ImageAspectFlags,
    pub mtl_texture: MTLTexture_id,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for ExportMetalTextureInfoEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            image: Image::default(),
            image_view: ImageView::default(),
            buffer_view: BufferView::default(),
            plane: ImageAspectFlags::default(),
            mtl_texture: unsafe { ::std::mem::zeroed() },
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for ExportMetalTextureInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::EXPORT_METAL_TEXTURE_INFO_EXT;
}
unsafe impl ExtendsExportMetalObjectsInfoEXT for ExportMetalTextureInfoEXT<'_> {}
impl<'a> ExportMetalTextureInfoEXT<'a> {
    #[inline]
    pub fn image(mut self, image: Image) -> Self {
        self.image = image;
        self
    }
    #[inline]
    pub fn image_view(mut self, image_view: ImageView) -> Self {
        self.image_view = image_view;
        self
    }
    #[inline]
    pub fn buffer_view(mut self, buffer_view: BufferView) -> Self {
        self.buffer_view = buffer_view;
        self
    }
    #[inline]
    pub fn plane(mut self, plane: ImageAspectFlags) -> Self {
        self.plane = plane;
        self
    }
    #[inline]
    pub fn mtl_texture(mut self, mtl_texture: MTLTexture_id) -> Self {
        self.mtl_texture = mtl_texture;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImportMetalTextureInfoEXT.html>"]
pub struct ImportMetalTextureInfoEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub plane: ImageAspectFlags,
    pub mtl_texture: MTLTexture_id,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for ImportMetalTextureInfoEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            plane: ImageAspectFlags::default(),
            mtl_texture: unsafe { ::std::mem::zeroed() },
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for ImportMetalTextureInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::IMPORT_METAL_TEXTURE_INFO_EXT;
}
unsafe impl ExtendsImageCreateInfo for ImportMetalTextureInfoEXT<'_> {}
impl<'a> ImportMetalTextureInfoEXT<'a> {
    #[inline]
    pub fn plane(mut self, plane: ImageAspectFlags) -> Self {
        self.plane = plane;
        self
    }
    #[inline]
    pub fn mtl_texture(mut self, mtl_texture: MTLTexture_id) -> Self {
        self.mtl_texture = mtl_texture;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExportMetalIOSurfaceInfoEXT.html>"]
pub struct ExportMetalIOSurfaceInfoEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub image: Image,
    pub io_surface: IOSurfaceRef,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for ExportMetalIOSurfaceInfoEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            image: Image::default(),
            io_surface: unsafe { ::std::mem::zeroed() },
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for ExportMetalIOSurfaceInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::EXPORT_METAL_IO_SURFACE_INFO_EXT;
}
unsafe impl ExtendsExportMetalObjectsInfoEXT for ExportMetalIOSurfaceInfoEXT<'_> {}
impl<'a> ExportMetalIOSurfaceInfoEXT<'a> {
    #[inline]
    pub fn image(mut self, image: Image) -> Self {
        self.image = image;
        self
    }
    #[inline]
    pub fn io_surface(mut self, io_surface: IOSurfaceRef) -> Self {
        self.io_surface = io_surface;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImportMetalIOSurfaceInfoEXT.html>"]
pub struct ImportMetalIOSurfaceInfoEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub io_surface: IOSurfaceRef,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for ImportMetalIOSurfaceInfoEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            io_surface: unsafe { ::std::mem::zeroed() },
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for ImportMetalIOSurfaceInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::IMPORT_METAL_IO_SURFACE_INFO_EXT;
}
unsafe impl ExtendsImageCreateInfo for ImportMetalIOSurfaceInfoEXT<'_> {}
impl<'a> ImportMetalIOSurfaceInfoEXT<'a> {
    #[inline]
    pub fn io_surface(mut self, io_surface: IOSurfaceRef) -> Self {
        self.io_surface = io_surface;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExportMetalSharedEventInfoEXT.html>"]
pub struct ExportMetalSharedEventInfoEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub semaphore: Semaphore,
    pub event: Event,
    pub mtl_shared_event: MTLSharedEvent_id,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for ExportMetalSharedEventInfoEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            semaphore: Semaphore::default(),
            event: Event::default(),
            mtl_shared_event: unsafe { ::std::mem::zeroed() },
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for ExportMetalSharedEventInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::EXPORT_METAL_SHARED_EVENT_INFO_EXT;
}
unsafe impl ExtendsExportMetalObjectsInfoEXT for ExportMetalSharedEventInfoEXT<'_> {}
impl<'a> ExportMetalSharedEventInfoEXT<'a> {
    #[inline]
    pub fn semaphore(mut self, semaphore: Semaphore) -> Self {
        self.semaphore = semaphore;
        self
    }
    #[inline]
    pub fn event(mut self, event: Event) -> Self {
        self.event = event;
        self
    }
    #[inline]
    pub fn mtl_shared_event(mut self, mtl_shared_event: MTLSharedEvent_id) -> Self {
        self.mtl_shared_event = mtl_shared_event;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImportMetalSharedEventInfoEXT.html>"]
pub struct ImportMetalSharedEventInfoEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub mtl_shared_event: MTLSharedEvent_id,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for ImportMetalSharedEventInfoEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            mtl_shared_event: unsafe { ::std::mem::zeroed() },
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for ImportMetalSharedEventInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::IMPORT_METAL_SHARED_EVENT_INFO_EXT;
}
unsafe impl ExtendsSemaphoreCreateInfo for ImportMetalSharedEventInfoEXT<'_> {}
unsafe impl ExtendsEventCreateInfo for ImportMetalSharedEventInfoEXT<'_> {}
impl<'a> ImportMetalSharedEventInfoEXT<'a> {
    #[inline]
    pub fn mtl_shared_event(mut self, mtl_shared_event: MTLSharedEvent_id) -> Self {
        self.mtl_shared_event = mtl_shared_event;
        self
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT.html>"]
pub struct PhysicalDeviceNonSeamlessCubeMapFeaturesEXT<'a> {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub non_seamless_cube_map: Bool32,
    pub _marker: PhantomData<&'a ()>,
}
impl ::std::default::Default for PhysicalDeviceNonSeamlessCubeMapFeaturesEXT<'_> {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            non_seamless_cube_map: Bool32::default(),
            _marker: PhantomData,
        }
    }
}
unsafe impl<'a> TaggedStructure for PhysicalDeviceNonSeamlessCubeMapFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT;
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceNonSeamlessCubeMapFeaturesEXT<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceNonSeamlessCubeMapFeaturesEXT<'_> {}
impl<'a> PhysicalDeviceNonSeamlessCubeMapFeaturesEXT<'a> {
    #[inline]
    pub fn non_seamless_cube_map(mut self, non_seamless_cube_map: bool) -> Self {
        self.non_seamless_cube_map = non_seamless_cube_map.into();
        self
    }
}
